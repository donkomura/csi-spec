// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lib/cxx/.protoc/csi.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/descriptor.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/wrappers.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
namespace csi {
namespace v1 {
class CapacityRange;
struct CapacityRangeDefaultTypeInternal;
extern CapacityRangeDefaultTypeInternal _CapacityRange_default_instance_;
class ControllerExpandVolumeRequest;
struct ControllerExpandVolumeRequestDefaultTypeInternal;
extern ControllerExpandVolumeRequestDefaultTypeInternal _ControllerExpandVolumeRequest_default_instance_;
class ControllerExpandVolumeRequest_SecretsEntry_DoNotUse;
struct ControllerExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerExpandVolumeResponse;
struct ControllerExpandVolumeResponseDefaultTypeInternal;
extern ControllerExpandVolumeResponseDefaultTypeInternal _ControllerExpandVolumeResponse_default_instance_;
class ControllerGetCapabilitiesRequest;
struct ControllerGetCapabilitiesRequestDefaultTypeInternal;
extern ControllerGetCapabilitiesRequestDefaultTypeInternal _ControllerGetCapabilitiesRequest_default_instance_;
class ControllerGetCapabilitiesResponse;
struct ControllerGetCapabilitiesResponseDefaultTypeInternal;
extern ControllerGetCapabilitiesResponseDefaultTypeInternal _ControllerGetCapabilitiesResponse_default_instance_;
class ControllerGetVolumeRequest;
struct ControllerGetVolumeRequestDefaultTypeInternal;
extern ControllerGetVolumeRequestDefaultTypeInternal _ControllerGetVolumeRequest_default_instance_;
class ControllerGetVolumeResponse;
struct ControllerGetVolumeResponseDefaultTypeInternal;
extern ControllerGetVolumeResponseDefaultTypeInternal _ControllerGetVolumeResponse_default_instance_;
class ControllerGetVolumeResponse_VolumeStatus;
struct ControllerGetVolumeResponse_VolumeStatusDefaultTypeInternal;
extern ControllerGetVolumeResponse_VolumeStatusDefaultTypeInternal _ControllerGetVolumeResponse_VolumeStatus_default_instance_;
class ControllerModifyVolumeRequest;
struct ControllerModifyVolumeRequestDefaultTypeInternal;
extern ControllerModifyVolumeRequestDefaultTypeInternal _ControllerModifyVolumeRequest_default_instance_;
class ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse;
struct ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal;
extern ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal _ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse_default_instance_;
class ControllerModifyVolumeRequest_SecretsEntry_DoNotUse;
struct ControllerModifyVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerModifyVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerModifyVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerModifyVolumeResponse;
struct ControllerModifyVolumeResponseDefaultTypeInternal;
extern ControllerModifyVolumeResponseDefaultTypeInternal _ControllerModifyVolumeResponse_default_instance_;
class ControllerPublishVolumeRequest;
struct ControllerPublishVolumeRequestDefaultTypeInternal;
extern ControllerPublishVolumeRequestDefaultTypeInternal _ControllerPublishVolumeRequest_default_instance_;
class ControllerPublishVolumeRequest_SecretsEntry_DoNotUse;
struct ControllerPublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse;
struct ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class ControllerPublishVolumeResponse;
struct ControllerPublishVolumeResponseDefaultTypeInternal;
extern ControllerPublishVolumeResponseDefaultTypeInternal _ControllerPublishVolumeResponse_default_instance_;
class ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse;
struct ControllerPublishVolumeResponse_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeResponse_PublishContextEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse_default_instance_;
class ControllerServiceCapability;
struct ControllerServiceCapabilityDefaultTypeInternal;
extern ControllerServiceCapabilityDefaultTypeInternal _ControllerServiceCapability_default_instance_;
class ControllerServiceCapability_RPC;
struct ControllerServiceCapability_RPCDefaultTypeInternal;
extern ControllerServiceCapability_RPCDefaultTypeInternal _ControllerServiceCapability_RPC_default_instance_;
class ControllerUnpublishVolumeRequest;
struct ControllerUnpublishVolumeRequestDefaultTypeInternal;
extern ControllerUnpublishVolumeRequestDefaultTypeInternal _ControllerUnpublishVolumeRequest_default_instance_;
class ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse;
struct ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerUnpublishVolumeResponse;
struct ControllerUnpublishVolumeResponseDefaultTypeInternal;
extern ControllerUnpublishVolumeResponseDefaultTypeInternal _ControllerUnpublishVolumeResponse_default_instance_;
class CreateSnapshotRequest;
struct CreateSnapshotRequestDefaultTypeInternal;
extern CreateSnapshotRequestDefaultTypeInternal _CreateSnapshotRequest_default_instance_;
class CreateSnapshotRequest_ParametersEntry_DoNotUse;
struct CreateSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal _CreateSnapshotRequest_ParametersEntry_DoNotUse_default_instance_;
class CreateSnapshotRequest_SecretsEntry_DoNotUse;
struct CreateSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern CreateSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _CreateSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class CreateSnapshotResponse;
struct CreateSnapshotResponseDefaultTypeInternal;
extern CreateSnapshotResponseDefaultTypeInternal _CreateSnapshotResponse_default_instance_;
class CreateVolumeGroupSnapshotRequest;
struct CreateVolumeGroupSnapshotRequestDefaultTypeInternal;
extern CreateVolumeGroupSnapshotRequestDefaultTypeInternal _CreateVolumeGroupSnapshotRequest_default_instance_;
class CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse;
struct CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal _CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse_default_instance_;
class CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse;
struct CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class CreateVolumeGroupSnapshotResponse;
struct CreateVolumeGroupSnapshotResponseDefaultTypeInternal;
extern CreateVolumeGroupSnapshotResponseDefaultTypeInternal _CreateVolumeGroupSnapshotResponse_default_instance_;
class CreateVolumeRequest;
struct CreateVolumeRequestDefaultTypeInternal;
extern CreateVolumeRequestDefaultTypeInternal _CreateVolumeRequest_default_instance_;
class CreateVolumeRequest_MutableParametersEntry_DoNotUse;
struct CreateVolumeRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal _CreateVolumeRequest_MutableParametersEntry_DoNotUse_default_instance_;
class CreateVolumeRequest_ParametersEntry_DoNotUse;
struct CreateVolumeRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeRequest_ParametersEntry_DoNotUseDefaultTypeInternal _CreateVolumeRequest_ParametersEntry_DoNotUse_default_instance_;
class CreateVolumeRequest_SecretsEntry_DoNotUse;
struct CreateVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _CreateVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class CreateVolumeResponse;
struct CreateVolumeResponseDefaultTypeInternal;
extern CreateVolumeResponseDefaultTypeInternal _CreateVolumeResponse_default_instance_;
class DeleteSnapshotRequest;
struct DeleteSnapshotRequestDefaultTypeInternal;
extern DeleteSnapshotRequestDefaultTypeInternal _DeleteSnapshotRequest_default_instance_;
class DeleteSnapshotRequest_SecretsEntry_DoNotUse;
struct DeleteSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern DeleteSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _DeleteSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class DeleteSnapshotResponse;
struct DeleteSnapshotResponseDefaultTypeInternal;
extern DeleteSnapshotResponseDefaultTypeInternal _DeleteSnapshotResponse_default_instance_;
class DeleteVolumeGroupSnapshotRequest;
struct DeleteVolumeGroupSnapshotRequestDefaultTypeInternal;
extern DeleteVolumeGroupSnapshotRequestDefaultTypeInternal _DeleteVolumeGroupSnapshotRequest_default_instance_;
class DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse;
struct DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class DeleteVolumeGroupSnapshotResponse;
struct DeleteVolumeGroupSnapshotResponseDefaultTypeInternal;
extern DeleteVolumeGroupSnapshotResponseDefaultTypeInternal _DeleteVolumeGroupSnapshotResponse_default_instance_;
class DeleteVolumeRequest;
struct DeleteVolumeRequestDefaultTypeInternal;
extern DeleteVolumeRequestDefaultTypeInternal _DeleteVolumeRequest_default_instance_;
class DeleteVolumeRequest_SecretsEntry_DoNotUse;
struct DeleteVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern DeleteVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _DeleteVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class DeleteVolumeResponse;
struct DeleteVolumeResponseDefaultTypeInternal;
extern DeleteVolumeResponseDefaultTypeInternal _DeleteVolumeResponse_default_instance_;
class GetCapacityRequest;
struct GetCapacityRequestDefaultTypeInternal;
extern GetCapacityRequestDefaultTypeInternal _GetCapacityRequest_default_instance_;
class GetCapacityRequest_ParametersEntry_DoNotUse;
struct GetCapacityRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern GetCapacityRequest_ParametersEntry_DoNotUseDefaultTypeInternal _GetCapacityRequest_ParametersEntry_DoNotUse_default_instance_;
class GetCapacityResponse;
struct GetCapacityResponseDefaultTypeInternal;
extern GetCapacityResponseDefaultTypeInternal _GetCapacityResponse_default_instance_;
class GetPluginCapabilitiesRequest;
struct GetPluginCapabilitiesRequestDefaultTypeInternal;
extern GetPluginCapabilitiesRequestDefaultTypeInternal _GetPluginCapabilitiesRequest_default_instance_;
class GetPluginCapabilitiesResponse;
struct GetPluginCapabilitiesResponseDefaultTypeInternal;
extern GetPluginCapabilitiesResponseDefaultTypeInternal _GetPluginCapabilitiesResponse_default_instance_;
class GetPluginInfoRequest;
struct GetPluginInfoRequestDefaultTypeInternal;
extern GetPluginInfoRequestDefaultTypeInternal _GetPluginInfoRequest_default_instance_;
class GetPluginInfoResponse;
struct GetPluginInfoResponseDefaultTypeInternal;
extern GetPluginInfoResponseDefaultTypeInternal _GetPluginInfoResponse_default_instance_;
class GetPluginInfoResponse_ManifestEntry_DoNotUse;
struct GetPluginInfoResponse_ManifestEntry_DoNotUseDefaultTypeInternal;
extern GetPluginInfoResponse_ManifestEntry_DoNotUseDefaultTypeInternal _GetPluginInfoResponse_ManifestEntry_DoNotUse_default_instance_;
class GetVolumeGroupSnapshotRequest;
struct GetVolumeGroupSnapshotRequestDefaultTypeInternal;
extern GetVolumeGroupSnapshotRequestDefaultTypeInternal _GetVolumeGroupSnapshotRequest_default_instance_;
class GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse;
struct GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class GetVolumeGroupSnapshotResponse;
struct GetVolumeGroupSnapshotResponseDefaultTypeInternal;
extern GetVolumeGroupSnapshotResponseDefaultTypeInternal _GetVolumeGroupSnapshotResponse_default_instance_;
class GroupControllerGetCapabilitiesRequest;
struct GroupControllerGetCapabilitiesRequestDefaultTypeInternal;
extern GroupControllerGetCapabilitiesRequestDefaultTypeInternal _GroupControllerGetCapabilitiesRequest_default_instance_;
class GroupControllerGetCapabilitiesResponse;
struct GroupControllerGetCapabilitiesResponseDefaultTypeInternal;
extern GroupControllerGetCapabilitiesResponseDefaultTypeInternal _GroupControllerGetCapabilitiesResponse_default_instance_;
class GroupControllerServiceCapability;
struct GroupControllerServiceCapabilityDefaultTypeInternal;
extern GroupControllerServiceCapabilityDefaultTypeInternal _GroupControllerServiceCapability_default_instance_;
class GroupControllerServiceCapability_RPC;
struct GroupControllerServiceCapability_RPCDefaultTypeInternal;
extern GroupControllerServiceCapability_RPCDefaultTypeInternal _GroupControllerServiceCapability_RPC_default_instance_;
class ListSnapshotsRequest;
struct ListSnapshotsRequestDefaultTypeInternal;
extern ListSnapshotsRequestDefaultTypeInternal _ListSnapshotsRequest_default_instance_;
class ListSnapshotsRequest_SecretsEntry_DoNotUse;
struct ListSnapshotsRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ListSnapshotsRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ListSnapshotsRequest_SecretsEntry_DoNotUse_default_instance_;
class ListSnapshotsResponse;
struct ListSnapshotsResponseDefaultTypeInternal;
extern ListSnapshotsResponseDefaultTypeInternal _ListSnapshotsResponse_default_instance_;
class ListSnapshotsResponse_Entry;
struct ListSnapshotsResponse_EntryDefaultTypeInternal;
extern ListSnapshotsResponse_EntryDefaultTypeInternal _ListSnapshotsResponse_Entry_default_instance_;
class ListVolumesRequest;
struct ListVolumesRequestDefaultTypeInternal;
extern ListVolumesRequestDefaultTypeInternal _ListVolumesRequest_default_instance_;
class ListVolumesResponse;
struct ListVolumesResponseDefaultTypeInternal;
extern ListVolumesResponseDefaultTypeInternal _ListVolumesResponse_default_instance_;
class ListVolumesResponse_Entry;
struct ListVolumesResponse_EntryDefaultTypeInternal;
extern ListVolumesResponse_EntryDefaultTypeInternal _ListVolumesResponse_Entry_default_instance_;
class ListVolumesResponse_VolumeStatus;
struct ListVolumesResponse_VolumeStatusDefaultTypeInternal;
extern ListVolumesResponse_VolumeStatusDefaultTypeInternal _ListVolumesResponse_VolumeStatus_default_instance_;
class NodeExpandVolumeRequest;
struct NodeExpandVolumeRequestDefaultTypeInternal;
extern NodeExpandVolumeRequestDefaultTypeInternal _NodeExpandVolumeRequest_default_instance_;
class NodeExpandVolumeRequest_SecretsEntry_DoNotUse;
struct NodeExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodeExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodeExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodeExpandVolumeResponse;
struct NodeExpandVolumeResponseDefaultTypeInternal;
extern NodeExpandVolumeResponseDefaultTypeInternal _NodeExpandVolumeResponse_default_instance_;
class NodeGetCapabilitiesRequest;
struct NodeGetCapabilitiesRequestDefaultTypeInternal;
extern NodeGetCapabilitiesRequestDefaultTypeInternal _NodeGetCapabilitiesRequest_default_instance_;
class NodeGetCapabilitiesResponse;
struct NodeGetCapabilitiesResponseDefaultTypeInternal;
extern NodeGetCapabilitiesResponseDefaultTypeInternal _NodeGetCapabilitiesResponse_default_instance_;
class NodeGetInfoRequest;
struct NodeGetInfoRequestDefaultTypeInternal;
extern NodeGetInfoRequestDefaultTypeInternal _NodeGetInfoRequest_default_instance_;
class NodeGetInfoResponse;
struct NodeGetInfoResponseDefaultTypeInternal;
extern NodeGetInfoResponseDefaultTypeInternal _NodeGetInfoResponse_default_instance_;
class NodeGetVolumeStatsRequest;
struct NodeGetVolumeStatsRequestDefaultTypeInternal;
extern NodeGetVolumeStatsRequestDefaultTypeInternal _NodeGetVolumeStatsRequest_default_instance_;
class NodeGetVolumeStatsResponse;
struct NodeGetVolumeStatsResponseDefaultTypeInternal;
extern NodeGetVolumeStatsResponseDefaultTypeInternal _NodeGetVolumeStatsResponse_default_instance_;
class NodePublishVolumeRequest;
struct NodePublishVolumeRequestDefaultTypeInternal;
extern NodePublishVolumeRequestDefaultTypeInternal _NodePublishVolumeRequest_default_instance_;
class NodePublishVolumeRequest_PublishContextEntry_DoNotUse;
struct NodePublishVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_PublishContextEntry_DoNotUse_default_instance_;
class NodePublishVolumeRequest_SecretsEntry_DoNotUse;
struct NodePublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodePublishVolumeRequest_VolumeContextEntry_DoNotUse;
struct NodePublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class NodePublishVolumeResponse;
struct NodePublishVolumeResponseDefaultTypeInternal;
extern NodePublishVolumeResponseDefaultTypeInternal _NodePublishVolumeResponse_default_instance_;
class NodeServiceCapability;
struct NodeServiceCapabilityDefaultTypeInternal;
extern NodeServiceCapabilityDefaultTypeInternal _NodeServiceCapability_default_instance_;
class NodeServiceCapability_RPC;
struct NodeServiceCapability_RPCDefaultTypeInternal;
extern NodeServiceCapability_RPCDefaultTypeInternal _NodeServiceCapability_RPC_default_instance_;
class NodeStageVolumeRequest;
struct NodeStageVolumeRequestDefaultTypeInternal;
extern NodeStageVolumeRequestDefaultTypeInternal _NodeStageVolumeRequest_default_instance_;
class NodeStageVolumeRequest_PublishContextEntry_DoNotUse;
struct NodeStageVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_PublishContextEntry_DoNotUse_default_instance_;
class NodeStageVolumeRequest_SecretsEntry_DoNotUse;
struct NodeStageVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodeStageVolumeRequest_VolumeContextEntry_DoNotUse;
struct NodeStageVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class NodeStageVolumeResponse;
struct NodeStageVolumeResponseDefaultTypeInternal;
extern NodeStageVolumeResponseDefaultTypeInternal _NodeStageVolumeResponse_default_instance_;
class NodeUnpublishVolumeRequest;
struct NodeUnpublishVolumeRequestDefaultTypeInternal;
extern NodeUnpublishVolumeRequestDefaultTypeInternal _NodeUnpublishVolumeRequest_default_instance_;
class NodeUnpublishVolumeResponse;
struct NodeUnpublishVolumeResponseDefaultTypeInternal;
extern NodeUnpublishVolumeResponseDefaultTypeInternal _NodeUnpublishVolumeResponse_default_instance_;
class NodeUnstageVolumeRequest;
struct NodeUnstageVolumeRequestDefaultTypeInternal;
extern NodeUnstageVolumeRequestDefaultTypeInternal _NodeUnstageVolumeRequest_default_instance_;
class NodeUnstageVolumeResponse;
struct NodeUnstageVolumeResponseDefaultTypeInternal;
extern NodeUnstageVolumeResponseDefaultTypeInternal _NodeUnstageVolumeResponse_default_instance_;
class PluginCapability;
struct PluginCapabilityDefaultTypeInternal;
extern PluginCapabilityDefaultTypeInternal _PluginCapability_default_instance_;
class PluginCapability_Service;
struct PluginCapability_ServiceDefaultTypeInternal;
extern PluginCapability_ServiceDefaultTypeInternal _PluginCapability_Service_default_instance_;
class PluginCapability_VolumeExpansion;
struct PluginCapability_VolumeExpansionDefaultTypeInternal;
extern PluginCapability_VolumeExpansionDefaultTypeInternal _PluginCapability_VolumeExpansion_default_instance_;
class ProbeRequest;
struct ProbeRequestDefaultTypeInternal;
extern ProbeRequestDefaultTypeInternal _ProbeRequest_default_instance_;
class ProbeResponse;
struct ProbeResponseDefaultTypeInternal;
extern ProbeResponseDefaultTypeInternal _ProbeResponse_default_instance_;
class Snapshot;
struct SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class Topology;
struct TopologyDefaultTypeInternal;
extern TopologyDefaultTypeInternal _Topology_default_instance_;
class TopologyRequirement;
struct TopologyRequirementDefaultTypeInternal;
extern TopologyRequirementDefaultTypeInternal _TopologyRequirement_default_instance_;
class Topology_SegmentsEntry_DoNotUse;
struct Topology_SegmentsEntry_DoNotUseDefaultTypeInternal;
extern Topology_SegmentsEntry_DoNotUseDefaultTypeInternal _Topology_SegmentsEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest;
struct ValidateVolumeCapabilitiesRequestDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequestDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_default_instance_;
class ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse;
struct ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse;
struct ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse;
struct ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse;
struct ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesResponse;
struct ValidateVolumeCapabilitiesResponseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed;
struct ValidateVolumeCapabilitiesResponse_ConfirmedDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_ConfirmedDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse;
struct ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse;
struct ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse;
struct ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse_default_instance_;
class Volume;
struct VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class VolumeCapability;
struct VolumeCapabilityDefaultTypeInternal;
extern VolumeCapabilityDefaultTypeInternal _VolumeCapability_default_instance_;
class VolumeCapability_AccessMode;
struct VolumeCapability_AccessModeDefaultTypeInternal;
extern VolumeCapability_AccessModeDefaultTypeInternal _VolumeCapability_AccessMode_default_instance_;
class VolumeCapability_BlockVolume;
struct VolumeCapability_BlockVolumeDefaultTypeInternal;
extern VolumeCapability_BlockVolumeDefaultTypeInternal _VolumeCapability_BlockVolume_default_instance_;
class VolumeCapability_MountVolume;
struct VolumeCapability_MountVolumeDefaultTypeInternal;
extern VolumeCapability_MountVolumeDefaultTypeInternal _VolumeCapability_MountVolume_default_instance_;
class VolumeCondition;
struct VolumeConditionDefaultTypeInternal;
extern VolumeConditionDefaultTypeInternal _VolumeCondition_default_instance_;
class VolumeContentSource;
struct VolumeContentSourceDefaultTypeInternal;
extern VolumeContentSourceDefaultTypeInternal _VolumeContentSource_default_instance_;
class VolumeContentSource_SnapshotSource;
struct VolumeContentSource_SnapshotSourceDefaultTypeInternal;
extern VolumeContentSource_SnapshotSourceDefaultTypeInternal _VolumeContentSource_SnapshotSource_default_instance_;
class VolumeContentSource_VolumeSource;
struct VolumeContentSource_VolumeSourceDefaultTypeInternal;
extern VolumeContentSource_VolumeSourceDefaultTypeInternal _VolumeContentSource_VolumeSource_default_instance_;
class VolumeGroupSnapshot;
struct VolumeGroupSnapshotDefaultTypeInternal;
extern VolumeGroupSnapshotDefaultTypeInternal _VolumeGroupSnapshot_default_instance_;
class VolumeUsage;
struct VolumeUsageDefaultTypeInternal;
extern VolumeUsageDefaultTypeInternal _VolumeUsage_default_instance_;
class Volume_VolumeContextEntry_DoNotUse;
struct Volume_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern Volume_VolumeContextEntry_DoNotUseDefaultTypeInternal _Volume_VolumeContextEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace csi
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace csi {
namespace v1 {
enum PluginCapability_Service_Type : int {
  PluginCapability_Service_Type_UNKNOWN = 0,
  PluginCapability_Service_Type_CONTROLLER_SERVICE = 1,
  PluginCapability_Service_Type_VOLUME_ACCESSIBILITY_CONSTRAINTS = 2,
  PluginCapability_Service_Type_GROUP_CONTROLLER_SERVICE = 3,
  PluginCapability_Service_Type_PluginCapability_Service_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PluginCapability_Service_Type_PluginCapability_Service_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PluginCapability_Service_Type_IsValid(int value);
extern const uint32_t PluginCapability_Service_Type_internal_data_[];
constexpr PluginCapability_Service_Type PluginCapability_Service_Type_Type_MIN = static_cast<PluginCapability_Service_Type>(0);
constexpr PluginCapability_Service_Type PluginCapability_Service_Type_Type_MAX = static_cast<PluginCapability_Service_Type>(3);
constexpr int PluginCapability_Service_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
PluginCapability_Service_Type_descriptor();
template <typename T>
const std::string& PluginCapability_Service_Type_Name(T value) {
  static_assert(std::is_same<T, PluginCapability_Service_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return PluginCapability_Service_Type_Name(static_cast<PluginCapability_Service_Type>(value));
}
template <>
inline const std::string& PluginCapability_Service_Type_Name(PluginCapability_Service_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PluginCapability_Service_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool PluginCapability_Service_Type_Parse(absl::string_view name, PluginCapability_Service_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PluginCapability_Service_Type>(
      PluginCapability_Service_Type_descriptor(), name, value);
}
enum PluginCapability_VolumeExpansion_Type : int {
  PluginCapability_VolumeExpansion_Type_UNKNOWN = 0,
  PluginCapability_VolumeExpansion_Type_ONLINE = 1,
  PluginCapability_VolumeExpansion_Type_OFFLINE = 2,
  PluginCapability_VolumeExpansion_Type_PluginCapability_VolumeExpansion_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  PluginCapability_VolumeExpansion_Type_PluginCapability_VolumeExpansion_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool PluginCapability_VolumeExpansion_Type_IsValid(int value);
extern const uint32_t PluginCapability_VolumeExpansion_Type_internal_data_[];
constexpr PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion_Type_Type_MIN = static_cast<PluginCapability_VolumeExpansion_Type>(0);
constexpr PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion_Type_Type_MAX = static_cast<PluginCapability_VolumeExpansion_Type>(2);
constexpr int PluginCapability_VolumeExpansion_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
PluginCapability_VolumeExpansion_Type_descriptor();
template <typename T>
const std::string& PluginCapability_VolumeExpansion_Type_Name(T value) {
  static_assert(std::is_same<T, PluginCapability_VolumeExpansion_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return PluginCapability_VolumeExpansion_Type_Name(static_cast<PluginCapability_VolumeExpansion_Type>(value));
}
template <>
inline const std::string& PluginCapability_VolumeExpansion_Type_Name(PluginCapability_VolumeExpansion_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<PluginCapability_VolumeExpansion_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool PluginCapability_VolumeExpansion_Type_Parse(absl::string_view name, PluginCapability_VolumeExpansion_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PluginCapability_VolumeExpansion_Type>(
      PluginCapability_VolumeExpansion_Type_descriptor(), name, value);
}
enum VolumeCapability_AccessMode_Mode : int {
  VolumeCapability_AccessMode_Mode_UNKNOWN = 0,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_WRITER = 1,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_READER_ONLY = 2,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_READER_ONLY = 3,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_SINGLE_WRITER = 4,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_MULTI_WRITER = 5,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_SINGLE_WRITER = 6,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_MULTI_WRITER = 7,
  VolumeCapability_AccessMode_Mode_VolumeCapability_AccessMode_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VolumeCapability_AccessMode_Mode_VolumeCapability_AccessMode_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VolumeCapability_AccessMode_Mode_IsValid(int value);
extern const uint32_t VolumeCapability_AccessMode_Mode_internal_data_[];
constexpr VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode_Mode_Mode_MIN = static_cast<VolumeCapability_AccessMode_Mode>(0);
constexpr VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode_Mode_Mode_MAX = static_cast<VolumeCapability_AccessMode_Mode>(7);
constexpr int VolumeCapability_AccessMode_Mode_Mode_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
VolumeCapability_AccessMode_Mode_descriptor();
template <typename T>
const std::string& VolumeCapability_AccessMode_Mode_Name(T value) {
  static_assert(std::is_same<T, VolumeCapability_AccessMode_Mode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Mode_Name().");
  return VolumeCapability_AccessMode_Mode_Name(static_cast<VolumeCapability_AccessMode_Mode>(value));
}
template <>
inline const std::string& VolumeCapability_AccessMode_Mode_Name(VolumeCapability_AccessMode_Mode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VolumeCapability_AccessMode_Mode_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool VolumeCapability_AccessMode_Mode_Parse(absl::string_view name, VolumeCapability_AccessMode_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeCapability_AccessMode_Mode>(
      VolumeCapability_AccessMode_Mode_descriptor(), name, value);
}
enum ControllerServiceCapability_RPC_Type : int {
  ControllerServiceCapability_RPC_Type_UNKNOWN = 0,
  ControllerServiceCapability_RPC_Type_CREATE_DELETE_VOLUME = 1,
  ControllerServiceCapability_RPC_Type_PUBLISH_UNPUBLISH_VOLUME = 2,
  ControllerServiceCapability_RPC_Type_LIST_VOLUMES = 3,
  ControllerServiceCapability_RPC_Type_GET_CAPACITY = 4,
  ControllerServiceCapability_RPC_Type_CREATE_DELETE_SNAPSHOT = 5,
  ControllerServiceCapability_RPC_Type_LIST_SNAPSHOTS = 6,
  ControllerServiceCapability_RPC_Type_CLONE_VOLUME = 7,
  ControllerServiceCapability_RPC_Type_PUBLISH_READONLY = 8,
  ControllerServiceCapability_RPC_Type_EXPAND_VOLUME = 9,
  ControllerServiceCapability_RPC_Type_LIST_VOLUMES_PUBLISHED_NODES = 10,
  ControllerServiceCapability_RPC_Type_VOLUME_CONDITION = 11,
  ControllerServiceCapability_RPC_Type_GET_VOLUME = 12,
  ControllerServiceCapability_RPC_Type_SINGLE_NODE_MULTI_WRITER = 13,
  ControllerServiceCapability_RPC_Type_MODIFY_VOLUME = 14,
  ControllerServiceCapability_RPC_Type_ControllerServiceCapability_RPC_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ControllerServiceCapability_RPC_Type_ControllerServiceCapability_RPC_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ControllerServiceCapability_RPC_Type_IsValid(int value);
extern const uint32_t ControllerServiceCapability_RPC_Type_internal_data_[];
constexpr ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC_Type_Type_MIN = static_cast<ControllerServiceCapability_RPC_Type>(0);
constexpr ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC_Type_Type_MAX = static_cast<ControllerServiceCapability_RPC_Type>(14);
constexpr int ControllerServiceCapability_RPC_Type_Type_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
ControllerServiceCapability_RPC_Type_descriptor();
template <typename T>
const std::string& ControllerServiceCapability_RPC_Type_Name(T value) {
  static_assert(std::is_same<T, ControllerServiceCapability_RPC_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return ControllerServiceCapability_RPC_Type_Name(static_cast<ControllerServiceCapability_RPC_Type>(value));
}
template <>
inline const std::string& ControllerServiceCapability_RPC_Type_Name(ControllerServiceCapability_RPC_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ControllerServiceCapability_RPC_Type_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool ControllerServiceCapability_RPC_Type_Parse(absl::string_view name, ControllerServiceCapability_RPC_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControllerServiceCapability_RPC_Type>(
      ControllerServiceCapability_RPC_Type_descriptor(), name, value);
}
enum VolumeUsage_Unit : int {
  VolumeUsage_Unit_UNKNOWN = 0,
  VolumeUsage_Unit_BYTES = 1,
  VolumeUsage_Unit_INODES = 2,
  VolumeUsage_Unit_VolumeUsage_Unit_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  VolumeUsage_Unit_VolumeUsage_Unit_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool VolumeUsage_Unit_IsValid(int value);
extern const uint32_t VolumeUsage_Unit_internal_data_[];
constexpr VolumeUsage_Unit VolumeUsage_Unit_Unit_MIN = static_cast<VolumeUsage_Unit>(0);
constexpr VolumeUsage_Unit VolumeUsage_Unit_Unit_MAX = static_cast<VolumeUsage_Unit>(2);
constexpr int VolumeUsage_Unit_Unit_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VolumeUsage_Unit_descriptor();
template <typename T>
const std::string& VolumeUsage_Unit_Name(T value) {
  static_assert(std::is_same<T, VolumeUsage_Unit>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Unit_Name().");
  return VolumeUsage_Unit_Name(static_cast<VolumeUsage_Unit>(value));
}
template <>
inline const std::string& VolumeUsage_Unit_Name(VolumeUsage_Unit value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VolumeUsage_Unit_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VolumeUsage_Unit_Parse(absl::string_view name, VolumeUsage_Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeUsage_Unit>(
      VolumeUsage_Unit_descriptor(), name, value);
}
enum NodeServiceCapability_RPC_Type : int {
  NodeServiceCapability_RPC_Type_UNKNOWN = 0,
  NodeServiceCapability_RPC_Type_STAGE_UNSTAGE_VOLUME = 1,
  NodeServiceCapability_RPC_Type_GET_VOLUME_STATS = 2,
  NodeServiceCapability_RPC_Type_EXPAND_VOLUME = 3,
  NodeServiceCapability_RPC_Type_VOLUME_CONDITION = 4,
  NodeServiceCapability_RPC_Type_SINGLE_NODE_MULTI_WRITER = 5,
  NodeServiceCapability_RPC_Type_VOLUME_MOUNT_GROUP = 6,
  NodeServiceCapability_RPC_Type_NodeServiceCapability_RPC_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeServiceCapability_RPC_Type_NodeServiceCapability_RPC_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeServiceCapability_RPC_Type_IsValid(int value);
extern const uint32_t NodeServiceCapability_RPC_Type_internal_data_[];
constexpr NodeServiceCapability_RPC_Type NodeServiceCapability_RPC_Type_Type_MIN = static_cast<NodeServiceCapability_RPC_Type>(0);
constexpr NodeServiceCapability_RPC_Type NodeServiceCapability_RPC_Type_Type_MAX = static_cast<NodeServiceCapability_RPC_Type>(6);
constexpr int NodeServiceCapability_RPC_Type_Type_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
NodeServiceCapability_RPC_Type_descriptor();
template <typename T>
const std::string& NodeServiceCapability_RPC_Type_Name(T value) {
  static_assert(std::is_same<T, NodeServiceCapability_RPC_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return NodeServiceCapability_RPC_Type_Name(static_cast<NodeServiceCapability_RPC_Type>(value));
}
template <>
inline const std::string& NodeServiceCapability_RPC_Type_Name(NodeServiceCapability_RPC_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeServiceCapability_RPC_Type_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool NodeServiceCapability_RPC_Type_Parse(absl::string_view name, NodeServiceCapability_RPC_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeServiceCapability_RPC_Type>(
      NodeServiceCapability_RPC_Type_descriptor(), name, value);
}
enum GroupControllerServiceCapability_RPC_Type : int {
  GroupControllerServiceCapability_RPC_Type_UNKNOWN = 0,
  GroupControllerServiceCapability_RPC_Type_CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT = 1,
  GroupControllerServiceCapability_RPC_Type_GroupControllerServiceCapability_RPC_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GroupControllerServiceCapability_RPC_Type_GroupControllerServiceCapability_RPC_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GroupControllerServiceCapability_RPC_Type_IsValid(int value);
extern const uint32_t GroupControllerServiceCapability_RPC_Type_internal_data_[];
constexpr GroupControllerServiceCapability_RPC_Type GroupControllerServiceCapability_RPC_Type_Type_MIN = static_cast<GroupControllerServiceCapability_RPC_Type>(0);
constexpr GroupControllerServiceCapability_RPC_Type GroupControllerServiceCapability_RPC_Type_Type_MAX = static_cast<GroupControllerServiceCapability_RPC_Type>(1);
constexpr int GroupControllerServiceCapability_RPC_Type_Type_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
GroupControllerServiceCapability_RPC_Type_descriptor();
template <typename T>
const std::string& GroupControllerServiceCapability_RPC_Type_Name(T value) {
  static_assert(std::is_same<T, GroupControllerServiceCapability_RPC_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return GroupControllerServiceCapability_RPC_Type_Name(static_cast<GroupControllerServiceCapability_RPC_Type>(value));
}
template <>
inline const std::string& GroupControllerServiceCapability_RPC_Type_Name(GroupControllerServiceCapability_RPC_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GroupControllerServiceCapability_RPC_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool GroupControllerServiceCapability_RPC_Type_Parse(absl::string_view name, GroupControllerServiceCapability_RPC_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupControllerServiceCapability_RPC_Type>(
      GroupControllerServiceCapability_RPC_Type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VolumeUsage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeUsage) */ {
 public:
  inline VolumeUsage() : VolumeUsage(nullptr) {}
  ~VolumeUsage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeUsage(::google::protobuf::internal::ConstantInitialized);

  inline VolumeUsage(const VolumeUsage& from)
      : VolumeUsage(nullptr, from) {}
  VolumeUsage(VolumeUsage&& from) noexcept
    : VolumeUsage() {
    *this = ::std::move(from);
  }

  inline VolumeUsage& operator=(const VolumeUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeUsage& operator=(VolumeUsage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeUsage& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeUsage* internal_default_instance() {
    return reinterpret_cast<const VolumeUsage*>(
               &_VolumeUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(VolumeUsage& a, VolumeUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeUsage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeUsage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeUsage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeUsage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeUsage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeUsage& from) {
    VolumeUsage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeUsage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeUsage";
  }
  protected:
  explicit VolumeUsage(::google::protobuf::Arena* arena);
  VolumeUsage(::google::protobuf::Arena* arena, const VolumeUsage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Unit = VolumeUsage_Unit;
  static constexpr Unit UNKNOWN = VolumeUsage_Unit_UNKNOWN;
  static constexpr Unit BYTES = VolumeUsage_Unit_BYTES;
  static constexpr Unit INODES = VolumeUsage_Unit_INODES;
  static inline bool Unit_IsValid(int value) {
    return VolumeUsage_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN = VolumeUsage_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX = VolumeUsage_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE = VolumeUsage_Unit_Unit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Unit_descriptor() {
    return VolumeUsage_Unit_descriptor();
  }
  template <typename T>
  static inline const std::string& Unit_Name(T value) {
    return VolumeUsage_Unit_Name(value);
  }
  static inline bool Unit_Parse(absl::string_view name, Unit* value) {
    return VolumeUsage_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableFieldNumber = 1,
    kTotalFieldNumber = 2,
    kUsedFieldNumber = 3,
    kUnitFieldNumber = 4,
  };
  // int64 available = 1;
  void clear_available() ;
  ::int64_t available() const;
  void set_available(::int64_t value);

  private:
  ::int64_t _internal_available() const;
  void _internal_set_available(::int64_t value);

  public:
  // int64 total = 2;
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // int64 used = 3;
  void clear_used() ;
  ::int64_t used() const;
  void set_used(::int64_t value);

  private:
  ::int64_t _internal_used() const;
  void _internal_set_used(::int64_t value);

  public:
  // .csi.v1.VolumeUsage.Unit unit = 4;
  void clear_unit() ;
  ::csi::v1::VolumeUsage_Unit unit() const;
  void set_unit(::csi::v1::VolumeUsage_Unit value);

  private:
  ::csi::v1::VolumeUsage_Unit _internal_unit() const;
  void _internal_set_unit(::csi::v1::VolumeUsage_Unit value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeUsage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t available_;
    ::int64_t total_;
    ::int64_t used_;
    int unit_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeContentSource_VolumeSource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource.VolumeSource) */ {
 public:
  inline VolumeContentSource_VolumeSource() : VolumeContentSource_VolumeSource(nullptr) {}
  ~VolumeContentSource_VolumeSource() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeContentSource_VolumeSource(::google::protobuf::internal::ConstantInitialized);

  inline VolumeContentSource_VolumeSource(const VolumeContentSource_VolumeSource& from)
      : VolumeContentSource_VolumeSource(nullptr, from) {}
  VolumeContentSource_VolumeSource(VolumeContentSource_VolumeSource&& from) noexcept
    : VolumeContentSource_VolumeSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource_VolumeSource& operator=(const VolumeContentSource_VolumeSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource_VolumeSource& operator=(VolumeContentSource_VolumeSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeContentSource_VolumeSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeContentSource_VolumeSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource_VolumeSource*>(
               &_VolumeContentSource_VolumeSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VolumeContentSource_VolumeSource& a, VolumeContentSource_VolumeSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource_VolumeSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource_VolumeSource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeContentSource_VolumeSource* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeContentSource_VolumeSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeContentSource_VolumeSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeContentSource_VolumeSource& from) {
    VolumeContentSource_VolumeSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeContentSource_VolumeSource* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeContentSource.VolumeSource";
  }
  protected:
  explicit VolumeContentSource_VolumeSource(::google::protobuf::Arena* arena);
  VolumeContentSource_VolumeSource(::google::protobuf::Arena* arena, const VolumeContentSource_VolumeSource& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
  };
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.VolumeSource)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeContentSource_SnapshotSource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource.SnapshotSource) */ {
 public:
  inline VolumeContentSource_SnapshotSource() : VolumeContentSource_SnapshotSource(nullptr) {}
  ~VolumeContentSource_SnapshotSource() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeContentSource_SnapshotSource(::google::protobuf::internal::ConstantInitialized);

  inline VolumeContentSource_SnapshotSource(const VolumeContentSource_SnapshotSource& from)
      : VolumeContentSource_SnapshotSource(nullptr, from) {}
  VolumeContentSource_SnapshotSource(VolumeContentSource_SnapshotSource&& from) noexcept
    : VolumeContentSource_SnapshotSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource_SnapshotSource& operator=(const VolumeContentSource_SnapshotSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource_SnapshotSource& operator=(VolumeContentSource_SnapshotSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeContentSource_SnapshotSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeContentSource_SnapshotSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource_SnapshotSource*>(
               &_VolumeContentSource_SnapshotSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VolumeContentSource_SnapshotSource& a, VolumeContentSource_SnapshotSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource_SnapshotSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource_SnapshotSource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeContentSource_SnapshotSource* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeContentSource_SnapshotSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeContentSource_SnapshotSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeContentSource_SnapshotSource& from) {
    VolumeContentSource_SnapshotSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeContentSource_SnapshotSource* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeContentSource.SnapshotSource";
  }
  protected:
  explicit VolumeContentSource_SnapshotSource(::google::protobuf::Arena* arena);
  VolumeContentSource_SnapshotSource(::google::protobuf::Arena* arena, const VolumeContentSource_SnapshotSource& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdFieldNumber = 1,
  };
  // string snapshot_id = 1;
  void clear_snapshot_id() ;
  const std::string& snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* value);

  private:
  const std::string& _internal_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_snapshot_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.SnapshotSource)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr snapshot_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCondition) */ {
 public:
  inline VolumeCondition() : VolumeCondition(nullptr) {}
  ~VolumeCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeCondition(::google::protobuf::internal::ConstantInitialized);

  inline VolumeCondition(const VolumeCondition& from)
      : VolumeCondition(nullptr, from) {}
  VolumeCondition(VolumeCondition&& from) noexcept
    : VolumeCondition() {
    *this = ::std::move(from);
  }

  inline VolumeCondition& operator=(const VolumeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCondition& operator=(VolumeCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeCondition* internal_default_instance() {
    return reinterpret_cast<const VolumeCondition*>(
               &_VolumeCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(VolumeCondition& a, VolumeCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeCondition& from) {
    VolumeCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeCondition";
  }
  protected:
  explicit VolumeCondition(::google::protobuf::Arena* arena);
  VolumeCondition(::google::protobuf::Arena* arena, const VolumeCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kAbnormalFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool abnormal = 1;
  void clear_abnormal() ;
  bool abnormal() const;
  void set_abnormal(bool value);

  private:
  bool _internal_abnormal() const;
  void _internal_set_abnormal(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool abnormal_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeCapability_MountVolume final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.MountVolume) */ {
 public:
  inline VolumeCapability_MountVolume() : VolumeCapability_MountVolume(nullptr) {}
  ~VolumeCapability_MountVolume() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeCapability_MountVolume(::google::protobuf::internal::ConstantInitialized);

  inline VolumeCapability_MountVolume(const VolumeCapability_MountVolume& from)
      : VolumeCapability_MountVolume(nullptr, from) {}
  VolumeCapability_MountVolume(VolumeCapability_MountVolume&& from) noexcept
    : VolumeCapability_MountVolume() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_MountVolume& operator=(const VolumeCapability_MountVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_MountVolume& operator=(VolumeCapability_MountVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeCapability_MountVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeCapability_MountVolume* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_MountVolume*>(
               &_VolumeCapability_MountVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VolumeCapability_MountVolume& a, VolumeCapability_MountVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_MountVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_MountVolume* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeCapability_MountVolume* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeCapability_MountVolume>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeCapability_MountVolume& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeCapability_MountVolume& from) {
    VolumeCapability_MountVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeCapability_MountVolume* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeCapability.MountVolume";
  }
  protected:
  explicit VolumeCapability_MountVolume(::google::protobuf::Arena* arena);
  VolumeCapability_MountVolume(::google::protobuf::Arena* arena, const VolumeCapability_MountVolume& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMountFlagsFieldNumber = 2,
    kFsTypeFieldNumber = 1,
    kVolumeMountGroupFieldNumber = 3,
  };
  // repeated string mount_flags = 2;
  int mount_flags_size() const;
  private:
  int _internal_mount_flags_size() const;

  public:
  void clear_mount_flags() ;
  const std::string& mount_flags(int index) const;
  std::string* mutable_mount_flags(int index);
  void set_mount_flags(int index, const std::string& value);
  void set_mount_flags(int index, std::string&& value);
  void set_mount_flags(int index, const char* value);
  void set_mount_flags(int index, const char* value, std::size_t size);
  void set_mount_flags(int index, absl::string_view value);
  std::string* add_mount_flags();
  void add_mount_flags(const std::string& value);
  void add_mount_flags(std::string&& value);
  void add_mount_flags(const char* value);
  void add_mount_flags(const char* value, std::size_t size);
  void add_mount_flags(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& mount_flags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_mount_flags();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_mount_flags() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_mount_flags();

  public:
  // string fs_type = 1;
  void clear_fs_type() ;
  const std::string& fs_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fs_type(Arg_&& arg, Args_... args);
  std::string* mutable_fs_type();
  PROTOBUF_NODISCARD std::string* release_fs_type();
  void set_allocated_fs_type(std::string* value);

  private:
  const std::string& _internal_fs_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fs_type(
      const std::string& value);
  std::string* _internal_mutable_fs_type();

  public:
  // string volume_mount_group = 3;
  void clear_volume_mount_group() ;
  const std::string& volume_mount_group() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_mount_group(Arg_&& arg, Args_... args);
  std::string* mutable_volume_mount_group();
  PROTOBUF_NODISCARD std::string* release_volume_mount_group();
  void set_allocated_volume_mount_group(std::string* value);

  private:
  const std::string& _internal_volume_mount_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_mount_group(
      const std::string& value);
  std::string* _internal_mutable_volume_mount_group();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.MountVolume)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> mount_flags_;
    ::google::protobuf::internal::ArenaStringPtr fs_type_;
    ::google::protobuf::internal::ArenaStringPtr volume_mount_group_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeCapability_BlockVolume final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.BlockVolume) */ {
 public:
  inline VolumeCapability_BlockVolume() : VolumeCapability_BlockVolume(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeCapability_BlockVolume(::google::protobuf::internal::ConstantInitialized);

  inline VolumeCapability_BlockVolume(const VolumeCapability_BlockVolume& from)
      : VolumeCapability_BlockVolume(nullptr, from) {}
  VolumeCapability_BlockVolume(VolumeCapability_BlockVolume&& from) noexcept
    : VolumeCapability_BlockVolume() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_BlockVolume& operator=(const VolumeCapability_BlockVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_BlockVolume& operator=(VolumeCapability_BlockVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeCapability_BlockVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeCapability_BlockVolume* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_BlockVolume*>(
               &_VolumeCapability_BlockVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VolumeCapability_BlockVolume& a, VolumeCapability_BlockVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_BlockVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_BlockVolume* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeCapability_BlockVolume* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeCapability_BlockVolume>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const VolumeCapability_BlockVolume& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const VolumeCapability_BlockVolume& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeCapability.BlockVolume";
  }
  protected:
  explicit VolumeCapability_BlockVolume(::google::protobuf::Arena* arena);
  VolumeCapability_BlockVolume(::google::protobuf::Arena* arena, const VolumeCapability_BlockVolume& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.BlockVolume)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeCapability_AccessMode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.AccessMode) */ {
 public:
  inline VolumeCapability_AccessMode() : VolumeCapability_AccessMode(nullptr) {}
  ~VolumeCapability_AccessMode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeCapability_AccessMode(::google::protobuf::internal::ConstantInitialized);

  inline VolumeCapability_AccessMode(const VolumeCapability_AccessMode& from)
      : VolumeCapability_AccessMode(nullptr, from) {}
  VolumeCapability_AccessMode(VolumeCapability_AccessMode&& from) noexcept
    : VolumeCapability_AccessMode() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_AccessMode& operator=(const VolumeCapability_AccessMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_AccessMode& operator=(VolumeCapability_AccessMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeCapability_AccessMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeCapability_AccessMode* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_AccessMode*>(
               &_VolumeCapability_AccessMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VolumeCapability_AccessMode& a, VolumeCapability_AccessMode& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_AccessMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_AccessMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeCapability_AccessMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeCapability_AccessMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeCapability_AccessMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeCapability_AccessMode& from) {
    VolumeCapability_AccessMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeCapability_AccessMode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeCapability.AccessMode";
  }
  protected:
  explicit VolumeCapability_AccessMode(::google::protobuf::Arena* arena);
  VolumeCapability_AccessMode(::google::protobuf::Arena* arena, const VolumeCapability_AccessMode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Mode = VolumeCapability_AccessMode_Mode;
  static constexpr Mode UNKNOWN = VolumeCapability_AccessMode_Mode_UNKNOWN;
  static constexpr Mode SINGLE_NODE_WRITER = VolumeCapability_AccessMode_Mode_SINGLE_NODE_WRITER;
  static constexpr Mode SINGLE_NODE_READER_ONLY = VolumeCapability_AccessMode_Mode_SINGLE_NODE_READER_ONLY;
  static constexpr Mode MULTI_NODE_READER_ONLY = VolumeCapability_AccessMode_Mode_MULTI_NODE_READER_ONLY;
  static constexpr Mode MULTI_NODE_SINGLE_WRITER = VolumeCapability_AccessMode_Mode_MULTI_NODE_SINGLE_WRITER;
  static constexpr Mode MULTI_NODE_MULTI_WRITER = VolumeCapability_AccessMode_Mode_MULTI_NODE_MULTI_WRITER;
  static constexpr Mode SINGLE_NODE_SINGLE_WRITER = VolumeCapability_AccessMode_Mode_SINGLE_NODE_SINGLE_WRITER;
  static constexpr Mode SINGLE_NODE_MULTI_WRITER = VolumeCapability_AccessMode_Mode_SINGLE_NODE_MULTI_WRITER;
  static inline bool Mode_IsValid(int value) {
    return VolumeCapability_AccessMode_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN = VolumeCapability_AccessMode_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX = VolumeCapability_AccessMode_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE = VolumeCapability_AccessMode_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Mode_descriptor() {
    return VolumeCapability_AccessMode_Mode_descriptor();
  }
  template <typename T>
  static inline const std::string& Mode_Name(T value) {
    return VolumeCapability_AccessMode_Mode_Name(value);
  }
  static inline bool Mode_Parse(absl::string_view name, Mode* value) {
    return VolumeCapability_AccessMode_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .csi.v1.VolumeCapability.AccessMode.Mode mode = 1;
  void clear_mode() ;
  ::csi::v1::VolumeCapability_AccessMode_Mode mode() const;
  void set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value);

  private:
  ::csi::v1::VolumeCapability_AccessMode_Mode _internal_mode() const;
  void _internal_set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.AccessMode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class Volume_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Volume_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Volume_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Volume_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Volume_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Volume_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Volume_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Volume_VolumeContextEntry_DoNotUse*>(
        &_Volume_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.Volume.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.Volume.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.MutableParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.MutableParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse*>(
        &_ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.MutableParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.MutableParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class Topology_SegmentsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Topology_SegmentsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Topology_SegmentsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  Topology_SegmentsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Topology_SegmentsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Topology_SegmentsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Topology_SegmentsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Topology_SegmentsEntry_DoNotUse*>(
        &_Topology_SegmentsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.Topology.SegmentsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.Topology.SegmentsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ProbeRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.ProbeRequest) */ {
 public:
  inline ProbeRequest() : ProbeRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProbeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ProbeRequest(const ProbeRequest& from)
      : ProbeRequest(nullptr, from) {}
  ProbeRequest(ProbeRequest&& from) noexcept
    : ProbeRequest() {
    *this = ::std::move(from);
  }

  inline ProbeRequest& operator=(const ProbeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProbeRequest& operator=(ProbeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProbeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProbeRequest* internal_default_instance() {
    return reinterpret_cast<const ProbeRequest*>(
               &_ProbeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProbeRequest& a, ProbeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProbeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProbeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProbeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProbeRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ProbeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ProbeRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ProbeRequest";
  }
  protected:
  explicit ProbeRequest(::google::protobuf::Arena* arena);
  ProbeRequest(::google::protobuf::Arena* arena, const ProbeRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ProbeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class PluginCapability_VolumeExpansion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability.VolumeExpansion) */ {
 public:
  inline PluginCapability_VolumeExpansion() : PluginCapability_VolumeExpansion(nullptr) {}
  ~PluginCapability_VolumeExpansion() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PluginCapability_VolumeExpansion(::google::protobuf::internal::ConstantInitialized);

  inline PluginCapability_VolumeExpansion(const PluginCapability_VolumeExpansion& from)
      : PluginCapability_VolumeExpansion(nullptr, from) {}
  PluginCapability_VolumeExpansion(PluginCapability_VolumeExpansion&& from) noexcept
    : PluginCapability_VolumeExpansion() {
    *this = ::std::move(from);
  }

  inline PluginCapability_VolumeExpansion& operator=(const PluginCapability_VolumeExpansion& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability_VolumeExpansion& operator=(PluginCapability_VolumeExpansion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginCapability_VolumeExpansion& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginCapability_VolumeExpansion* internal_default_instance() {
    return reinterpret_cast<const PluginCapability_VolumeExpansion*>(
               &_PluginCapability_VolumeExpansion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PluginCapability_VolumeExpansion& a, PluginCapability_VolumeExpansion& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability_VolumeExpansion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability_VolumeExpansion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginCapability_VolumeExpansion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginCapability_VolumeExpansion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginCapability_VolumeExpansion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PluginCapability_VolumeExpansion& from) {
    PluginCapability_VolumeExpansion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PluginCapability_VolumeExpansion* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.PluginCapability.VolumeExpansion";
  }
  protected:
  explicit PluginCapability_VolumeExpansion(::google::protobuf::Arena* arena);
  PluginCapability_VolumeExpansion(::google::protobuf::Arena* arena, const PluginCapability_VolumeExpansion& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = PluginCapability_VolumeExpansion_Type;
  static constexpr Type UNKNOWN = PluginCapability_VolumeExpansion_Type_UNKNOWN;
  static constexpr Type ONLINE = PluginCapability_VolumeExpansion_Type_ONLINE;
  static constexpr Type OFFLINE = PluginCapability_VolumeExpansion_Type_OFFLINE;
  static inline bool Type_IsValid(int value) {
    return PluginCapability_VolumeExpansion_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = PluginCapability_VolumeExpansion_Type_Type_MIN;
  static constexpr Type Type_MAX = PluginCapability_VolumeExpansion_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = PluginCapability_VolumeExpansion_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return PluginCapability_VolumeExpansion_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return PluginCapability_VolumeExpansion_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return PluginCapability_VolumeExpansion_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.PluginCapability.VolumeExpansion.Type type = 1;
  void clear_type() ;
  ::csi::v1::PluginCapability_VolumeExpansion_Type type() const;
  void set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value);

  private:
  ::csi::v1::PluginCapability_VolumeExpansion_Type _internal_type() const;
  void _internal_set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.VolumeExpansion)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class PluginCapability_Service final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability.Service) */ {
 public:
  inline PluginCapability_Service() : PluginCapability_Service(nullptr) {}
  ~PluginCapability_Service() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PluginCapability_Service(::google::protobuf::internal::ConstantInitialized);

  inline PluginCapability_Service(const PluginCapability_Service& from)
      : PluginCapability_Service(nullptr, from) {}
  PluginCapability_Service(PluginCapability_Service&& from) noexcept
    : PluginCapability_Service() {
    *this = ::std::move(from);
  }

  inline PluginCapability_Service& operator=(const PluginCapability_Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability_Service& operator=(PluginCapability_Service&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginCapability_Service& default_instance() {
    return *internal_default_instance();
  }
  static inline const PluginCapability_Service* internal_default_instance() {
    return reinterpret_cast<const PluginCapability_Service*>(
               &_PluginCapability_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PluginCapability_Service& a, PluginCapability_Service& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability_Service* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability_Service* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginCapability_Service* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginCapability_Service>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginCapability_Service& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PluginCapability_Service& from) {
    PluginCapability_Service::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PluginCapability_Service* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.PluginCapability.Service";
  }
  protected:
  explicit PluginCapability_Service(::google::protobuf::Arena* arena);
  PluginCapability_Service(::google::protobuf::Arena* arena, const PluginCapability_Service& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = PluginCapability_Service_Type;
  static constexpr Type UNKNOWN = PluginCapability_Service_Type_UNKNOWN;
  static constexpr Type CONTROLLER_SERVICE = PluginCapability_Service_Type_CONTROLLER_SERVICE;
  static constexpr Type VOLUME_ACCESSIBILITY_CONSTRAINTS = PluginCapability_Service_Type_VOLUME_ACCESSIBILITY_CONSTRAINTS;
  static constexpr Type GROUP_CONTROLLER_SERVICE = PluginCapability_Service_Type_GROUP_CONTROLLER_SERVICE;
  static inline bool Type_IsValid(int value) {
    return PluginCapability_Service_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = PluginCapability_Service_Type_Type_MIN;
  static constexpr Type Type_MAX = PluginCapability_Service_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = PluginCapability_Service_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return PluginCapability_Service_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return PluginCapability_Service_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return PluginCapability_Service_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.PluginCapability.Service.Type type = 1;
  void clear_type() ;
  ::csi::v1::PluginCapability_Service_Type type() const;
  void set_type(::csi::v1::PluginCapability_Service_Type value);

  private:
  ::csi::v1::PluginCapability_Service_Type _internal_type() const;
  void _internal_set_type(::csi::v1::PluginCapability_Service_Type value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.Service)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeUnstageVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnstageVolumeResponse) */ {
 public:
  inline NodeUnstageVolumeResponse() : NodeUnstageVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeUnstageVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeUnstageVolumeResponse(const NodeUnstageVolumeResponse& from)
      : NodeUnstageVolumeResponse(nullptr, from) {}
  NodeUnstageVolumeResponse(NodeUnstageVolumeResponse&& from) noexcept
    : NodeUnstageVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeUnstageVolumeResponse& operator=(const NodeUnstageVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnstageVolumeResponse& operator=(NodeUnstageVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeUnstageVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeUnstageVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeUnstageVolumeResponse*>(
               &_NodeUnstageVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(NodeUnstageVolumeResponse& a, NodeUnstageVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnstageVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnstageVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeUnstageVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeUnstageVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodeUnstageVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodeUnstageVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeUnstageVolumeResponse";
  }
  protected:
  explicit NodeUnstageVolumeResponse(::google::protobuf::Arena* arena);
  NodeUnstageVolumeResponse(::google::protobuf::Arena* arena, const NodeUnstageVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeUnstageVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnstageVolumeRequest) */ {
 public:
  inline NodeUnstageVolumeRequest() : NodeUnstageVolumeRequest(nullptr) {}
  ~NodeUnstageVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeUnstageVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeUnstageVolumeRequest(const NodeUnstageVolumeRequest& from)
      : NodeUnstageVolumeRequest(nullptr, from) {}
  NodeUnstageVolumeRequest(NodeUnstageVolumeRequest&& from) noexcept
    : NodeUnstageVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeUnstageVolumeRequest& operator=(const NodeUnstageVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnstageVolumeRequest& operator=(NodeUnstageVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeUnstageVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeUnstageVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeUnstageVolumeRequest*>(
               &_NodeUnstageVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(NodeUnstageVolumeRequest& a, NodeUnstageVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnstageVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnstageVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeUnstageVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeUnstageVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeUnstageVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeUnstageVolumeRequest& from) {
    NodeUnstageVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeUnstageVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeUnstageVolumeRequest";
  }
  protected:
  explicit NodeUnstageVolumeRequest(::google::protobuf::Arena* arena);
  NodeUnstageVolumeRequest(::google::protobuf::Arena* arena, const NodeUnstageVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 2,
  };
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string staging_target_path = 2;
  void clear_staging_target_path() ;
  const std::string& staging_target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staging_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_staging_target_path();
  PROTOBUF_NODISCARD std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* value);

  private:
  const std::string& _internal_staging_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_target_path(
      const std::string& value);
  std::string* _internal_mutable_staging_target_path();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr staging_target_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeUnpublishVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnpublishVolumeResponse) */ {
 public:
  inline NodeUnpublishVolumeResponse() : NodeUnpublishVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeUnpublishVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeUnpublishVolumeResponse(const NodeUnpublishVolumeResponse& from)
      : NodeUnpublishVolumeResponse(nullptr, from) {}
  NodeUnpublishVolumeResponse(NodeUnpublishVolumeResponse&& from) noexcept
    : NodeUnpublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeUnpublishVolumeResponse& operator=(const NodeUnpublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnpublishVolumeResponse& operator=(NodeUnpublishVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeUnpublishVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeUnpublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeUnpublishVolumeResponse*>(
               &_NodeUnpublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(NodeUnpublishVolumeResponse& a, NodeUnpublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnpublishVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnpublishVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeUnpublishVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeUnpublishVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodeUnpublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodeUnpublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeUnpublishVolumeResponse";
  }
  protected:
  explicit NodeUnpublishVolumeResponse(::google::protobuf::Arena* arena);
  NodeUnpublishVolumeResponse(::google::protobuf::Arena* arena, const NodeUnpublishVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeUnpublishVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnpublishVolumeRequest) */ {
 public:
  inline NodeUnpublishVolumeRequest() : NodeUnpublishVolumeRequest(nullptr) {}
  ~NodeUnpublishVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeUnpublishVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeUnpublishVolumeRequest(const NodeUnpublishVolumeRequest& from)
      : NodeUnpublishVolumeRequest(nullptr, from) {}
  NodeUnpublishVolumeRequest(NodeUnpublishVolumeRequest&& from) noexcept
    : NodeUnpublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeUnpublishVolumeRequest& operator=(const NodeUnpublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnpublishVolumeRequest& operator=(NodeUnpublishVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeUnpublishVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeUnpublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeUnpublishVolumeRequest*>(
               &_NodeUnpublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(NodeUnpublishVolumeRequest& a, NodeUnpublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnpublishVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnpublishVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeUnpublishVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeUnpublishVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeUnpublishVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeUnpublishVolumeRequest& from) {
    NodeUnpublishVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeUnpublishVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeUnpublishVolumeRequest";
  }
  protected:
  explicit NodeUnpublishVolumeRequest(::google::protobuf::Arena* arena);
  NodeUnpublishVolumeRequest(::google::protobuf::Arena* arena, const NodeUnpublishVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kTargetPathFieldNumber = 2,
  };
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string target_path = 2;
  void clear_target_path() ;
  const std::string& target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_target_path();
  PROTOBUF_NODISCARD std::string* release_target_path();
  void set_allocated_target_path(std::string* value);

  private:
  const std::string& _internal_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_path(
      const std::string& value);
  std::string* _internal_mutable_target_path();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr target_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeStageVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodeStageVolumeResponse) */ {
 public:
  inline NodeStageVolumeResponse() : NodeStageVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStageVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeStageVolumeResponse(const NodeStageVolumeResponse& from)
      : NodeStageVolumeResponse(nullptr, from) {}
  NodeStageVolumeResponse(NodeStageVolumeResponse&& from) noexcept
    : NodeStageVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeStageVolumeResponse& operator=(const NodeStageVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStageVolumeResponse& operator=(NodeStageVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStageVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStageVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeResponse*>(
               &_NodeStageVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(NodeStageVolumeResponse& a, NodeStageVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStageVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStageVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStageVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeStageVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodeStageVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodeStageVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeStageVolumeResponse";
  }
  protected:
  explicit NodeStageVolumeResponse(::google::protobuf::Arena* arena);
  NodeStageVolumeResponse(::google::protobuf::Arena* arena, const NodeStageVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeStageVolumeRequest_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodeStageVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodeStageVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodeStageVolumeRequest_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStageVolumeRequest_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodeStageVolumeRequest_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodeStageVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeRequest_VolumeContextEntry_DoNotUse*>(
        &_NodeStageVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodeStageVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodeStageVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodeStageVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodeStageVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStageVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodeStageVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodeStageVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeRequest_SecretsEntry_DoNotUse*>(
        &_NodeStageVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodeStageVolumeRequest_PublishContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodeStageVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodeStageVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodeStageVolumeRequest_PublishContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStageVolumeRequest_PublishContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodeStageVolumeRequest_PublishContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodeStageVolumeRequest_PublishContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeRequest_PublishContextEntry_DoNotUse*>(
        &_NodeStageVolumeRequest_PublishContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.PublishContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodeServiceCapability_RPC final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeServiceCapability.RPC) */ {
 public:
  inline NodeServiceCapability_RPC() : NodeServiceCapability_RPC(nullptr) {}
  ~NodeServiceCapability_RPC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeServiceCapability_RPC(::google::protobuf::internal::ConstantInitialized);

  inline NodeServiceCapability_RPC(const NodeServiceCapability_RPC& from)
      : NodeServiceCapability_RPC(nullptr, from) {}
  NodeServiceCapability_RPC(NodeServiceCapability_RPC&& from) noexcept
    : NodeServiceCapability_RPC() {
    *this = ::std::move(from);
  }

  inline NodeServiceCapability_RPC& operator=(const NodeServiceCapability_RPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeServiceCapability_RPC& operator=(NodeServiceCapability_RPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeServiceCapability_RPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeServiceCapability_RPC* internal_default_instance() {
    return reinterpret_cast<const NodeServiceCapability_RPC*>(
               &_NodeServiceCapability_RPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(NodeServiceCapability_RPC& a, NodeServiceCapability_RPC& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeServiceCapability_RPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeServiceCapability_RPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeServiceCapability_RPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeServiceCapability_RPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeServiceCapability_RPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeServiceCapability_RPC& from) {
    NodeServiceCapability_RPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeServiceCapability_RPC* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeServiceCapability.RPC";
  }
  protected:
  explicit NodeServiceCapability_RPC(::google::protobuf::Arena* arena);
  NodeServiceCapability_RPC(::google::protobuf::Arena* arena, const NodeServiceCapability_RPC& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = NodeServiceCapability_RPC_Type;
  static constexpr Type UNKNOWN = NodeServiceCapability_RPC_Type_UNKNOWN;
  static constexpr Type STAGE_UNSTAGE_VOLUME = NodeServiceCapability_RPC_Type_STAGE_UNSTAGE_VOLUME;
  static constexpr Type GET_VOLUME_STATS = NodeServiceCapability_RPC_Type_GET_VOLUME_STATS;
  static constexpr Type EXPAND_VOLUME = NodeServiceCapability_RPC_Type_EXPAND_VOLUME;
  static constexpr Type VOLUME_CONDITION = NodeServiceCapability_RPC_Type_VOLUME_CONDITION;
  static constexpr Type SINGLE_NODE_MULTI_WRITER = NodeServiceCapability_RPC_Type_SINGLE_NODE_MULTI_WRITER;
  static constexpr Type VOLUME_MOUNT_GROUP = NodeServiceCapability_RPC_Type_VOLUME_MOUNT_GROUP;
  static inline bool Type_IsValid(int value) {
    return NodeServiceCapability_RPC_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = NodeServiceCapability_RPC_Type_Type_MIN;
  static constexpr Type Type_MAX = NodeServiceCapability_RPC_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = NodeServiceCapability_RPC_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return NodeServiceCapability_RPC_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return NodeServiceCapability_RPC_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return NodeServiceCapability_RPC_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.NodeServiceCapability.RPC.Type type = 1;
  void clear_type() ;
  ::csi::v1::NodeServiceCapability_RPC_Type type() const;
  void set_type(::csi::v1::NodeServiceCapability_RPC_Type value);

  private:
  ::csi::v1::NodeServiceCapability_RPC_Type _internal_type() const;
  void _internal_set_type(::csi::v1::NodeServiceCapability_RPC_Type value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability.RPC)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodePublishVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodePublishVolumeResponse) */ {
 public:
  inline NodePublishVolumeResponse() : NodePublishVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodePublishVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodePublishVolumeResponse(const NodePublishVolumeResponse& from)
      : NodePublishVolumeResponse(nullptr, from) {}
  NodePublishVolumeResponse(NodePublishVolumeResponse&& from) noexcept
    : NodePublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodePublishVolumeResponse& operator=(const NodePublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePublishVolumeResponse& operator=(NodePublishVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodePublishVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodePublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeResponse*>(
               &_NodePublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(NodePublishVolumeResponse& a, NodePublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePublishVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePublishVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodePublishVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodePublishVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodePublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodePublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodePublishVolumeResponse";
  }
  protected:
  explicit NodePublishVolumeResponse(::google::protobuf::Arena* arena);
  NodePublishVolumeResponse(::google::protobuf::Arena* arena, const NodePublishVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodePublishVolumeRequest_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodePublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodePublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodePublishVolumeRequest_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodePublishVolumeRequest_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodePublishVolumeRequest_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodePublishVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeRequest_VolumeContextEntry_DoNotUse*>(
        &_NodePublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodePublishVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodePublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodePublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodePublishVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodePublishVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodePublishVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodePublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeRequest_SecretsEntry_DoNotUse*>(
        &_NodePublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodePublishVolumeRequest_PublishContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodePublishVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodePublishVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodePublishVolumeRequest_PublishContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodePublishVolumeRequest_PublishContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodePublishVolumeRequest_PublishContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodePublishVolumeRequest_PublishContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeRequest_PublishContextEntry_DoNotUse*>(
        &_NodePublishVolumeRequest_PublishContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.PublishContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetVolumeStatsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetVolumeStatsRequest) */ {
 public:
  inline NodeGetVolumeStatsRequest() : NodeGetVolumeStatsRequest(nullptr) {}
  ~NodeGetVolumeStatsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetVolumeStatsRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetVolumeStatsRequest(const NodeGetVolumeStatsRequest& from)
      : NodeGetVolumeStatsRequest(nullptr, from) {}
  NodeGetVolumeStatsRequest(NodeGetVolumeStatsRequest&& from) noexcept
    : NodeGetVolumeStatsRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetVolumeStatsRequest& operator=(const NodeGetVolumeStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetVolumeStatsRequest& operator=(NodeGetVolumeStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetVolumeStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetVolumeStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetVolumeStatsRequest*>(
               &_NodeGetVolumeStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(NodeGetVolumeStatsRequest& a, NodeGetVolumeStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetVolumeStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetVolumeStatsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetVolumeStatsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetVolumeStatsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeGetVolumeStatsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeGetVolumeStatsRequest& from) {
    NodeGetVolumeStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeGetVolumeStatsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetVolumeStatsRequest";
  }
  protected:
  explicit NodeGetVolumeStatsRequest(::google::protobuf::Arena* arena);
  NodeGetVolumeStatsRequest(::google::protobuf::Arena* arena, const NodeGetVolumeStatsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kVolumePathFieldNumber = 2,
    kStagingTargetPathFieldNumber = 3,
  };
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string volume_path = 2;
  void clear_volume_path() ;
  const std::string& volume_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_path(Arg_&& arg, Args_... args);
  std::string* mutable_volume_path();
  PROTOBUF_NODISCARD std::string* release_volume_path();
  void set_allocated_volume_path(std::string* value);

  private:
  const std::string& _internal_volume_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_path(
      const std::string& value);
  std::string* _internal_mutable_volume_path();

  public:
  // string staging_target_path = 3;
  void clear_staging_target_path() ;
  const std::string& staging_target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staging_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_staging_target_path();
  PROTOBUF_NODISCARD std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* value);

  private:
  const std::string& _internal_staging_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_target_path(
      const std::string& value);
  std::string* _internal_mutable_staging_target_path();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr volume_path_;
    ::google::protobuf::internal::ArenaStringPtr staging_target_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeGetInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetInfoRequest) */ {
 public:
  inline NodeGetInfoRequest() : NodeGetInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetInfoRequest(const NodeGetInfoRequest& from)
      : NodeGetInfoRequest(nullptr, from) {}
  NodeGetInfoRequest(NodeGetInfoRequest&& from) noexcept
    : NodeGetInfoRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetInfoRequest& operator=(const NodeGetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetInfoRequest& operator=(NodeGetInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetInfoRequest*>(
               &_NodeGetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(NodeGetInfoRequest& a, NodeGetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodeGetInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodeGetInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetInfoRequest";
  }
  protected:
  explicit NodeGetInfoRequest(::google::protobuf::Arena* arena);
  NodeGetInfoRequest(::google::protobuf::Arena* arena, const NodeGetInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeGetCapabilitiesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetCapabilitiesRequest) */ {
 public:
  inline NodeGetCapabilitiesRequest() : NodeGetCapabilitiesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetCapabilitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetCapabilitiesRequest(const NodeGetCapabilitiesRequest& from)
      : NodeGetCapabilitiesRequest(nullptr, from) {}
  NodeGetCapabilitiesRequest(NodeGetCapabilitiesRequest&& from) noexcept
    : NodeGetCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetCapabilitiesRequest& operator=(const NodeGetCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetCapabilitiesRequest& operator=(NodeGetCapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetCapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetCapabilitiesRequest*>(
               &_NodeGetCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(NodeGetCapabilitiesRequest& a, NodeGetCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetCapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetCapabilitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetCapabilitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetCapabilitiesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NodeGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NodeGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetCapabilitiesRequest";
  }
  protected:
  explicit NodeGetCapabilitiesRequest(::google::protobuf::Arena* arena);
  NodeGetCapabilitiesRequest(::google::protobuf::Arena* arena, const NodeGetCapabilitiesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeExpandVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeExpandVolumeResponse) */ {
 public:
  inline NodeExpandVolumeResponse() : NodeExpandVolumeResponse(nullptr) {}
  ~NodeExpandVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeExpandVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeExpandVolumeResponse(const NodeExpandVolumeResponse& from)
      : NodeExpandVolumeResponse(nullptr, from) {}
  NodeExpandVolumeResponse(NodeExpandVolumeResponse&& from) noexcept
    : NodeExpandVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeExpandVolumeResponse& operator=(const NodeExpandVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExpandVolumeResponse& operator=(NodeExpandVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExpandVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExpandVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeExpandVolumeResponse*>(
               &_NodeExpandVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(NodeExpandVolumeResponse& a, NodeExpandVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExpandVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExpandVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExpandVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExpandVolumeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeExpandVolumeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeExpandVolumeResponse& from) {
    NodeExpandVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeExpandVolumeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeExpandVolumeResponse";
  }
  protected:
  explicit NodeExpandVolumeResponse(::google::protobuf::Arena* arena);
  NodeExpandVolumeResponse(::google::protobuf::Arena* arena, const NodeExpandVolumeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityBytesFieldNumber = 1,
  };
  // int64 capacity_bytes = 1;
  void clear_capacity_bytes() ;
  ::int64_t capacity_bytes() const;
  void set_capacity_bytes(::int64_t value);

  private:
  ::int64_t _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t capacity_bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeExpandVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          NodeExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      NodeExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  NodeExpandVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeExpandVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit NodeExpandVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const NodeExpandVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const NodeExpandVolumeRequest_SecretsEntry_DoNotUse*>(
        &_NodeExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeExpandVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.NodeExpandVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ListVolumesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesRequest) */ {
 public:
  inline ListVolumesRequest() : ListVolumesRequest(nullptr) {}
  ~ListVolumesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListVolumesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListVolumesRequest(const ListVolumesRequest& from)
      : ListVolumesRequest(nullptr, from) {}
  ListVolumesRequest(ListVolumesRequest&& from) noexcept
    : ListVolumesRequest() {
    *this = ::std::move(from);
  }

  inline ListVolumesRequest& operator=(const ListVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesRequest& operator=(ListVolumesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVolumesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVolumesRequest*>(
               &_ListVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ListVolumesRequest& a, ListVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVolumesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVolumesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListVolumesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListVolumesRequest& from) {
    ListVolumesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListVolumesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListVolumesRequest";
  }
  protected:
  explicit ListVolumesRequest(::google::protobuf::Arena* arena);
  ListVolumesRequest(::google::protobuf::Arena* arena, const ListVolumesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartingTokenFieldNumber = 2,
    kMaxEntriesFieldNumber = 1,
  };
  // string starting_token = 2;
  void clear_starting_token() ;
  const std::string& starting_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_starting_token(Arg_&& arg, Args_... args);
  std::string* mutable_starting_token();
  PROTOBUF_NODISCARD std::string* release_starting_token();
  void set_allocated_starting_token(std::string* value);

  private:
  const std::string& _internal_starting_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_starting_token(
      const std::string& value);
  std::string* _internal_mutable_starting_token();

  public:
  // int32 max_entries = 1;
  void clear_max_entries() ;
  ::int32_t max_entries() const;
  void set_max_entries(::int32_t value);

  private:
  ::int32_t _internal_max_entries() const;
  void _internal_set_max_entries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr starting_token_;
    ::int32_t max_entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListSnapshotsRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ListSnapshotsRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ListSnapshotsRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ListSnapshotsRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListSnapshotsRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ListSnapshotsRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ListSnapshotsRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsRequest_SecretsEntry_DoNotUse*>(
        &_ListSnapshotsRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ListSnapshotsRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ListSnapshotsRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class GroupControllerServiceCapability_RPC final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GroupControllerServiceCapability.RPC) */ {
 public:
  inline GroupControllerServiceCapability_RPC() : GroupControllerServiceCapability_RPC(nullptr) {}
  ~GroupControllerServiceCapability_RPC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupControllerServiceCapability_RPC(::google::protobuf::internal::ConstantInitialized);

  inline GroupControllerServiceCapability_RPC(const GroupControllerServiceCapability_RPC& from)
      : GroupControllerServiceCapability_RPC(nullptr, from) {}
  GroupControllerServiceCapability_RPC(GroupControllerServiceCapability_RPC&& from) noexcept
    : GroupControllerServiceCapability_RPC() {
    *this = ::std::move(from);
  }

  inline GroupControllerServiceCapability_RPC& operator=(const GroupControllerServiceCapability_RPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupControllerServiceCapability_RPC& operator=(GroupControllerServiceCapability_RPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupControllerServiceCapability_RPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupControllerServiceCapability_RPC* internal_default_instance() {
    return reinterpret_cast<const GroupControllerServiceCapability_RPC*>(
               &_GroupControllerServiceCapability_RPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(GroupControllerServiceCapability_RPC& a, GroupControllerServiceCapability_RPC& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupControllerServiceCapability_RPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupControllerServiceCapability_RPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupControllerServiceCapability_RPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupControllerServiceCapability_RPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupControllerServiceCapability_RPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupControllerServiceCapability_RPC& from) {
    GroupControllerServiceCapability_RPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupControllerServiceCapability_RPC* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GroupControllerServiceCapability.RPC";
  }
  protected:
  explicit GroupControllerServiceCapability_RPC(::google::protobuf::Arena* arena);
  GroupControllerServiceCapability_RPC(::google::protobuf::Arena* arena, const GroupControllerServiceCapability_RPC& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = GroupControllerServiceCapability_RPC_Type;
  static constexpr Type UNKNOWN = GroupControllerServiceCapability_RPC_Type_UNKNOWN;
  static constexpr Type CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT = GroupControllerServiceCapability_RPC_Type_CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT;
  static inline bool Type_IsValid(int value) {
    return GroupControllerServiceCapability_RPC_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = GroupControllerServiceCapability_RPC_Type_Type_MIN;
  static constexpr Type Type_MAX = GroupControllerServiceCapability_RPC_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = GroupControllerServiceCapability_RPC_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return GroupControllerServiceCapability_RPC_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return GroupControllerServiceCapability_RPC_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return GroupControllerServiceCapability_RPC_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.GroupControllerServiceCapability.RPC.Type type = 1;
  void clear_type() ;
  ::csi::v1::GroupControllerServiceCapability_RPC_Type type() const;
  void set_type(::csi::v1::GroupControllerServiceCapability_RPC_Type value);

  private:
  ::csi::v1::GroupControllerServiceCapability_RPC_Type _internal_type() const;
  void _internal_set_type(::csi::v1::GroupControllerServiceCapability_RPC_Type value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GroupControllerServiceCapability.RPC)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GroupControllerGetCapabilitiesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.GroupControllerGetCapabilitiesRequest) */ {
 public:
  inline GroupControllerGetCapabilitiesRequest() : GroupControllerGetCapabilitiesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupControllerGetCapabilitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline GroupControllerGetCapabilitiesRequest(const GroupControllerGetCapabilitiesRequest& from)
      : GroupControllerGetCapabilitiesRequest(nullptr, from) {}
  GroupControllerGetCapabilitiesRequest(GroupControllerGetCapabilitiesRequest&& from) noexcept
    : GroupControllerGetCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline GroupControllerGetCapabilitiesRequest& operator=(const GroupControllerGetCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupControllerGetCapabilitiesRequest& operator=(GroupControllerGetCapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupControllerGetCapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupControllerGetCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const GroupControllerGetCapabilitiesRequest*>(
               &_GroupControllerGetCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(GroupControllerGetCapabilitiesRequest& a, GroupControllerGetCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupControllerGetCapabilitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupControllerGetCapabilitiesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GroupControllerGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GroupControllerGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GroupControllerGetCapabilitiesRequest";
  }
  protected:
  explicit GroupControllerGetCapabilitiesRequest(::google::protobuf::Arena* arena);
  GroupControllerGetCapabilitiesRequest(::google::protobuf::Arena* arena, const GroupControllerGetCapabilitiesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.GroupControllerGetCapabilitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse*>(
        &_GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetVolumeGroupSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetVolumeGroupSnapshotRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginInfoResponse_ManifestEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GetPluginInfoResponse_ManifestEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GetPluginInfoResponse_ManifestEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GetPluginInfoResponse_ManifestEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetPluginInfoResponse_ManifestEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GetPluginInfoResponse_ManifestEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GetPluginInfoResponse_ManifestEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GetPluginInfoResponse_ManifestEntry_DoNotUse*>(
        &_GetPluginInfoResponse_ManifestEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetPluginInfoResponse.ManifestEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetPluginInfoResponse.ManifestEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginInfoRequest) */ {
 public:
  inline GetPluginInfoRequest() : GetPluginInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPluginInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPluginInfoRequest(const GetPluginInfoRequest& from)
      : GetPluginInfoRequest(nullptr, from) {}
  GetPluginInfoRequest(GetPluginInfoRequest&& from) noexcept
    : GetPluginInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetPluginInfoRequest& operator=(const GetPluginInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginInfoRequest& operator=(GetPluginInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetPluginInfoRequest*>(
               &_GetPluginInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetPluginInfoRequest& a, GetPluginInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPluginInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPluginInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetPluginInfoRequest";
  }
  protected:
  explicit GetPluginInfoRequest(::google::protobuf::Arena* arena);
  GetPluginInfoRequest(::google::protobuf::Arena* arena, const GetPluginInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetPluginCapabilitiesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginCapabilitiesRequest) */ {
 public:
  inline GetPluginCapabilitiesRequest() : GetPluginCapabilitiesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPluginCapabilitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetPluginCapabilitiesRequest(const GetPluginCapabilitiesRequest& from)
      : GetPluginCapabilitiesRequest(nullptr, from) {}
  GetPluginCapabilitiesRequest(GetPluginCapabilitiesRequest&& from) noexcept
    : GetPluginCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline GetPluginCapabilitiesRequest& operator=(const GetPluginCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginCapabilitiesRequest& operator=(GetPluginCapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginCapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const GetPluginCapabilitiesRequest*>(
               &_GetPluginCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetPluginCapabilitiesRequest& a, GetPluginCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginCapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginCapabilitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginCapabilitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginCapabilitiesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPluginCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPluginCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetPluginCapabilitiesRequest";
  }
  protected:
  explicit GetPluginCapabilitiesRequest(::google::protobuf::Arena* arena);
  GetPluginCapabilitiesRequest(::google::protobuf::Arena* arena, const GetPluginCapabilitiesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetCapacityRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GetCapacityRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GetCapacityRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GetCapacityRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetCapacityRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GetCapacityRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GetCapacityRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GetCapacityRequest_ParametersEntry_DoNotUse*>(
        &_GetCapacityRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetCapacityRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.GetCapacityRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class DeleteVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeResponse) */ {
 public:
  inline DeleteVolumeResponse() : DeleteVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteVolumeResponse(const DeleteVolumeResponse& from)
      : DeleteVolumeResponse(nullptr, from) {}
  DeleteVolumeResponse(DeleteVolumeResponse&& from) noexcept
    : DeleteVolumeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeResponse& operator=(const DeleteVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeResponse& operator=(DeleteVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeResponse*>(
               &_DeleteVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeleteVolumeResponse& a, DeleteVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteVolumeResponse";
  }
  protected:
  explicit DeleteVolumeResponse(::google::protobuf::Arena* arena);
  DeleteVolumeResponse(::google::protobuf::Arena* arena, const DeleteVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          DeleteVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      DeleteVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  DeleteVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit DeleteVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const DeleteVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeRequest_SecretsEntry_DoNotUse*>(
        &_DeleteVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class DeleteVolumeGroupSnapshotResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeGroupSnapshotResponse) */ {
 public:
  inline DeleteVolumeGroupSnapshotResponse() : DeleteVolumeGroupSnapshotResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeGroupSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteVolumeGroupSnapshotResponse(const DeleteVolumeGroupSnapshotResponse& from)
      : DeleteVolumeGroupSnapshotResponse(nullptr, from) {}
  DeleteVolumeGroupSnapshotResponse(DeleteVolumeGroupSnapshotResponse&& from) noexcept
    : DeleteVolumeGroupSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeGroupSnapshotResponse& operator=(const DeleteVolumeGroupSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeGroupSnapshotResponse& operator=(DeleteVolumeGroupSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteVolumeGroupSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteVolumeGroupSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeGroupSnapshotResponse*>(
               &_DeleteVolumeGroupSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(DeleteVolumeGroupSnapshotResponse& a, DeleteVolumeGroupSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteVolumeGroupSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteVolumeGroupSnapshotResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteVolumeGroupSnapshotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteVolumeGroupSnapshotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteVolumeGroupSnapshotResponse";
  }
  protected:
  explicit DeleteVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena);
  DeleteVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena, const DeleteVolumeGroupSnapshotResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeGroupSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse*>(
        &_DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeGroupSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeGroupSnapshotRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class DeleteSnapshotResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.DeleteSnapshotResponse) */ {
 public:
  inline DeleteSnapshotResponse() : DeleteSnapshotResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteSnapshotResponse(const DeleteSnapshotResponse& from)
      : DeleteSnapshotResponse(nullptr, from) {}
  DeleteSnapshotResponse(DeleteSnapshotResponse&& from) noexcept
    : DeleteSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSnapshotResponse& operator=(const DeleteSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSnapshotResponse& operator=(DeleteSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSnapshotResponse*>(
               &_DeleteSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(DeleteSnapshotResponse& a, DeleteSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSnapshotResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteSnapshotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteSnapshotResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteSnapshotResponse";
  }
  protected:
  explicit DeleteSnapshotResponse(::google::protobuf::Arena* arena);
  DeleteSnapshotResponse(::google::protobuf::Arena* arena, const DeleteSnapshotResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteSnapshotRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          DeleteSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      DeleteSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  DeleteSnapshotRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteSnapshotRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit DeleteSnapshotRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const DeleteSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const DeleteSnapshotRequest_SecretsEntry_DoNotUse*>(
        &_DeleteSnapshotRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.DeleteSnapshotRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeRequest_SecretsEntry_DoNotUse*>(
        &_CreateVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateVolumeRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateVolumeRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateVolumeRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateVolumeRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateVolumeRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeRequest_ParametersEntry_DoNotUse*>(
        &_CreateVolumeRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeRequest_MutableParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateVolumeRequest_MutableParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeRequest_MutableParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateVolumeRequest_MutableParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateVolumeRequest_MutableParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeRequest_MutableParametersEntry_DoNotUse*>(
        &_CreateVolumeRequest_MutableParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.MutableParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.MutableParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse*>(
        &_CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeGroupSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeGroupSnapshotRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse*>(
        &_CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeGroupSnapshotRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeGroupSnapshotRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateSnapshotRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateSnapshotRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSnapshotRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateSnapshotRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotRequest_SecretsEntry_DoNotUse*>(
        &_CreateSnapshotRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CreateSnapshotRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CreateSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CreateSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  CreateSnapshotRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSnapshotRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CreateSnapshotRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CreateSnapshotRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotRequest_ParametersEntry_DoNotUse*>(
        &_CreateSnapshotRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerUnpublishVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.ControllerUnpublishVolumeResponse) */ {
 public:
  inline ControllerUnpublishVolumeResponse() : ControllerUnpublishVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerUnpublishVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerUnpublishVolumeResponse(const ControllerUnpublishVolumeResponse& from)
      : ControllerUnpublishVolumeResponse(nullptr, from) {}
  ControllerUnpublishVolumeResponse(ControllerUnpublishVolumeResponse&& from) noexcept
    : ControllerUnpublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerUnpublishVolumeResponse& operator=(const ControllerUnpublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerUnpublishVolumeResponse& operator=(ControllerUnpublishVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerUnpublishVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerUnpublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerUnpublishVolumeResponse*>(
               &_ControllerUnpublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ControllerUnpublishVolumeResponse& a, ControllerUnpublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerUnpublishVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerUnpublishVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerUnpublishVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ControllerUnpublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ControllerUnpublishVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerUnpublishVolumeResponse";
  }
  protected:
  explicit ControllerUnpublishVolumeResponse(::google::protobuf::Arena* arena);
  ControllerUnpublishVolumeResponse(::google::protobuf::Arena* arena, const ControllerUnpublishVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse*>(
        &_ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerServiceCapability_RPC final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerServiceCapability.RPC) */ {
 public:
  inline ControllerServiceCapability_RPC() : ControllerServiceCapability_RPC(nullptr) {}
  ~ControllerServiceCapability_RPC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerServiceCapability_RPC(::google::protobuf::internal::ConstantInitialized);

  inline ControllerServiceCapability_RPC(const ControllerServiceCapability_RPC& from)
      : ControllerServiceCapability_RPC(nullptr, from) {}
  ControllerServiceCapability_RPC(ControllerServiceCapability_RPC&& from) noexcept
    : ControllerServiceCapability_RPC() {
    *this = ::std::move(from);
  }

  inline ControllerServiceCapability_RPC& operator=(const ControllerServiceCapability_RPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerServiceCapability_RPC& operator=(ControllerServiceCapability_RPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerServiceCapability_RPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerServiceCapability_RPC* internal_default_instance() {
    return reinterpret_cast<const ControllerServiceCapability_RPC*>(
               &_ControllerServiceCapability_RPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(ControllerServiceCapability_RPC& a, ControllerServiceCapability_RPC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerServiceCapability_RPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerServiceCapability_RPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerServiceCapability_RPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerServiceCapability_RPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerServiceCapability_RPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerServiceCapability_RPC& from) {
    ControllerServiceCapability_RPC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerServiceCapability_RPC* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerServiceCapability.RPC";
  }
  protected:
  explicit ControllerServiceCapability_RPC(::google::protobuf::Arena* arena);
  ControllerServiceCapability_RPC(::google::protobuf::Arena* arena, const ControllerServiceCapability_RPC& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = ControllerServiceCapability_RPC_Type;
  static constexpr Type UNKNOWN = ControllerServiceCapability_RPC_Type_UNKNOWN;
  static constexpr Type CREATE_DELETE_VOLUME = ControllerServiceCapability_RPC_Type_CREATE_DELETE_VOLUME;
  static constexpr Type PUBLISH_UNPUBLISH_VOLUME = ControllerServiceCapability_RPC_Type_PUBLISH_UNPUBLISH_VOLUME;
  static constexpr Type LIST_VOLUMES = ControllerServiceCapability_RPC_Type_LIST_VOLUMES;
  static constexpr Type GET_CAPACITY = ControllerServiceCapability_RPC_Type_GET_CAPACITY;
  static constexpr Type CREATE_DELETE_SNAPSHOT = ControllerServiceCapability_RPC_Type_CREATE_DELETE_SNAPSHOT;
  static constexpr Type LIST_SNAPSHOTS = ControllerServiceCapability_RPC_Type_LIST_SNAPSHOTS;
  static constexpr Type CLONE_VOLUME = ControllerServiceCapability_RPC_Type_CLONE_VOLUME;
  static constexpr Type PUBLISH_READONLY = ControllerServiceCapability_RPC_Type_PUBLISH_READONLY;
  static constexpr Type EXPAND_VOLUME = ControllerServiceCapability_RPC_Type_EXPAND_VOLUME;
  static constexpr Type LIST_VOLUMES_PUBLISHED_NODES = ControllerServiceCapability_RPC_Type_LIST_VOLUMES_PUBLISHED_NODES;
  static constexpr Type VOLUME_CONDITION = ControllerServiceCapability_RPC_Type_VOLUME_CONDITION;
  static constexpr Type GET_VOLUME = ControllerServiceCapability_RPC_Type_GET_VOLUME;
  static constexpr Type SINGLE_NODE_MULTI_WRITER = ControllerServiceCapability_RPC_Type_SINGLE_NODE_MULTI_WRITER;
  static constexpr Type MODIFY_VOLUME = ControllerServiceCapability_RPC_Type_MODIFY_VOLUME;
  static inline bool Type_IsValid(int value) {
    return ControllerServiceCapability_RPC_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = ControllerServiceCapability_RPC_Type_Type_MIN;
  static constexpr Type Type_MAX = ControllerServiceCapability_RPC_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = ControllerServiceCapability_RPC_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return ControllerServiceCapability_RPC_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return ControllerServiceCapability_RPC_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return ControllerServiceCapability_RPC_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.ControllerServiceCapability.RPC.Type type = 1;
  void clear_type() ;
  ::csi::v1::ControllerServiceCapability_RPC_Type type() const;
  void set_type(::csi::v1::ControllerServiceCapability_RPC_Type value);

  private:
  ::csi::v1::ControllerServiceCapability_RPC_Type _internal_type() const;
  void _internal_set_type(::csi::v1::ControllerServiceCapability_RPC_Type value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability.RPC)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse*>(
        &_ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeResponse.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeResponse.PublishContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse*>(
        &_ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerPublishVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerPublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerPublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerPublishVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerPublishVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerPublishVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerPublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeRequest_SecretsEntry_DoNotUse*>(
        &_ControllerPublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerModifyVolumeResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.ControllerModifyVolumeResponse) */ {
 public:
  inline ControllerModifyVolumeResponse() : ControllerModifyVolumeResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerModifyVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerModifyVolumeResponse(const ControllerModifyVolumeResponse& from)
      : ControllerModifyVolumeResponse(nullptr, from) {}
  ControllerModifyVolumeResponse(ControllerModifyVolumeResponse&& from) noexcept
    : ControllerModifyVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerModifyVolumeResponse& operator=(const ControllerModifyVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerModifyVolumeResponse& operator=(ControllerModifyVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerModifyVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerModifyVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerModifyVolumeResponse*>(
               &_ControllerModifyVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ControllerModifyVolumeResponse& a, ControllerModifyVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerModifyVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerModifyVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerModifyVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerModifyVolumeResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ControllerModifyVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ControllerModifyVolumeResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerModifyVolumeResponse";
  }
  protected:
  explicit ControllerModifyVolumeResponse(::google::protobuf::Arena* arena);
  ControllerModifyVolumeResponse(::google::protobuf::Arena* arena, const ControllerModifyVolumeResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerModifyVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerModifyVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerModifyVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerModifyVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerModifyVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerModifyVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerModifyVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerModifyVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerModifyVolumeRequest_SecretsEntry_DoNotUse*>(
        &_ControllerModifyVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerModifyVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerModifyVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse*>(
        &_ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerModifyVolumeRequest.MutableParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerModifyVolumeRequest.MutableParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeRequest) */ {
 public:
  inline ControllerGetVolumeRequest() : ControllerGetVolumeRequest(nullptr) {}
  ~ControllerGetVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerGetVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerGetVolumeRequest(const ControllerGetVolumeRequest& from)
      : ControllerGetVolumeRequest(nullptr, from) {}
  ControllerGetVolumeRequest(ControllerGetVolumeRequest&& from) noexcept
    : ControllerGetVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeRequest& operator=(const ControllerGetVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeRequest& operator=(ControllerGetVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerGetVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerGetVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeRequest*>(
               &_ControllerGetVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ControllerGetVolumeRequest& a, ControllerGetVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerGetVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerGetVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerGetVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerGetVolumeRequest& from) {
    ControllerGetVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerGetVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerGetVolumeRequest";
  }
  protected:
  explicit ControllerGetVolumeRequest(::google::protobuf::Arena* arena);
  ControllerGetVolumeRequest(::google::protobuf::Arena* arena, const ControllerGetVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
  };
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerGetCapabilitiesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetCapabilitiesRequest) */ {
 public:
  inline ControllerGetCapabilitiesRequest() : ControllerGetCapabilitiesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerGetCapabilitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerGetCapabilitiesRequest(const ControllerGetCapabilitiesRequest& from)
      : ControllerGetCapabilitiesRequest(nullptr, from) {}
  ControllerGetCapabilitiesRequest(ControllerGetCapabilitiesRequest&& from) noexcept
    : ControllerGetCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline ControllerGetCapabilitiesRequest& operator=(const ControllerGetCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetCapabilitiesRequest& operator=(ControllerGetCapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerGetCapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerGetCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerGetCapabilitiesRequest*>(
               &_ControllerGetCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(ControllerGetCapabilitiesRequest& a, ControllerGetCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerGetCapabilitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ControllerGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ControllerGetCapabilitiesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerGetCapabilitiesRequest";
  }
  protected:
  explicit ControllerGetCapabilitiesRequest(::google::protobuf::Arena* arena);
  ControllerGetCapabilitiesRequest(::google::protobuf::Arena* arena, const ControllerGetCapabilitiesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerExpandVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerExpandVolumeResponse) */ {
 public:
  inline ControllerExpandVolumeResponse() : ControllerExpandVolumeResponse(nullptr) {}
  ~ControllerExpandVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerExpandVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerExpandVolumeResponse(const ControllerExpandVolumeResponse& from)
      : ControllerExpandVolumeResponse(nullptr, from) {}
  ControllerExpandVolumeResponse(ControllerExpandVolumeResponse&& from) noexcept
    : ControllerExpandVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerExpandVolumeResponse& operator=(const ControllerExpandVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerExpandVolumeResponse& operator=(ControllerExpandVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerExpandVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerExpandVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerExpandVolumeResponse*>(
               &_ControllerExpandVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(ControllerExpandVolumeResponse& a, ControllerExpandVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerExpandVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerExpandVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerExpandVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerExpandVolumeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerExpandVolumeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerExpandVolumeResponse& from) {
    ControllerExpandVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerExpandVolumeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerExpandVolumeResponse";
  }
  protected:
  explicit ControllerExpandVolumeResponse(::google::protobuf::Arena* arena);
  ControllerExpandVolumeResponse(::google::protobuf::Arena* arena, const ControllerExpandVolumeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityBytesFieldNumber = 1,
    kNodeExpansionRequiredFieldNumber = 2,
  };
  // int64 capacity_bytes = 1;
  void clear_capacity_bytes() ;
  ::int64_t capacity_bytes() const;
  void set_capacity_bytes(::int64_t value);

  private:
  ::int64_t _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::int64_t value);

  public:
  // bool node_expansion_required = 2;
  void clear_node_expansion_required() ;
  bool node_expansion_required() const;
  void set_node_expansion_required(bool value);

  private:
  bool _internal_node_expansion_required() const;
  void _internal_set_node_expansion_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t capacity_bytes_;
    bool node_expansion_required_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerExpandVolumeRequest_SecretsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          ControllerExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      ControllerExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ControllerExpandVolumeRequest_SecretsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerExpandVolumeRequest_SecretsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit ControllerExpandVolumeRequest_SecretsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const ControllerExpandVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const ControllerExpandVolumeRequest_SecretsEntry_DoNotUse*>(
        &_ControllerExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerExpandVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "csi.v1.ControllerExpandVolumeRequest.SecretsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};
// -------------------------------------------------------------------

class CapacityRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CapacityRange) */ {
 public:
  inline CapacityRange() : CapacityRange(nullptr) {}
  ~CapacityRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CapacityRange(::google::protobuf::internal::ConstantInitialized);

  inline CapacityRange(const CapacityRange& from)
      : CapacityRange(nullptr, from) {}
  CapacityRange(CapacityRange&& from) noexcept
    : CapacityRange() {
    *this = ::std::move(from);
  }

  inline CapacityRange& operator=(const CapacityRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityRange& operator=(CapacityRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapacityRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapacityRange* internal_default_instance() {
    return reinterpret_cast<const CapacityRange*>(
               &_CapacityRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CapacityRange& a, CapacityRange& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacityRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapacityRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapacityRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CapacityRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CapacityRange& from) {
    CapacityRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CapacityRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CapacityRange";
  }
  protected:
  explicit CapacityRange(::google::protobuf::Arena* arena);
  CapacityRange(::google::protobuf::Arena* arena, const CapacityRange& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredBytesFieldNumber = 1,
    kLimitBytesFieldNumber = 2,
  };
  // int64 required_bytes = 1;
  void clear_required_bytes() ;
  ::int64_t required_bytes() const;
  void set_required_bytes(::int64_t value);

  private:
  ::int64_t _internal_required_bytes() const;
  void _internal_set_required_bytes(::int64_t value);

  public:
  // int64 limit_bytes = 2;
  void clear_limit_bytes() ;
  ::int64_t limit_bytes() const;
  void set_limit_bytes(::int64_t value);

  private:
  ::int64_t _internal_limit_bytes() const;
  void _internal_set_limit_bytes(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CapacityRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t required_bytes_;
    ::int64_t limit_bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeContentSource final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource) */ {
 public:
  inline VolumeContentSource() : VolumeContentSource(nullptr) {}
  ~VolumeContentSource() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeContentSource(::google::protobuf::internal::ConstantInitialized);

  inline VolumeContentSource(const VolumeContentSource& from)
      : VolumeContentSource(nullptr, from) {}
  VolumeContentSource(VolumeContentSource&& from) noexcept
    : VolumeContentSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource& operator=(const VolumeContentSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource& operator=(VolumeContentSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeContentSource& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSnapshot = 1,
    kVolume = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const VolumeContentSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource*>(
               &_VolumeContentSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VolumeContentSource& a, VolumeContentSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeContentSource* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeContentSource>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeContentSource& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeContentSource& from) {
    VolumeContentSource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeContentSource* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeContentSource";
  }
  protected:
  explicit VolumeContentSource(::google::protobuf::Arena* arena);
  VolumeContentSource(::google::protobuf::Arena* arena, const VolumeContentSource& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SnapshotSource = VolumeContentSource_SnapshotSource;
  using VolumeSource = VolumeContentSource_VolumeSource;

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kVolumeFieldNumber = 2,
  };
  // .csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;

  public:
  void clear_snapshot() ;
  const ::csi::v1::VolumeContentSource_SnapshotSource& snapshot() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeContentSource_SnapshotSource* release_snapshot();
  ::csi::v1::VolumeContentSource_SnapshotSource* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::VolumeContentSource_SnapshotSource* value);
  void unsafe_arena_set_allocated_snapshot(::csi::v1::VolumeContentSource_SnapshotSource* value);
  ::csi::v1::VolumeContentSource_SnapshotSource* unsafe_arena_release_snapshot();

  private:
  const ::csi::v1::VolumeContentSource_SnapshotSource& _internal_snapshot() const;
  ::csi::v1::VolumeContentSource_SnapshotSource* _internal_mutable_snapshot();

  public:
  // .csi.v1.VolumeContentSource.VolumeSource volume = 2;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;

  public:
  void clear_volume() ;
  const ::csi::v1::VolumeContentSource_VolumeSource& volume() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeContentSource_VolumeSource* release_volume();
  ::csi::v1::VolumeContentSource_VolumeSource* mutable_volume();
  void set_allocated_volume(::csi::v1::VolumeContentSource_VolumeSource* value);
  void unsafe_arena_set_allocated_volume(::csi::v1::VolumeContentSource_VolumeSource* value);
  ::csi::v1::VolumeContentSource_VolumeSource* unsafe_arena_release_volume();

  private:
  const ::csi::v1::VolumeContentSource_VolumeSource& _internal_volume() const;
  ::csi::v1::VolumeContentSource_VolumeSource* _internal_mutable_volume();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource)
 private:
  class _Internal;
  void set_has_snapshot();
  void set_has_volume();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::VolumeContentSource_SnapshotSource* snapshot_;
      ::csi::v1::VolumeContentSource_VolumeSource* volume_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeCapability final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability) */ {
 public:
  inline VolumeCapability() : VolumeCapability(nullptr) {}
  ~VolumeCapability() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeCapability(::google::protobuf::internal::ConstantInitialized);

  inline VolumeCapability(const VolumeCapability& from)
      : VolumeCapability(nullptr, from) {}
  VolumeCapability(VolumeCapability&& from) noexcept
    : VolumeCapability() {
    *this = ::std::move(from);
  }

  inline VolumeCapability& operator=(const VolumeCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability& operator=(VolumeCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeCapability& default_instance() {
    return *internal_default_instance();
  }
  enum AccessTypeCase {
    kBlock = 1,
    kMount = 2,
    ACCESS_TYPE_NOT_SET = 0,
  };

  static inline const VolumeCapability* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability*>(
               &_VolumeCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VolumeCapability& a, VolumeCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeCapability* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeCapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeCapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeCapability& from) {
    VolumeCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeCapability* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeCapability";
  }
  protected:
  explicit VolumeCapability(::google::protobuf::Arena* arena);
  VolumeCapability(::google::protobuf::Arena* arena, const VolumeCapability& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BlockVolume = VolumeCapability_BlockVolume;
  using MountVolume = VolumeCapability_MountVolume;
  using AccessMode = VolumeCapability_AccessMode;

  // accessors -------------------------------------------------------

  enum : int {
    kAccessModeFieldNumber = 3,
    kBlockFieldNumber = 1,
    kMountFieldNumber = 2,
  };
  // .csi.v1.VolumeCapability.AccessMode access_mode = 3;
  bool has_access_mode() const;
  void clear_access_mode() ;
  const ::csi::v1::VolumeCapability_AccessMode& access_mode() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability_AccessMode* release_access_mode();
  ::csi::v1::VolumeCapability_AccessMode* mutable_access_mode();
  void set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* value);
  void unsafe_arena_set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* value);
  ::csi::v1::VolumeCapability_AccessMode* unsafe_arena_release_access_mode();

  private:
  const ::csi::v1::VolumeCapability_AccessMode& _internal_access_mode() const;
  ::csi::v1::VolumeCapability_AccessMode* _internal_mutable_access_mode();

  public:
  // .csi.v1.VolumeCapability.BlockVolume block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;

  public:
  void clear_block() ;
  const ::csi::v1::VolumeCapability_BlockVolume& block() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability_BlockVolume* release_block();
  ::csi::v1::VolumeCapability_BlockVolume* mutable_block();
  void set_allocated_block(::csi::v1::VolumeCapability_BlockVolume* value);
  void unsafe_arena_set_allocated_block(::csi::v1::VolumeCapability_BlockVolume* value);
  ::csi::v1::VolumeCapability_BlockVolume* unsafe_arena_release_block();

  private:
  const ::csi::v1::VolumeCapability_BlockVolume& _internal_block() const;
  ::csi::v1::VolumeCapability_BlockVolume* _internal_mutable_block();

  public:
  // .csi.v1.VolumeCapability.MountVolume mount = 2;
  bool has_mount() const;
  private:
  bool _internal_has_mount() const;

  public:
  void clear_mount() ;
  const ::csi::v1::VolumeCapability_MountVolume& mount() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability_MountVolume* release_mount();
  ::csi::v1::VolumeCapability_MountVolume* mutable_mount();
  void set_allocated_mount(::csi::v1::VolumeCapability_MountVolume* value);
  void unsafe_arena_set_allocated_mount(::csi::v1::VolumeCapability_MountVolume* value);
  ::csi::v1::VolumeCapability_MountVolume* unsafe_arena_release_mount();

  private:
  const ::csi::v1::VolumeCapability_MountVolume& _internal_mount() const;
  ::csi::v1::VolumeCapability_MountVolume* _internal_mutable_mount();

  public:
  void clear_access_type();
  AccessTypeCase access_type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability)
 private:
  class _Internal;
  void set_has_block();
  void set_has_mount();

  inline bool has_access_type() const;
  inline void clear_has_access_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::VolumeCapability_AccessMode* access_mode_;
    union AccessTypeUnion {
      constexpr AccessTypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::VolumeCapability_BlockVolume* block_;
      ::csi::v1::VolumeCapability_MountVolume* mount_;
    } access_type_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class Topology final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.Topology) */ {
 public:
  inline Topology() : Topology(nullptr) {}
  ~Topology() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Topology(::google::protobuf::internal::ConstantInitialized);

  inline Topology(const Topology& from)
      : Topology(nullptr, from) {}
  Topology(Topology&& from) noexcept
    : Topology() {
    *this = ::std::move(from);
  }

  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }
  inline Topology& operator=(Topology&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Topology& default_instance() {
    return *internal_default_instance();
  }
  static inline const Topology* internal_default_instance() {
    return reinterpret_cast<const Topology*>(
               &_Topology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Topology& a, Topology& b) {
    a.Swap(&b);
  }
  inline void Swap(Topology* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Topology* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Topology* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Topology>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Topology& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Topology& from) {
    Topology::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Topology* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.Topology";
  }
  protected:
  explicit Topology(::google::protobuf::Arena* arena);
  Topology(::google::protobuf::Arena* arena, const Topology& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // map<string, string> segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  const ::google::protobuf::Map<std::string, std::string>& segments() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_segments();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_segments() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_segments();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.Topology)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<Topology_SegmentsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        segments_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class Snapshot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {}
  ~Snapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Snapshot(::google::protobuf::internal::ConstantInitialized);

  inline Snapshot(const Snapshot& from)
      : Snapshot(nullptr, from) {}
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snapshot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Snapshot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Snapshot& from) {
    Snapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Snapshot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.Snapshot";
  }
  protected:
  explicit Snapshot(::google::protobuf::Arena* arena);
  Snapshot(::google::protobuf::Arena* arena, const Snapshot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdFieldNumber = 2,
    kSourceVolumeIdFieldNumber = 3,
    kGroupSnapshotIdFieldNumber = 6,
    kCreationTimeFieldNumber = 4,
    kSizeBytesFieldNumber = 1,
    kReadyToUseFieldNumber = 5,
  };
  // string snapshot_id = 2;
  void clear_snapshot_id() ;
  const std::string& snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* value);

  private:
  const std::string& _internal_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_snapshot_id();

  public:
  // string source_volume_id = 3;
  void clear_source_volume_id() ;
  const std::string& source_volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_volume_id();
  PROTOBUF_NODISCARD std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* value);

  private:
  const std::string& _internal_source_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_volume_id(
      const std::string& value);
  std::string* _internal_mutable_source_volume_id();

  public:
  // string group_snapshot_id = 6 [(.csi.v1.alpha_field) = true];
  void clear_group_snapshot_id() ;
  const std::string& group_snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_group_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_group_snapshot_id();
  void set_allocated_group_snapshot_id(std::string* value);

  private:
  const std::string& _internal_group_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_group_snapshot_id();

  public:
  // .google.protobuf.Timestamp creation_time = 4;
  bool has_creation_time() const;
  void clear_creation_time() ;
  const ::google::protobuf::Timestamp& creation_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_creation_time();
  ::google::protobuf::Timestamp* mutable_creation_time();
  void set_allocated_creation_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_creation_time();

  private:
  const ::google::protobuf::Timestamp& _internal_creation_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_creation_time();

  public:
  // int64 size_bytes = 1;
  void clear_size_bytes() ;
  ::int64_t size_bytes() const;
  void set_size_bytes(::int64_t value);

  private:
  ::int64_t _internal_size_bytes() const;
  void _internal_set_size_bytes(::int64_t value);

  public:
  // bool ready_to_use = 5;
  void clear_ready_to_use() ;
  bool ready_to_use() const;
  void set_ready_to_use(bool value);

  private:
  bool _internal_ready_to_use() const;
  void _internal_set_ready_to_use(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.Snapshot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr snapshot_id_;
    ::google::protobuf::internal::ArenaStringPtr source_volume_id_;
    ::google::protobuf::internal::ArenaStringPtr group_snapshot_id_;
    ::google::protobuf::Timestamp* creation_time_;
    ::int64_t size_bytes_;
    bool ready_to_use_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ProbeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ProbeResponse) */ {
 public:
  inline ProbeResponse() : ProbeResponse(nullptr) {}
  ~ProbeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ProbeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ProbeResponse(const ProbeResponse& from)
      : ProbeResponse(nullptr, from) {}
  ProbeResponse(ProbeResponse&& from) noexcept
    : ProbeResponse() {
    *this = ::std::move(from);
  }

  inline ProbeResponse& operator=(const ProbeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProbeResponse& operator=(ProbeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProbeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProbeResponse* internal_default_instance() {
    return reinterpret_cast<const ProbeResponse*>(
               &_ProbeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProbeResponse& a, ProbeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProbeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProbeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProbeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProbeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProbeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ProbeResponse& from) {
    ProbeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProbeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ProbeResponse";
  }
  protected:
  explicit ProbeResponse(::google::protobuf::Arena* arena);
  ProbeResponse(::google::protobuf::Arena* arena, const ProbeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // .google.protobuf.BoolValue ready = 1;
  bool has_ready() const;
  void clear_ready() ;
  const ::google::protobuf::BoolValue& ready() const;
  PROTOBUF_NODISCARD ::google::protobuf::BoolValue* release_ready();
  ::google::protobuf::BoolValue* mutable_ready();
  void set_allocated_ready(::google::protobuf::BoolValue* value);
  void unsafe_arena_set_allocated_ready(::google::protobuf::BoolValue* value);
  ::google::protobuf::BoolValue* unsafe_arena_release_ready();

  private:
  const ::google::protobuf::BoolValue& _internal_ready() const;
  ::google::protobuf::BoolValue* _internal_mutable_ready();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ProbeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::BoolValue* ready_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class PluginCapability final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability) */ {
 public:
  inline PluginCapability() : PluginCapability(nullptr) {}
  ~PluginCapability() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PluginCapability(::google::protobuf::internal::ConstantInitialized);

  inline PluginCapability(const PluginCapability& from)
      : PluginCapability(nullptr, from) {}
  PluginCapability(PluginCapability&& from) noexcept
    : PluginCapability() {
    *this = ::std::move(from);
  }

  inline PluginCapability& operator=(const PluginCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability& operator=(PluginCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PluginCapability& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kService = 1,
    kVolumeExpansion = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const PluginCapability* internal_default_instance() {
    return reinterpret_cast<const PluginCapability*>(
               &_PluginCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PluginCapability& a, PluginCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PluginCapability* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PluginCapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PluginCapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PluginCapability& from) {
    PluginCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PluginCapability* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.PluginCapability";
  }
  protected:
  explicit PluginCapability(::google::protobuf::Arena* arena);
  PluginCapability(::google::protobuf::Arena* arena, const PluginCapability& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Service = PluginCapability_Service;
  using VolumeExpansion = PluginCapability_VolumeExpansion;

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kVolumeExpansionFieldNumber = 2,
  };
  // .csi.v1.PluginCapability.Service service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;

  public:
  void clear_service() ;
  const ::csi::v1::PluginCapability_Service& service() const;
  PROTOBUF_NODISCARD ::csi::v1::PluginCapability_Service* release_service();
  ::csi::v1::PluginCapability_Service* mutable_service();
  void set_allocated_service(::csi::v1::PluginCapability_Service* value);
  void unsafe_arena_set_allocated_service(::csi::v1::PluginCapability_Service* value);
  ::csi::v1::PluginCapability_Service* unsafe_arena_release_service();

  private:
  const ::csi::v1::PluginCapability_Service& _internal_service() const;
  ::csi::v1::PluginCapability_Service* _internal_mutable_service();

  public:
  // .csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;
  bool has_volume_expansion() const;
  private:
  bool _internal_has_volume_expansion() const;

  public:
  void clear_volume_expansion() ;
  const ::csi::v1::PluginCapability_VolumeExpansion& volume_expansion() const;
  PROTOBUF_NODISCARD ::csi::v1::PluginCapability_VolumeExpansion* release_volume_expansion();
  ::csi::v1::PluginCapability_VolumeExpansion* mutable_volume_expansion();
  void set_allocated_volume_expansion(::csi::v1::PluginCapability_VolumeExpansion* value);
  void unsafe_arena_set_allocated_volume_expansion(::csi::v1::PluginCapability_VolumeExpansion* value);
  ::csi::v1::PluginCapability_VolumeExpansion* unsafe_arena_release_volume_expansion();

  private:
  const ::csi::v1::PluginCapability_VolumeExpansion& _internal_volume_expansion() const;
  ::csi::v1::PluginCapability_VolumeExpansion* _internal_mutable_volume_expansion();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability)
 private:
  class _Internal;
  void set_has_service();
  void set_has_volume_expansion();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::PluginCapability_Service* service_;
      ::csi::v1::PluginCapability_VolumeExpansion* volume_expansion_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeServiceCapability final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeServiceCapability) */ {
 public:
  inline NodeServiceCapability() : NodeServiceCapability(nullptr) {}
  ~NodeServiceCapability() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeServiceCapability(::google::protobuf::internal::ConstantInitialized);

  inline NodeServiceCapability(const NodeServiceCapability& from)
      : NodeServiceCapability(nullptr, from) {}
  NodeServiceCapability(NodeServiceCapability&& from) noexcept
    : NodeServiceCapability() {
    *this = ::std::move(from);
  }

  inline NodeServiceCapability& operator=(const NodeServiceCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeServiceCapability& operator=(NodeServiceCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeServiceCapability& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kRpc = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const NodeServiceCapability* internal_default_instance() {
    return reinterpret_cast<const NodeServiceCapability*>(
               &_NodeServiceCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(NodeServiceCapability& a, NodeServiceCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeServiceCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeServiceCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeServiceCapability* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeServiceCapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeServiceCapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeServiceCapability& from) {
    NodeServiceCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeServiceCapability* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeServiceCapability";
  }
  protected:
  explicit NodeServiceCapability(::google::protobuf::Arena* arena);
  NodeServiceCapability(::google::protobuf::Arena* arena, const NodeServiceCapability& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RPC = NodeServiceCapability_RPC;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcFieldNumber = 1,
  };
  // .csi.v1.NodeServiceCapability.RPC rpc = 1;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;

  public:
  void clear_rpc() ;
  const ::csi::v1::NodeServiceCapability_RPC& rpc() const;
  PROTOBUF_NODISCARD ::csi::v1::NodeServiceCapability_RPC* release_rpc();
  ::csi::v1::NodeServiceCapability_RPC* mutable_rpc();
  void set_allocated_rpc(::csi::v1::NodeServiceCapability_RPC* value);
  void unsafe_arena_set_allocated_rpc(::csi::v1::NodeServiceCapability_RPC* value);
  ::csi::v1::NodeServiceCapability_RPC* unsafe_arena_release_rpc();

  private:
  const ::csi::v1::NodeServiceCapability_RPC& _internal_rpc() const;
  ::csi::v1::NodeServiceCapability_RPC* _internal_mutable_rpc();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability)
 private:
  class _Internal;
  void set_has_rpc();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::NodeServiceCapability_RPC* rpc_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeGetVolumeStatsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetVolumeStatsResponse) */ {
 public:
  inline NodeGetVolumeStatsResponse() : NodeGetVolumeStatsResponse(nullptr) {}
  ~NodeGetVolumeStatsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetVolumeStatsResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetVolumeStatsResponse(const NodeGetVolumeStatsResponse& from)
      : NodeGetVolumeStatsResponse(nullptr, from) {}
  NodeGetVolumeStatsResponse(NodeGetVolumeStatsResponse&& from) noexcept
    : NodeGetVolumeStatsResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetVolumeStatsResponse& operator=(const NodeGetVolumeStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetVolumeStatsResponse& operator=(NodeGetVolumeStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetVolumeStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetVolumeStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetVolumeStatsResponse*>(
               &_NodeGetVolumeStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(NodeGetVolumeStatsResponse& a, NodeGetVolumeStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetVolumeStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetVolumeStatsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetVolumeStatsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetVolumeStatsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeGetVolumeStatsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeGetVolumeStatsResponse& from) {
    NodeGetVolumeStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeGetVolumeStatsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetVolumeStatsResponse";
  }
  protected:
  explicit NodeGetVolumeStatsResponse(::google::protobuf::Arena* arena);
  NodeGetVolumeStatsResponse(::google::protobuf::Arena* arena, const NodeGetVolumeStatsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsageFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated .csi.v1.VolumeUsage usage = 1;
  int usage_size() const;
  private:
  int _internal_usage_size() const;

  public:
  void clear_usage() ;
  ::csi::v1::VolumeUsage* mutable_usage(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeUsage >*
      mutable_usage();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>& _internal_usage() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>* _internal_mutable_usage();
  public:
  const ::csi::v1::VolumeUsage& usage(int index) const;
  ::csi::v1::VolumeUsage* add_usage();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeUsage >&
      usage() const;
  // .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
  bool has_volume_condition() const;
  void clear_volume_condition() ;
  const ::csi::v1::VolumeCondition& volume_condition() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  void unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeUsage > usage_;
    ::csi::v1::VolumeCondition* volume_condition_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListVolumesResponse_VolumeStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse.VolumeStatus) */ {
 public:
  inline ListVolumesResponse_VolumeStatus() : ListVolumesResponse_VolumeStatus(nullptr) {}
  ~ListVolumesResponse_VolumeStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListVolumesResponse_VolumeStatus(::google::protobuf::internal::ConstantInitialized);

  inline ListVolumesResponse_VolumeStatus(const ListVolumesResponse_VolumeStatus& from)
      : ListVolumesResponse_VolumeStatus(nullptr, from) {}
  ListVolumesResponse_VolumeStatus(ListVolumesResponse_VolumeStatus&& from) noexcept
    : ListVolumesResponse_VolumeStatus() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse_VolumeStatus& operator=(const ListVolumesResponse_VolumeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse_VolumeStatus& operator=(ListVolumesResponse_VolumeStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVolumesResponse_VolumeStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVolumesResponse_VolumeStatus* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse_VolumeStatus*>(
               &_ListVolumesResponse_VolumeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ListVolumesResponse_VolumeStatus& a, ListVolumesResponse_VolumeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse_VolumeStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse_VolumeStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVolumesResponse_VolumeStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVolumesResponse_VolumeStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListVolumesResponse_VolumeStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListVolumesResponse_VolumeStatus& from) {
    ListVolumesResponse_VolumeStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListVolumesResponse_VolumeStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListVolumesResponse.VolumeStatus";
  }
  protected:
  explicit ListVolumesResponse_VolumeStatus(::google::protobuf::Arena* arena);
  ListVolumesResponse_VolumeStatus(::google::protobuf::Arena* arena, const ListVolumesResponse_VolumeStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishedNodeIdsFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated string published_node_ids = 1;
  int published_node_ids_size() const;
  private:
  int _internal_published_node_ids_size() const;

  public:
  void clear_published_node_ids() ;
  const std::string& published_node_ids(int index) const;
  std::string* mutable_published_node_ids(int index);
  void set_published_node_ids(int index, const std::string& value);
  void set_published_node_ids(int index, std::string&& value);
  void set_published_node_ids(int index, const char* value);
  void set_published_node_ids(int index, const char* value, std::size_t size);
  void set_published_node_ids(int index, absl::string_view value);
  std::string* add_published_node_ids();
  void add_published_node_ids(const std::string& value);
  void add_published_node_ids(std::string&& value);
  void add_published_node_ids(const char* value);
  void add_published_node_ids(const char* value, std::size_t size);
  void add_published_node_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& published_node_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_published_node_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_published_node_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_published_node_ids();

  public:
  // .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
  bool has_volume_condition() const;
  void clear_volume_condition() ;
  const ::csi::v1::VolumeCondition& volume_condition() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  void unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse.VolumeStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> published_node_ids_;
    ::csi::v1::VolumeCondition* volume_condition_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListSnapshotsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsRequest) */ {
 public:
  inline ListSnapshotsRequest() : ListSnapshotsRequest(nullptr) {}
  ~ListSnapshotsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListSnapshotsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListSnapshotsRequest(const ListSnapshotsRequest& from)
      : ListSnapshotsRequest(nullptr, from) {}
  ListSnapshotsRequest(ListSnapshotsRequest&& from) noexcept
    : ListSnapshotsRequest() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsRequest& operator=(const ListSnapshotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsRequest& operator=(ListSnapshotsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSnapshotsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSnapshotsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsRequest*>(
               &_ListSnapshotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(ListSnapshotsRequest& a, ListSnapshotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSnapshotsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSnapshotsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListSnapshotsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListSnapshotsRequest& from) {
    ListSnapshotsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListSnapshotsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListSnapshotsRequest";
  }
  protected:
  explicit ListSnapshotsRequest(::google::protobuf::Arena* arena);
  ListSnapshotsRequest(::google::protobuf::Arena* arena, const ListSnapshotsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 5,
    kStartingTokenFieldNumber = 2,
    kSourceVolumeIdFieldNumber = 3,
    kSnapshotIdFieldNumber = 4,
    kMaxEntriesFieldNumber = 1,
  };
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string starting_token = 2;
  void clear_starting_token() ;
  const std::string& starting_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_starting_token(Arg_&& arg, Args_... args);
  std::string* mutable_starting_token();
  PROTOBUF_NODISCARD std::string* release_starting_token();
  void set_allocated_starting_token(std::string* value);

  private:
  const std::string& _internal_starting_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_starting_token(
      const std::string& value);
  std::string* _internal_mutable_starting_token();

  public:
  // string source_volume_id = 3;
  void clear_source_volume_id() ;
  const std::string& source_volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_volume_id();
  PROTOBUF_NODISCARD std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* value);

  private:
  const std::string& _internal_source_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_volume_id(
      const std::string& value);
  std::string* _internal_mutable_source_volume_id();

  public:
  // string snapshot_id = 4;
  void clear_snapshot_id() ;
  const std::string& snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* value);

  private:
  const std::string& _internal_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_snapshot_id();

  public:
  // int32 max_entries = 1;
  void clear_max_entries() ;
  ::int32_t max_entries() const;
  void set_max_entries(::int32_t value);

  private:
  ::int32_t _internal_max_entries() const;
  void _internal_set_max_entries(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ListSnapshotsRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr starting_token_;
    ::google::protobuf::internal::ArenaStringPtr source_volume_id_;
    ::google::protobuf::internal::ArenaStringPtr snapshot_id_;
    ::int32_t max_entries_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GroupControllerServiceCapability final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GroupControllerServiceCapability) */ {
 public:
  inline GroupControllerServiceCapability() : GroupControllerServiceCapability(nullptr) {}
  ~GroupControllerServiceCapability() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupControllerServiceCapability(::google::protobuf::internal::ConstantInitialized);

  inline GroupControllerServiceCapability(const GroupControllerServiceCapability& from)
      : GroupControllerServiceCapability(nullptr, from) {}
  GroupControllerServiceCapability(GroupControllerServiceCapability&& from) noexcept
    : GroupControllerServiceCapability() {
    *this = ::std::move(from);
  }

  inline GroupControllerServiceCapability& operator=(const GroupControllerServiceCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupControllerServiceCapability& operator=(GroupControllerServiceCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupControllerServiceCapability& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kRpc = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const GroupControllerServiceCapability* internal_default_instance() {
    return reinterpret_cast<const GroupControllerServiceCapability*>(
               &_GroupControllerServiceCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(GroupControllerServiceCapability& a, GroupControllerServiceCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupControllerServiceCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupControllerServiceCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupControllerServiceCapability* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupControllerServiceCapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupControllerServiceCapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupControllerServiceCapability& from) {
    GroupControllerServiceCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupControllerServiceCapability* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GroupControllerServiceCapability";
  }
  protected:
  explicit GroupControllerServiceCapability(::google::protobuf::Arena* arena);
  GroupControllerServiceCapability(::google::protobuf::Arena* arena, const GroupControllerServiceCapability& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RPC = GroupControllerServiceCapability_RPC;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcFieldNumber = 1,
  };
  // .csi.v1.GroupControllerServiceCapability.RPC rpc = 1;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;

  public:
  void clear_rpc() ;
  const ::csi::v1::GroupControllerServiceCapability_RPC& rpc() const;
  PROTOBUF_NODISCARD ::csi::v1::GroupControllerServiceCapability_RPC* release_rpc();
  ::csi::v1::GroupControllerServiceCapability_RPC* mutable_rpc();
  void set_allocated_rpc(::csi::v1::GroupControllerServiceCapability_RPC* value);
  void unsafe_arena_set_allocated_rpc(::csi::v1::GroupControllerServiceCapability_RPC* value);
  ::csi::v1::GroupControllerServiceCapability_RPC* unsafe_arena_release_rpc();

  private:
  const ::csi::v1::GroupControllerServiceCapability_RPC& _internal_rpc() const;
  ::csi::v1::GroupControllerServiceCapability_RPC* _internal_mutable_rpc();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.GroupControllerServiceCapability)
 private:
  class _Internal;
  void set_has_rpc();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::GroupControllerServiceCapability_RPC* rpc_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetVolumeGroupSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetVolumeGroupSnapshotRequest) */ {
 public:
  inline GetVolumeGroupSnapshotRequest() : GetVolumeGroupSnapshotRequest(nullptr) {}
  ~GetVolumeGroupSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetVolumeGroupSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetVolumeGroupSnapshotRequest(const GetVolumeGroupSnapshotRequest& from)
      : GetVolumeGroupSnapshotRequest(nullptr, from) {}
  GetVolumeGroupSnapshotRequest(GetVolumeGroupSnapshotRequest&& from) noexcept
    : GetVolumeGroupSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline GetVolumeGroupSnapshotRequest& operator=(const GetVolumeGroupSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVolumeGroupSnapshotRequest& operator=(GetVolumeGroupSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVolumeGroupSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVolumeGroupSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const GetVolumeGroupSnapshotRequest*>(
               &_GetVolumeGroupSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(GetVolumeGroupSnapshotRequest& a, GetVolumeGroupSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVolumeGroupSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVolumeGroupSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetVolumeGroupSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetVolumeGroupSnapshotRequest& from) {
    GetVolumeGroupSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetVolumeGroupSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetVolumeGroupSnapshotRequest";
  }
  protected:
  explicit GetVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena);
  GetVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena, const GetVolumeGroupSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdsFieldNumber = 2,
    kSecretsFieldNumber = 3,
    kGroupSnapshotIdFieldNumber = 1,
  };
  // repeated string snapshot_ids = 2;
  int snapshot_ids_size() const;
  private:
  int _internal_snapshot_ids_size() const;

  public:
  void clear_snapshot_ids() ;
  const std::string& snapshot_ids(int index) const;
  std::string* mutable_snapshot_ids(int index);
  void set_snapshot_ids(int index, const std::string& value);
  void set_snapshot_ids(int index, std::string&& value);
  void set_snapshot_ids(int index, const char* value);
  void set_snapshot_ids(int index, const char* value, std::size_t size);
  void set_snapshot_ids(int index, absl::string_view value);
  std::string* add_snapshot_ids();
  void add_snapshot_ids(const std::string& value);
  void add_snapshot_ids(std::string&& value);
  void add_snapshot_ids(const char* value);
  void add_snapshot_ids(const char* value, std::size_t size);
  void add_snapshot_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& snapshot_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_snapshot_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_snapshot_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_snapshot_ids();

  public:
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string group_snapshot_id = 1;
  void clear_group_snapshot_id() ;
  const std::string& group_snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_group_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_group_snapshot_id();
  void set_allocated_group_snapshot_id(std::string* value);

  private:
  const std::string& _internal_group_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_group_snapshot_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GetVolumeGroupSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      81, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> snapshot_ids_;
    ::google::protobuf::internal::MapField<GetVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr group_snapshot_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetPluginInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginInfoResponse) */ {
 public:
  inline GetPluginInfoResponse() : GetPluginInfoResponse(nullptr) {}
  ~GetPluginInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPluginInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPluginInfoResponse(const GetPluginInfoResponse& from)
      : GetPluginInfoResponse(nullptr, from) {}
  GetPluginInfoResponse(GetPluginInfoResponse&& from) noexcept
    : GetPluginInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetPluginInfoResponse& operator=(const GetPluginInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginInfoResponse& operator=(GetPluginInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPluginInfoResponse*>(
               &_GetPluginInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetPluginInfoResponse& a, GetPluginInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPluginInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPluginInfoResponse& from) {
    GetPluginInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPluginInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetPluginInfoResponse";
  }
  protected:
  explicit GetPluginInfoResponse(::google::protobuf::Arena* arena);
  GetPluginInfoResponse(::google::protobuf::Arena* arena, const GetPluginInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kManifestFieldNumber = 3,
    kNameFieldNumber = 1,
    kVendorVersionFieldNumber = 2,
  };
  // map<string, string> manifest = 3;
  int manifest_size() const;
  private:
  int _internal_manifest_size() const;

  public:
  void clear_manifest() ;
  const ::google::protobuf::Map<std::string, std::string>& manifest() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_manifest();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_manifest() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_manifest();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string vendor_version = 2;
  void clear_vendor_version() ;
  const std::string& vendor_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vendor_version(Arg_&& arg, Args_... args);
  std::string* mutable_vendor_version();
  PROTOBUF_NODISCARD std::string* release_vendor_version();
  void set_allocated_vendor_version(std::string* value);

  private:
  const std::string& _internal_vendor_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor_version(
      const std::string& value);
  std::string* _internal_mutable_vendor_version();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<GetPluginInfoResponse_ManifestEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        manifest_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr vendor_version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetCapacityResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetCapacityResponse) */ {
 public:
  inline GetCapacityResponse() : GetCapacityResponse(nullptr) {}
  ~GetCapacityResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCapacityResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetCapacityResponse(const GetCapacityResponse& from)
      : GetCapacityResponse(nullptr, from) {}
  GetCapacityResponse(GetCapacityResponse&& from) noexcept
    : GetCapacityResponse() {
    *this = ::std::move(from);
  }

  inline GetCapacityResponse& operator=(const GetCapacityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapacityResponse& operator=(GetCapacityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCapacityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCapacityResponse* internal_default_instance() {
    return reinterpret_cast<const GetCapacityResponse*>(
               &_GetCapacityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(GetCapacityResponse& a, GetCapacityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCapacityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapacityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCapacityResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCapacityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCapacityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetCapacityResponse& from) {
    GetCapacityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetCapacityResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetCapacityResponse";
  }
  protected:
  explicit GetCapacityResponse(::google::protobuf::Arena* arena);
  GetCapacityResponse(::google::protobuf::Arena* arena, const GetCapacityResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumVolumeSizeFieldNumber = 2,
    kMinimumVolumeSizeFieldNumber = 3,
    kAvailableCapacityFieldNumber = 1,
  };
  // .google.protobuf.Int64Value maximum_volume_size = 2;
  bool has_maximum_volume_size() const;
  void clear_maximum_volume_size() ;
  const ::google::protobuf::Int64Value& maximum_volume_size() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_maximum_volume_size();
  ::google::protobuf::Int64Value* mutable_maximum_volume_size();
  void set_allocated_maximum_volume_size(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_maximum_volume_size(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_maximum_volume_size();

  private:
  const ::google::protobuf::Int64Value& _internal_maximum_volume_size() const;
  ::google::protobuf::Int64Value* _internal_mutable_maximum_volume_size();

  public:
  // .google.protobuf.Int64Value minimum_volume_size = 3 [(.csi.v1.alpha_field) = true];
  bool has_minimum_volume_size() const;
  void clear_minimum_volume_size() ;
  const ::google::protobuf::Int64Value& minimum_volume_size() const;
  PROTOBUF_NODISCARD ::google::protobuf::Int64Value* release_minimum_volume_size();
  ::google::protobuf::Int64Value* mutable_minimum_volume_size();
  void set_allocated_minimum_volume_size(::google::protobuf::Int64Value* value);
  void unsafe_arena_set_allocated_minimum_volume_size(::google::protobuf::Int64Value* value);
  ::google::protobuf::Int64Value* unsafe_arena_release_minimum_volume_size();

  private:
  const ::google::protobuf::Int64Value& _internal_minimum_volume_size() const;
  ::google::protobuf::Int64Value* _internal_mutable_minimum_volume_size();

  public:
  // int64 available_capacity = 1;
  void clear_available_capacity() ;
  ::int64_t available_capacity() const;
  void set_available_capacity(::int64_t value);

  private:
  ::int64_t _internal_available_capacity() const;
  void _internal_set_available_capacity(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Int64Value* maximum_volume_size_;
    ::google::protobuf::Int64Value* minimum_volume_size_;
    ::int64_t available_capacity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeRequest) */ {
 public:
  inline DeleteVolumeRequest() : DeleteVolumeRequest(nullptr) {}
  ~DeleteVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteVolumeRequest(const DeleteVolumeRequest& from)
      : DeleteVolumeRequest(nullptr, from) {}
  DeleteVolumeRequest(DeleteVolumeRequest&& from) noexcept
    : DeleteVolumeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeRequest& operator=(const DeleteVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeRequest& operator=(DeleteVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeRequest*>(
               &_DeleteVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteVolumeRequest& a, DeleteVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteVolumeRequest& from) {
    DeleteVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteVolumeRequest";
  }
  protected:
  explicit DeleteVolumeRequest(::google::protobuf::Arena* arena);
  DeleteVolumeRequest(::google::protobuf::Arena* arena, const DeleteVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kVolumeIdFieldNumber = 1,
  };
  // map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<DeleteVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteVolumeGroupSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeGroupSnapshotRequest) */ {
 public:
  inline DeleteVolumeGroupSnapshotRequest() : DeleteVolumeGroupSnapshotRequest(nullptr) {}
  ~DeleteVolumeGroupSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteVolumeGroupSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteVolumeGroupSnapshotRequest(const DeleteVolumeGroupSnapshotRequest& from)
      : DeleteVolumeGroupSnapshotRequest(nullptr, from) {}
  DeleteVolumeGroupSnapshotRequest(DeleteVolumeGroupSnapshotRequest&& from) noexcept
    : DeleteVolumeGroupSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeGroupSnapshotRequest& operator=(const DeleteVolumeGroupSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeGroupSnapshotRequest& operator=(DeleteVolumeGroupSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteVolumeGroupSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteVolumeGroupSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeGroupSnapshotRequest*>(
               &_DeleteVolumeGroupSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(DeleteVolumeGroupSnapshotRequest& a, DeleteVolumeGroupSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteVolumeGroupSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteVolumeGroupSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteVolumeGroupSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteVolumeGroupSnapshotRequest& from) {
    DeleteVolumeGroupSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteVolumeGroupSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteVolumeGroupSnapshotRequest";
  }
  protected:
  explicit DeleteVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena);
  DeleteVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena, const DeleteVolumeGroupSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdsFieldNumber = 2,
    kSecretsFieldNumber = 3,
    kGroupSnapshotIdFieldNumber = 1,
  };
  // repeated string snapshot_ids = 2;
  int snapshot_ids_size() const;
  private:
  int _internal_snapshot_ids_size() const;

  public:
  void clear_snapshot_ids() ;
  const std::string& snapshot_ids(int index) const;
  std::string* mutable_snapshot_ids(int index);
  void set_snapshot_ids(int index, const std::string& value);
  void set_snapshot_ids(int index, std::string&& value);
  void set_snapshot_ids(int index, const char* value);
  void set_snapshot_ids(int index, const char* value, std::size_t size);
  void set_snapshot_ids(int index, absl::string_view value);
  std::string* add_snapshot_ids();
  void add_snapshot_ids(const std::string& value);
  void add_snapshot_ids(std::string&& value);
  void add_snapshot_ids(const char* value);
  void add_snapshot_ids(const char* value, std::size_t size);
  void add_snapshot_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& snapshot_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_snapshot_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_snapshot_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_snapshot_ids();

  public:
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string group_snapshot_id = 1;
  void clear_group_snapshot_id() ;
  const std::string& group_snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_group_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_group_snapshot_id();
  void set_allocated_group_snapshot_id(std::string* value);

  private:
  const std::string& _internal_group_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_group_snapshot_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeGroupSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> snapshot_ids_;
    ::google::protobuf::internal::MapField<DeleteVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr group_snapshot_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class DeleteSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteSnapshotRequest) */ {
 public:
  inline DeleteSnapshotRequest() : DeleteSnapshotRequest(nullptr) {}
  ~DeleteSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteSnapshotRequest(const DeleteSnapshotRequest& from)
      : DeleteSnapshotRequest(nullptr, from) {}
  DeleteSnapshotRequest(DeleteSnapshotRequest&& from) noexcept
    : DeleteSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSnapshotRequest& operator=(const DeleteSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSnapshotRequest& operator=(DeleteSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSnapshotRequest*>(
               &_DeleteSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(DeleteSnapshotRequest& a, DeleteSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteSnapshotRequest& from) {
    DeleteSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.DeleteSnapshotRequest";
  }
  protected:
  explicit DeleteSnapshotRequest(::google::protobuf::Arena* arena);
  DeleteSnapshotRequest(::google::protobuf::Arena* arena, const DeleteSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kSnapshotIdFieldNumber = 1,
  };
  // map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string snapshot_id = 1;
  void clear_snapshot_id() ;
  const std::string& snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* value);

  private:
  const std::string& _internal_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_snapshot_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<DeleteSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr snapshot_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateVolumeGroupSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeGroupSnapshotRequest) */ {
 public:
  inline CreateVolumeGroupSnapshotRequest() : CreateVolumeGroupSnapshotRequest(nullptr) {}
  ~CreateVolumeGroupSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeGroupSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateVolumeGroupSnapshotRequest(const CreateVolumeGroupSnapshotRequest& from)
      : CreateVolumeGroupSnapshotRequest(nullptr, from) {}
  CreateVolumeGroupSnapshotRequest(CreateVolumeGroupSnapshotRequest&& from) noexcept
    : CreateVolumeGroupSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline CreateVolumeGroupSnapshotRequest& operator=(const CreateVolumeGroupSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeGroupSnapshotRequest& operator=(CreateVolumeGroupSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVolumeGroupSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVolumeGroupSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeGroupSnapshotRequest*>(
               &_CreateVolumeGroupSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(CreateVolumeGroupSnapshotRequest& a, CreateVolumeGroupSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeGroupSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVolumeGroupSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVolumeGroupSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateVolumeGroupSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateVolumeGroupSnapshotRequest& from) {
    CreateVolumeGroupSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateVolumeGroupSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateVolumeGroupSnapshotRequest";
  }
  protected:
  explicit CreateVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena);
  CreateVolumeGroupSnapshotRequest(::google::protobuf::Arena* arena, const CreateVolumeGroupSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSourceVolumeIdsFieldNumber = 2,
    kSecretsFieldNumber = 3,
    kParametersFieldNumber = 4,
    kNameFieldNumber = 1,
  };
  // repeated string source_volume_ids = 2;
  int source_volume_ids_size() const;
  private:
  int _internal_source_volume_ids_size() const;

  public:
  void clear_source_volume_ids() ;
  const std::string& source_volume_ids(int index) const;
  std::string* mutable_source_volume_ids(int index);
  void set_source_volume_ids(int index, const std::string& value);
  void set_source_volume_ids(int index, std::string&& value);
  void set_source_volume_ids(int index, const char* value);
  void set_source_volume_ids(int index, const char* value, std::size_t size);
  void set_source_volume_ids(int index, absl::string_view value);
  std::string* add_source_volume_ids();
  void add_source_volume_ids(const std::string& value);
  void add_source_volume_ids(std::string&& value);
  void add_source_volume_ids(const char* value);
  void add_source_volume_ids(const char* value, std::size_t size);
  void add_source_volume_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& source_volume_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_source_volume_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_source_volume_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_source_volume_ids();

  public:
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeGroupSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 2,
      86, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> source_volume_ids_;
    ::google::protobuf::internal::MapField<CreateVolumeGroupSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<CreateVolumeGroupSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateSnapshotRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateSnapshotRequest) */ {
 public:
  inline CreateSnapshotRequest() : CreateSnapshotRequest(nullptr) {}
  ~CreateSnapshotRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSnapshotRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateSnapshotRequest(const CreateSnapshotRequest& from)
      : CreateSnapshotRequest(nullptr, from) {}
  CreateSnapshotRequest(CreateSnapshotRequest&& from) noexcept
    : CreateSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline CreateSnapshotRequest& operator=(const CreateSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSnapshotRequest& operator=(CreateSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotRequest*>(
               &_CreateSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CreateSnapshotRequest& a, CreateSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateSnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateSnapshotRequest& from) {
    CreateSnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateSnapshotRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateSnapshotRequest";
  }
  protected:
  explicit CreateSnapshotRequest(::google::protobuf::Arena* arena);
  CreateSnapshotRequest(::google::protobuf::Arena* arena, const CreateSnapshotRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSourceVolumeIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string source_volume_id = 1;
  void clear_source_volume_id() ;
  const std::string& source_volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_volume_id();
  PROTOBUF_NODISCARD std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* value);

  private:
  const std::string& _internal_source_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_volume_id(
      const std::string& value);
  std::string* _internal_mutable_source_volume_id();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 2,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<CreateSnapshotRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<CreateSnapshotRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr source_volume_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerUnpublishVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerUnpublishVolumeRequest) */ {
 public:
  inline ControllerUnpublishVolumeRequest() : ControllerUnpublishVolumeRequest(nullptr) {}
  ~ControllerUnpublishVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerUnpublishVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerUnpublishVolumeRequest(const ControllerUnpublishVolumeRequest& from)
      : ControllerUnpublishVolumeRequest(nullptr, from) {}
  ControllerUnpublishVolumeRequest(ControllerUnpublishVolumeRequest&& from) noexcept
    : ControllerUnpublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerUnpublishVolumeRequest& operator=(const ControllerUnpublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerUnpublishVolumeRequest& operator=(ControllerUnpublishVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerUnpublishVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerUnpublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerUnpublishVolumeRequest*>(
               &_ControllerUnpublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ControllerUnpublishVolumeRequest& a, ControllerUnpublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerUnpublishVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerUnpublishVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerUnpublishVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerUnpublishVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerUnpublishVolumeRequest& from) {
    ControllerUnpublishVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerUnpublishVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerUnpublishVolumeRequest";
  }
  protected:
  explicit ControllerUnpublishVolumeRequest(::google::protobuf::Arena* arena);
  ControllerUnpublishVolumeRequest(::google::protobuf::Arena* arena, const ControllerUnpublishVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kVolumeIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string node_id = 2;
  void clear_node_id() ;
  const std::string& node_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* value);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 3, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerServiceCapability final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerServiceCapability) */ {
 public:
  inline ControllerServiceCapability() : ControllerServiceCapability(nullptr) {}
  ~ControllerServiceCapability() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerServiceCapability(::google::protobuf::internal::ConstantInitialized);

  inline ControllerServiceCapability(const ControllerServiceCapability& from)
      : ControllerServiceCapability(nullptr, from) {}
  ControllerServiceCapability(ControllerServiceCapability&& from) noexcept
    : ControllerServiceCapability() {
    *this = ::std::move(from);
  }

  inline ControllerServiceCapability& operator=(const ControllerServiceCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerServiceCapability& operator=(ControllerServiceCapability&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerServiceCapability& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kRpc = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const ControllerServiceCapability* internal_default_instance() {
    return reinterpret_cast<const ControllerServiceCapability*>(
               &_ControllerServiceCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(ControllerServiceCapability& a, ControllerServiceCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerServiceCapability* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerServiceCapability* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerServiceCapability* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerServiceCapability>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerServiceCapability& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerServiceCapability& from) {
    ControllerServiceCapability::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerServiceCapability* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerServiceCapability";
  }
  protected:
  explicit ControllerServiceCapability(::google::protobuf::Arena* arena);
  ControllerServiceCapability(::google::protobuf::Arena* arena, const ControllerServiceCapability& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RPC = ControllerServiceCapability_RPC;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcFieldNumber = 1,
  };
  // .csi.v1.ControllerServiceCapability.RPC rpc = 1;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;

  public:
  void clear_rpc() ;
  const ::csi::v1::ControllerServiceCapability_RPC& rpc() const;
  PROTOBUF_NODISCARD ::csi::v1::ControllerServiceCapability_RPC* release_rpc();
  ::csi::v1::ControllerServiceCapability_RPC* mutable_rpc();
  void set_allocated_rpc(::csi::v1::ControllerServiceCapability_RPC* value);
  void unsafe_arena_set_allocated_rpc(::csi::v1::ControllerServiceCapability_RPC* value);
  ::csi::v1::ControllerServiceCapability_RPC* unsafe_arena_release_rpc();

  private:
  const ::csi::v1::ControllerServiceCapability_RPC& _internal_rpc() const;
  ::csi::v1::ControllerServiceCapability_RPC* _internal_mutable_rpc();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability)
 private:
  class _Internal;
  void set_has_rpc();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::csi::v1::ControllerServiceCapability_RPC* rpc_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerPublishVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerPublishVolumeResponse) */ {
 public:
  inline ControllerPublishVolumeResponse() : ControllerPublishVolumeResponse(nullptr) {}
  ~ControllerPublishVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerPublishVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerPublishVolumeResponse(const ControllerPublishVolumeResponse& from)
      : ControllerPublishVolumeResponse(nullptr, from) {}
  ControllerPublishVolumeResponse(ControllerPublishVolumeResponse&& from) noexcept
    : ControllerPublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerPublishVolumeResponse& operator=(const ControllerPublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerPublishVolumeResponse& operator=(ControllerPublishVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerPublishVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerPublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeResponse*>(
               &_ControllerPublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ControllerPublishVolumeResponse& a, ControllerPublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerPublishVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerPublishVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerPublishVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerPublishVolumeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerPublishVolumeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerPublishVolumeResponse& from) {
    ControllerPublishVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerPublishVolumeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerPublishVolumeResponse";
  }
  protected:
  explicit ControllerPublishVolumeResponse(::google::protobuf::Arena* arena);
  ControllerPublishVolumeResponse(::google::protobuf::Arena* arena, const ControllerPublishVolumeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 1,
  };
  // map<string, string> publish_context = 1;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;

  public:
  void clear_publish_context() ;
  const ::google::protobuf::Map<std::string, std::string>& publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_publish_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_publish_context();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        publish_context_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerModifyVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerModifyVolumeRequest) */ {
 public:
  inline ControllerModifyVolumeRequest() : ControllerModifyVolumeRequest(nullptr) {}
  ~ControllerModifyVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerModifyVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerModifyVolumeRequest(const ControllerModifyVolumeRequest& from)
      : ControllerModifyVolumeRequest(nullptr, from) {}
  ControllerModifyVolumeRequest(ControllerModifyVolumeRequest&& from) noexcept
    : ControllerModifyVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerModifyVolumeRequest& operator=(const ControllerModifyVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerModifyVolumeRequest& operator=(ControllerModifyVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerModifyVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerModifyVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerModifyVolumeRequest*>(
               &_ControllerModifyVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ControllerModifyVolumeRequest& a, ControllerModifyVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerModifyVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerModifyVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerModifyVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerModifyVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerModifyVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerModifyVolumeRequest& from) {
    ControllerModifyVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerModifyVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerModifyVolumeRequest";
  }
  protected:
  explicit ControllerModifyVolumeRequest(::google::protobuf::Arena* arena);
  ControllerModifyVolumeRequest(::google::protobuf::Arena* arena, const ControllerModifyVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kMutableParametersFieldNumber = 3,
    kVolumeIdFieldNumber = 1,
  };
  // map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> mutable_parameters = 3;
  int mutable_parameters_size() const;
  private:
  int _internal_mutable_parameters_size() const;

  public:
  void clear_mutable_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_mutable_parameters();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerModifyVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 2,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ControllerModifyVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<ControllerModifyVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        mutable_parameters_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerGetVolumeResponse_VolumeStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeResponse.VolumeStatus) */ {
 public:
  inline ControllerGetVolumeResponse_VolumeStatus() : ControllerGetVolumeResponse_VolumeStatus(nullptr) {}
  ~ControllerGetVolumeResponse_VolumeStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerGetVolumeResponse_VolumeStatus(::google::protobuf::internal::ConstantInitialized);

  inline ControllerGetVolumeResponse_VolumeStatus(const ControllerGetVolumeResponse_VolumeStatus& from)
      : ControllerGetVolumeResponse_VolumeStatus(nullptr, from) {}
  ControllerGetVolumeResponse_VolumeStatus(ControllerGetVolumeResponse_VolumeStatus&& from) noexcept
    : ControllerGetVolumeResponse_VolumeStatus() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeResponse_VolumeStatus& operator=(const ControllerGetVolumeResponse_VolumeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeResponse_VolumeStatus& operator=(ControllerGetVolumeResponse_VolumeStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerGetVolumeResponse_VolumeStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerGetVolumeResponse_VolumeStatus* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeResponse_VolumeStatus*>(
               &_ControllerGetVolumeResponse_VolumeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(ControllerGetVolumeResponse_VolumeStatus& a, ControllerGetVolumeResponse_VolumeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeResponse_VolumeStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeResponse_VolumeStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerGetVolumeResponse_VolumeStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse_VolumeStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerGetVolumeResponse_VolumeStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerGetVolumeResponse_VolumeStatus& from) {
    ControllerGetVolumeResponse_VolumeStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerGetVolumeResponse_VolumeStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerGetVolumeResponse.VolumeStatus";
  }
  protected:
  explicit ControllerGetVolumeResponse_VolumeStatus(::google::protobuf::Arena* arena);
  ControllerGetVolumeResponse_VolumeStatus(::google::protobuf::Arena* arena, const ControllerGetVolumeResponse_VolumeStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishedNodeIdsFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated string published_node_ids = 1;
  int published_node_ids_size() const;
  private:
  int _internal_published_node_ids_size() const;

  public:
  void clear_published_node_ids() ;
  const std::string& published_node_ids(int index) const;
  std::string* mutable_published_node_ids(int index);
  void set_published_node_ids(int index, const std::string& value);
  void set_published_node_ids(int index, std::string&& value);
  void set_published_node_ids(int index, const char* value);
  void set_published_node_ids(int index, const char* value, std::size_t size);
  void set_published_node_ids(int index, absl::string_view value);
  std::string* add_published_node_ids();
  void add_published_node_ids(const std::string& value);
  void add_published_node_ids(std::string&& value);
  void add_published_node_ids(const char* value);
  void add_published_node_ids(const char* value, std::size_t size);
  void add_published_node_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& published_node_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_published_node_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_published_node_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_published_node_ids();

  public:
  // .csi.v1.VolumeCondition volume_condition = 2;
  bool has_volume_condition() const;
  void clear_volume_condition() ;
  const ::csi::v1::VolumeCondition& volume_condition() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  void unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeResponse.VolumeStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> published_node_ids_;
    ::csi::v1::VolumeCondition* volume_condition_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class VolumeGroupSnapshot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeGroupSnapshot) */ {
 public:
  inline VolumeGroupSnapshot() : VolumeGroupSnapshot(nullptr) {}
  ~VolumeGroupSnapshot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VolumeGroupSnapshot(::google::protobuf::internal::ConstantInitialized);

  inline VolumeGroupSnapshot(const VolumeGroupSnapshot& from)
      : VolumeGroupSnapshot(nullptr, from) {}
  VolumeGroupSnapshot(VolumeGroupSnapshot&& from) noexcept
    : VolumeGroupSnapshot() {
    *this = ::std::move(from);
  }

  inline VolumeGroupSnapshot& operator=(const VolumeGroupSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeGroupSnapshot& operator=(VolumeGroupSnapshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VolumeGroupSnapshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const VolumeGroupSnapshot* internal_default_instance() {
    return reinterpret_cast<const VolumeGroupSnapshot*>(
               &_VolumeGroupSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(VolumeGroupSnapshot& a, VolumeGroupSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeGroupSnapshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeGroupSnapshot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VolumeGroupSnapshot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VolumeGroupSnapshot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VolumeGroupSnapshot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VolumeGroupSnapshot& from) {
    VolumeGroupSnapshot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VolumeGroupSnapshot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.VolumeGroupSnapshot";
  }
  protected:
  explicit VolumeGroupSnapshot(::google::protobuf::Arena* arena);
  VolumeGroupSnapshot(::google::protobuf::Arena* arena, const VolumeGroupSnapshot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotsFieldNumber = 2,
    kGroupSnapshotIdFieldNumber = 1,
    kCreationTimeFieldNumber = 3,
    kReadyToUseFieldNumber = 4,
  };
  // repeated .csi.v1.Snapshot snapshots = 2;
  int snapshots_size() const;
  private:
  int _internal_snapshots_size() const;

  public:
  void clear_snapshots() ;
  ::csi::v1::Snapshot* mutable_snapshots(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::Snapshot >*
      mutable_snapshots();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>& _internal_snapshots() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>* _internal_mutable_snapshots();
  public:
  const ::csi::v1::Snapshot& snapshots(int index) const;
  ::csi::v1::Snapshot* add_snapshots();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::Snapshot >&
      snapshots() const;
  // string group_snapshot_id = 1;
  void clear_group_snapshot_id() ;
  const std::string& group_snapshot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_group_snapshot_id(Arg_&& arg, Args_... args);
  std::string* mutable_group_snapshot_id();
  PROTOBUF_NODISCARD std::string* release_group_snapshot_id();
  void set_allocated_group_snapshot_id(std::string* value);

  private:
  const std::string& _internal_group_snapshot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_snapshot_id(
      const std::string& value);
  std::string* _internal_mutable_group_snapshot_id();

  public:
  // .google.protobuf.Timestamp creation_time = 3;
  bool has_creation_time() const;
  void clear_creation_time() ;
  const ::google::protobuf::Timestamp& creation_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_creation_time();
  ::google::protobuf::Timestamp* mutable_creation_time();
  void set_allocated_creation_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_creation_time();

  private:
  const ::google::protobuf::Timestamp& _internal_creation_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_creation_time();

  public:
  // bool ready_to_use = 4;
  void clear_ready_to_use() ;
  bool ready_to_use() const;
  void set_ready_to_use(bool value);

  private:
  bool _internal_ready_to_use() const;
  void _internal_set_ready_to_use(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeGroupSnapshot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::Snapshot > snapshots_;
    ::google::protobuf::internal::ArenaStringPtr group_snapshot_id_;
    ::google::protobuf::Timestamp* creation_time_;
    bool ready_to_use_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class Volume final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.Volume) */ {
 public:
  inline Volume() : Volume(nullptr) {}
  ~Volume() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Volume(::google::protobuf::internal::ConstantInitialized);

  inline Volume(const Volume& from)
      : Volume(nullptr, from) {}
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  inline Volume& operator=(Volume&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Volume& default_instance() {
    return *internal_default_instance();
  }
  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }
  inline void Swap(Volume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Volume* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Volume* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Volume>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Volume& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Volume& from) {
    Volume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Volume* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.Volume";
  }
  protected:
  explicit Volume(::google::protobuf::Arena* arena);
  Volume(::google::protobuf::Arena* arena, const Volume& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 3,
    kAccessibleTopologyFieldNumber = 5,
    kVolumeIdFieldNumber = 2,
    kContentSourceFieldNumber = 4,
    kCapacityBytesFieldNumber = 1,
  };
  // map<string, string> volume_context = 3;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // repeated .csi.v1.Topology accessible_topology = 5;
  int accessible_topology_size() const;
  private:
  int _internal_accessible_topology_size() const;

  public:
  void clear_accessible_topology() ;
  ::csi::v1::Topology* mutable_accessible_topology(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_accessible_topology();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& _internal_accessible_topology() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* _internal_mutable_accessible_topology();
  public:
  const ::csi::v1::Topology& accessible_topology(int index) const;
  ::csi::v1::Topology* add_accessible_topology();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >&
      accessible_topology() const;
  // string volume_id = 2;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // .csi.v1.VolumeContentSource content_source = 4;
  bool has_content_source() const;
  void clear_content_source() ;
  const ::csi::v1::VolumeContentSource& content_source() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeContentSource* release_content_source();
  ::csi::v1::VolumeContentSource* mutable_content_source();
  void set_allocated_content_source(::csi::v1::VolumeContentSource* value);
  void unsafe_arena_set_allocated_content_source(::csi::v1::VolumeContentSource* value);
  ::csi::v1::VolumeContentSource* unsafe_arena_release_content_source();

  private:
  const ::csi::v1::VolumeContentSource& _internal_content_source() const;
  ::csi::v1::VolumeContentSource* _internal_mutable_content_source();

  public:
  // int64 capacity_bytes = 1;
  void clear_capacity_bytes() ;
  ::int64_t capacity_bytes() const;
  void set_capacity_bytes(::int64_t value);

  private:
  ::int64_t _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.Volume)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<Volume_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology > accessible_topology_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::csi::v1::VolumeContentSource* content_source_;
    ::int64_t capacity_bytes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed) */ {
 public:
  inline ValidateVolumeCapabilitiesResponse_Confirmed() : ValidateVolumeCapabilitiesResponse_Confirmed(nullptr) {}
  ~ValidateVolumeCapabilitiesResponse_Confirmed() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesResponse_Confirmed(::google::protobuf::internal::ConstantInitialized);

  inline ValidateVolumeCapabilitiesResponse_Confirmed(const ValidateVolumeCapabilitiesResponse_Confirmed& from)
      : ValidateVolumeCapabilitiesResponse_Confirmed(nullptr, from) {}
  ValidateVolumeCapabilitiesResponse_Confirmed(ValidateVolumeCapabilitiesResponse_Confirmed&& from) noexcept
    : ValidateVolumeCapabilitiesResponse_Confirmed() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesResponse_Confirmed& operator=(const ValidateVolumeCapabilitiesResponse_Confirmed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesResponse_Confirmed& operator=(ValidateVolumeCapabilitiesResponse_Confirmed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateVolumeCapabilitiesResponse_Confirmed& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateVolumeCapabilitiesResponse_Confirmed* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed*>(
               &_ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ValidateVolumeCapabilitiesResponse_Confirmed& a, ValidateVolumeCapabilitiesResponse_Confirmed& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesResponse_Confirmed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesResponse_Confirmed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateVolumeCapabilitiesResponse_Confirmed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse_Confirmed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateVolumeCapabilitiesResponse_Confirmed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValidateVolumeCapabilitiesResponse_Confirmed& from) {
    ValidateVolumeCapabilitiesResponse_Confirmed::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidateVolumeCapabilitiesResponse_Confirmed* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed";
  }
  protected:
  explicit ValidateVolumeCapabilitiesResponse_Confirmed(::google::protobuf::Arena* arena);
  ValidateVolumeCapabilitiesResponse_Confirmed(::google::protobuf::Arena* arena, const ValidateVolumeCapabilitiesResponse_Confirmed& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 1,
    kVolumeCapabilitiesFieldNumber = 2,
    kParametersFieldNumber = 3,
    kMutableParametersFieldNumber = 4,
  };
  // map<string, string> volume_context = 1;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // repeated .csi.v1.VolumeCapability volume_capabilities = 2;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;

  public:
  void clear_volume_capabilities() ;
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& _internal_volume_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* _internal_mutable_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;
  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // map<string, string> mutable_parameters = 4 [(.csi.v1.alpha_field) = true];
  int mutable_parameters_size() const;
  private:
  int _internal_mutable_parameters_size() const;

  public:
  void clear_mutable_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_mutable_parameters();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      102, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesResponse_Confirmed_MutableParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        mutable_parameters_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesRequest) */ {
 public:
  inline ValidateVolumeCapabilitiesRequest() : ValidateVolumeCapabilitiesRequest(nullptr) {}
  ~ValidateVolumeCapabilitiesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ValidateVolumeCapabilitiesRequest(const ValidateVolumeCapabilitiesRequest& from)
      : ValidateVolumeCapabilitiesRequest(nullptr, from) {}
  ValidateVolumeCapabilitiesRequest(ValidateVolumeCapabilitiesRequest&& from) noexcept
    : ValidateVolumeCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesRequest& operator=(const ValidateVolumeCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesRequest& operator=(ValidateVolumeCapabilitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateVolumeCapabilitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateVolumeCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest*>(
               &_ValidateVolumeCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ValidateVolumeCapabilitiesRequest& a, ValidateVolumeCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateVolumeCapabilitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateVolumeCapabilitiesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValidateVolumeCapabilitiesRequest& from) {
    ValidateVolumeCapabilitiesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidateVolumeCapabilitiesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesRequest";
  }
  protected:
  explicit ValidateVolumeCapabilitiesRequest(::google::protobuf::Arena* arena);
  ValidateVolumeCapabilitiesRequest(::google::protobuf::Arena* arena, const ValidateVolumeCapabilitiesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 2,
    kVolumeCapabilitiesFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSecretsFieldNumber = 5,
    kMutableParametersFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
  };
  // map<string, string> volume_context = 2;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // repeated .csi.v1.VolumeCapability volume_capabilities = 3;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;

  public:
  void clear_volume_capabilities() ;
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& _internal_volume_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* _internal_mutable_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;
  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> mutable_parameters = 6 [(.csi.v1.alpha_field) = true];
  int mutable_parameters_size() const;
  private:
  int _internal_mutable_parameters_size() const;

  public:
  void clear_mutable_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_mutable_parameters();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 5,
      107, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<ValidateVolumeCapabilitiesRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        mutable_parameters_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class TopologyRequirement final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.TopologyRequirement) */ {
 public:
  inline TopologyRequirement() : TopologyRequirement(nullptr) {}
  ~TopologyRequirement() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TopologyRequirement(::google::protobuf::internal::ConstantInitialized);

  inline TopologyRequirement(const TopologyRequirement& from)
      : TopologyRequirement(nullptr, from) {}
  TopologyRequirement(TopologyRequirement&& from) noexcept
    : TopologyRequirement() {
    *this = ::std::move(from);
  }

  inline TopologyRequirement& operator=(const TopologyRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopologyRequirement& operator=(TopologyRequirement&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TopologyRequirement& default_instance() {
    return *internal_default_instance();
  }
  static inline const TopologyRequirement* internal_default_instance() {
    return reinterpret_cast<const TopologyRequirement*>(
               &_TopologyRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TopologyRequirement& a, TopologyRequirement& b) {
    a.Swap(&b);
  }
  inline void Swap(TopologyRequirement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopologyRequirement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TopologyRequirement* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TopologyRequirement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TopologyRequirement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TopologyRequirement& from) {
    TopologyRequirement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TopologyRequirement* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.TopologyRequirement";
  }
  protected:
  explicit TopologyRequirement(::google::protobuf::Arena* arena);
  TopologyRequirement(::google::protobuf::Arena* arena, const TopologyRequirement& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequisiteFieldNumber = 1,
    kPreferredFieldNumber = 2,
  };
  // repeated .csi.v1.Topology requisite = 1;
  int requisite_size() const;
  private:
  int _internal_requisite_size() const;

  public:
  void clear_requisite() ;
  ::csi::v1::Topology* mutable_requisite(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_requisite();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& _internal_requisite() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* _internal_mutable_requisite();
  public:
  const ::csi::v1::Topology& requisite(int index) const;
  ::csi::v1::Topology* add_requisite();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >&
      requisite() const;
  // repeated .csi.v1.Topology preferred = 2;
  int preferred_size() const;
  private:
  int _internal_preferred_size() const;

  public:
  void clear_preferred() ;
  ::csi::v1::Topology* mutable_preferred(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_preferred();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& _internal_preferred() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* _internal_mutable_preferred();
  public:
  const ::csi::v1::Topology& preferred(int index) const;
  ::csi::v1::Topology* add_preferred();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology >&
      preferred() const;
  // @@protoc_insertion_point(class_scope:csi.v1.TopologyRequirement)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology > requisite_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::Topology > preferred_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeStageVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeStageVolumeRequest) */ {
 public:
  inline NodeStageVolumeRequest() : NodeStageVolumeRequest(nullptr) {}
  ~NodeStageVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStageVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeStageVolumeRequest(const NodeStageVolumeRequest& from)
      : NodeStageVolumeRequest(nullptr, from) {}
  NodeStageVolumeRequest(NodeStageVolumeRequest&& from) noexcept
    : NodeStageVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeStageVolumeRequest& operator=(const NodeStageVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStageVolumeRequest& operator=(NodeStageVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStageVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStageVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeRequest*>(
               &_NodeStageVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(NodeStageVolumeRequest& a, NodeStageVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStageVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStageVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStageVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeStageVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeStageVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeStageVolumeRequest& from) {
    NodeStageVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeStageVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeStageVolumeRequest";
  }
  protected:
  explicit NodeStageVolumeRequest(::google::protobuf::Arena* arena);
  NodeStageVolumeRequest(::google::protobuf::Arena* arena, const NodeStageVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 2,
    kSecretsFieldNumber = 5,
    kVolumeContextFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 3,
    kVolumeCapabilityFieldNumber = 4,
  };
  // map<string, string> publish_context = 2;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;

  public:
  void clear_publish_context() ;
  const ::google::protobuf::Map<std::string, std::string>& publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_publish_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_publish_context();

  public:
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> volume_context = 6;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string staging_target_path = 3;
  void clear_staging_target_path() ;
  const std::string& staging_target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staging_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_staging_target_path();
  PROTOBUF_NODISCARD std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* value);

  private:
  const std::string& _internal_staging_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_target_path(
      const std::string& value);
  std::string* _internal_mutable_staging_target_path();

  public:
  // .csi.v1.VolumeCapability volume_capability = 4;
  bool has_volume_capability() const;
  void clear_volume_capability() ;
  const ::csi::v1::VolumeCapability& volume_capability() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  void unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 4,
      102, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<NodeStageVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        publish_context_;
    ::google::protobuf::internal::MapField<NodeStageVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<NodeStageVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr staging_target_path_;
    ::csi::v1::VolumeCapability* volume_capability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodePublishVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodePublishVolumeRequest) */ {
 public:
  inline NodePublishVolumeRequest() : NodePublishVolumeRequest(nullptr) {}
  ~NodePublishVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodePublishVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodePublishVolumeRequest(const NodePublishVolumeRequest& from)
      : NodePublishVolumeRequest(nullptr, from) {}
  NodePublishVolumeRequest(NodePublishVolumeRequest&& from) noexcept
    : NodePublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodePublishVolumeRequest& operator=(const NodePublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePublishVolumeRequest& operator=(NodePublishVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodePublishVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodePublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeRequest*>(
               &_NodePublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(NodePublishVolumeRequest& a, NodePublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePublishVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePublishVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodePublishVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodePublishVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodePublishVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodePublishVolumeRequest& from) {
    NodePublishVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodePublishVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodePublishVolumeRequest";
  }
  protected:
  explicit NodePublishVolumeRequest(::google::protobuf::Arena* arena);
  NodePublishVolumeRequest(::google::protobuf::Arena* arena, const NodePublishVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 2,
    kSecretsFieldNumber = 7,
    kVolumeContextFieldNumber = 8,
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 3,
    kTargetPathFieldNumber = 4,
    kVolumeCapabilityFieldNumber = 5,
    kReadonlyFieldNumber = 6,
  };
  // map<string, string> publish_context = 2;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;

  public:
  void clear_publish_context() ;
  const ::google::protobuf::Map<std::string, std::string>& publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_publish_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_publish_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_publish_context();

  public:
  // map<string, string> secrets = 7 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> volume_context = 8;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string staging_target_path = 3;
  void clear_staging_target_path() ;
  const std::string& staging_target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staging_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_staging_target_path();
  PROTOBUF_NODISCARD std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* value);

  private:
  const std::string& _internal_staging_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_target_path(
      const std::string& value);
  std::string* _internal_mutable_staging_target_path();

  public:
  // string target_path = 4;
  void clear_target_path() ;
  const std::string& target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_target_path();
  PROTOBUF_NODISCARD std::string* release_target_path();
  void set_allocated_target_path(std::string* value);

  private:
  const std::string& _internal_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_path(
      const std::string& value);
  std::string* _internal_mutable_target_path();

  public:
  // .csi.v1.VolumeCapability volume_capability = 5;
  bool has_volume_capability() const;
  void clear_volume_capability() ;
  const ::csi::v1::VolumeCapability& volume_capability() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  void unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();

  public:
  // bool readonly = 6;
  void clear_readonly() ;
  bool readonly() const;
  void set_readonly(bool value);

  private:
  bool _internal_readonly() const;
  void _internal_set_readonly(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 4,
      123, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<NodePublishVolumeRequest_PublishContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        publish_context_;
    ::google::protobuf::internal::MapField<NodePublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<NodePublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr staging_target_path_;
    ::google::protobuf::internal::ArenaStringPtr target_path_;
    ::csi::v1::VolumeCapability* volume_capability_;
    bool readonly_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeGetInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetInfoResponse) */ {
 public:
  inline NodeGetInfoResponse() : NodeGetInfoResponse(nullptr) {}
  ~NodeGetInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetInfoResponse(const NodeGetInfoResponse& from)
      : NodeGetInfoResponse(nullptr, from) {}
  NodeGetInfoResponse(NodeGetInfoResponse&& from) noexcept
    : NodeGetInfoResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetInfoResponse& operator=(const NodeGetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetInfoResponse& operator=(NodeGetInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetInfoResponse*>(
               &_NodeGetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(NodeGetInfoResponse& a, NodeGetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeGetInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeGetInfoResponse& from) {
    NodeGetInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeGetInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetInfoResponse";
  }
  protected:
  explicit NodeGetInfoResponse(::google::protobuf::Arena* arena);
  NodeGetInfoResponse(::google::protobuf::Arena* arena, const NodeGetInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kAccessibleTopologyFieldNumber = 3,
    kMaxVolumesPerNodeFieldNumber = 2,
  };
  // string node_id = 1;
  void clear_node_id() ;
  const std::string& node_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* value);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // .csi.v1.Topology accessible_topology = 3;
  bool has_accessible_topology() const;
  void clear_accessible_topology() ;
  const ::csi::v1::Topology& accessible_topology() const;
  PROTOBUF_NODISCARD ::csi::v1::Topology* release_accessible_topology();
  ::csi::v1::Topology* mutable_accessible_topology();
  void set_allocated_accessible_topology(::csi::v1::Topology* value);
  void unsafe_arena_set_allocated_accessible_topology(::csi::v1::Topology* value);
  ::csi::v1::Topology* unsafe_arena_release_accessible_topology();

  private:
  const ::csi::v1::Topology& _internal_accessible_topology() const;
  ::csi::v1::Topology* _internal_mutable_accessible_topology();

  public:
  // int64 max_volumes_per_node = 2;
  void clear_max_volumes_per_node() ;
  ::int64_t max_volumes_per_node() const;
  void set_max_volumes_per_node(::int64_t value);

  private:
  ::int64_t _internal_max_volumes_per_node() const;
  void _internal_set_max_volumes_per_node(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    ::csi::v1::Topology* accessible_topology_;
    ::int64_t max_volumes_per_node_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeGetCapabilitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetCapabilitiesResponse) */ {
 public:
  inline NodeGetCapabilitiesResponse() : NodeGetCapabilitiesResponse(nullptr) {}
  ~NodeGetCapabilitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeGetCapabilitiesResponse(::google::protobuf::internal::ConstantInitialized);

  inline NodeGetCapabilitiesResponse(const NodeGetCapabilitiesResponse& from)
      : NodeGetCapabilitiesResponse(nullptr, from) {}
  NodeGetCapabilitiesResponse(NodeGetCapabilitiesResponse&& from) noexcept
    : NodeGetCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetCapabilitiesResponse& operator=(const NodeGetCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetCapabilitiesResponse& operator=(NodeGetCapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeGetCapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeGetCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetCapabilitiesResponse*>(
               &_NodeGetCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(NodeGetCapabilitiesResponse& a, NodeGetCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetCapabilitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetCapabilitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeGetCapabilitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeGetCapabilitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeGetCapabilitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeGetCapabilitiesResponse& from) {
    NodeGetCapabilitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeGetCapabilitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeGetCapabilitiesResponse";
  }
  protected:
  explicit NodeGetCapabilitiesResponse(::google::protobuf::Arena* arena);
  NodeGetCapabilitiesResponse(::google::protobuf::Arena* arena, const NodeGetCapabilitiesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.NodeServiceCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;

  public:
  void clear_capabilities() ;
  ::csi::v1::NodeServiceCapability* mutable_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::NodeServiceCapability >*
      mutable_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>& _internal_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>* _internal_mutable_capabilities();
  public:
  const ::csi::v1::NodeServiceCapability& capabilities(int index) const;
  ::csi::v1::NodeServiceCapability* add_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::NodeServiceCapability >&
      capabilities() const;
  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::NodeServiceCapability > capabilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class NodeExpandVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeExpandVolumeRequest) */ {
 public:
  inline NodeExpandVolumeRequest() : NodeExpandVolumeRequest(nullptr) {}
  ~NodeExpandVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeExpandVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline NodeExpandVolumeRequest(const NodeExpandVolumeRequest& from)
      : NodeExpandVolumeRequest(nullptr, from) {}
  NodeExpandVolumeRequest(NodeExpandVolumeRequest&& from) noexcept
    : NodeExpandVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeExpandVolumeRequest& operator=(const NodeExpandVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExpandVolumeRequest& operator=(NodeExpandVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeExpandVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeExpandVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExpandVolumeRequest*>(
               &_NodeExpandVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(NodeExpandVolumeRequest& a, NodeExpandVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExpandVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExpandVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeExpandVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeExpandVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeExpandVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeExpandVolumeRequest& from) {
    NodeExpandVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeExpandVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.NodeExpandVolumeRequest";
  }
  protected:
  explicit NodeExpandVolumeRequest(::google::protobuf::Arena* arena);
  NodeExpandVolumeRequest(::google::protobuf::Arena* arena, const NodeExpandVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kVolumePathFieldNumber = 2,
    kStagingTargetPathFieldNumber = 4,
    kCapacityRangeFieldNumber = 3,
    kVolumeCapabilityFieldNumber = 5,
  };
  // map<string, string> secrets = 6 [(.csi.v1.csi_secret) = true, (.csi.v1.alpha_field) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string volume_path = 2;
  void clear_volume_path() ;
  const std::string& volume_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_path(Arg_&& arg, Args_... args);
  std::string* mutable_volume_path();
  PROTOBUF_NODISCARD std::string* release_volume_path();
  void set_allocated_volume_path(std::string* value);

  private:
  const std::string& _internal_volume_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_path(
      const std::string& value);
  std::string* _internal_mutable_volume_path();

  public:
  // string staging_target_path = 4;
  void clear_staging_target_path() ;
  const std::string& staging_target_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_staging_target_path(Arg_&& arg, Args_... args);
  std::string* mutable_staging_target_path();
  PROTOBUF_NODISCARD std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* value);

  private:
  const std::string& _internal_staging_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_staging_target_path(
      const std::string& value);
  std::string* _internal_mutable_staging_target_path();

  public:
  // .csi.v1.CapacityRange capacity_range = 3;
  bool has_capacity_range() const;
  void clear_capacity_range() ;
  const ::csi::v1::CapacityRange& capacity_range() const;
  PROTOBUF_NODISCARD ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  void unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();

  public:
  // .csi.v1.VolumeCapability volume_capability = 5;
  bool has_volume_capability() const;
  void clear_volume_capability() ;
  const ::csi::v1::VolumeCapability& volume_capability() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  void unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      85, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<NodeExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr volume_path_;
    ::google::protobuf::internal::ArenaStringPtr staging_target_path_;
    ::csi::v1::CapacityRange* capacity_range_;
    ::csi::v1::VolumeCapability* volume_capability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListSnapshotsResponse_Entry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsResponse.Entry) */ {
 public:
  inline ListSnapshotsResponse_Entry() : ListSnapshotsResponse_Entry(nullptr) {}
  ~ListSnapshotsResponse_Entry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListSnapshotsResponse_Entry(::google::protobuf::internal::ConstantInitialized);

  inline ListSnapshotsResponse_Entry(const ListSnapshotsResponse_Entry& from)
      : ListSnapshotsResponse_Entry(nullptr, from) {}
  ListSnapshotsResponse_Entry(ListSnapshotsResponse_Entry&& from) noexcept
    : ListSnapshotsResponse_Entry() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsResponse_Entry& operator=(const ListSnapshotsResponse_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsResponse_Entry& operator=(ListSnapshotsResponse_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSnapshotsResponse_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSnapshotsResponse_Entry* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsResponse_Entry*>(
               &_ListSnapshotsResponse_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(ListSnapshotsResponse_Entry& a, ListSnapshotsResponse_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsResponse_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsResponse_Entry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSnapshotsResponse_Entry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSnapshotsResponse_Entry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListSnapshotsResponse_Entry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListSnapshotsResponse_Entry& from) {
    ListSnapshotsResponse_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListSnapshotsResponse_Entry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListSnapshotsResponse.Entry";
  }
  protected:
  explicit ListSnapshotsResponse_Entry(::google::protobuf::Arena* arena);
  ListSnapshotsResponse_Entry(::google::protobuf::Arena* arena, const ListSnapshotsResponse_Entry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
  };
  // .csi.v1.Snapshot snapshot = 1;
  bool has_snapshot() const;
  void clear_snapshot() ;
  const ::csi::v1::Snapshot& snapshot() const;
  PROTOBUF_NODISCARD ::csi::v1::Snapshot* release_snapshot();
  ::csi::v1::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::Snapshot* value);
  void unsafe_arena_set_allocated_snapshot(::csi::v1::Snapshot* value);
  ::csi::v1::Snapshot* unsafe_arena_release_snapshot();

  private:
  const ::csi::v1::Snapshot& _internal_snapshot() const;
  ::csi::v1::Snapshot* _internal_mutable_snapshot();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse.Entry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::Snapshot* snapshot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GroupControllerGetCapabilitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GroupControllerGetCapabilitiesResponse) */ {
 public:
  inline GroupControllerGetCapabilitiesResponse() : GroupControllerGetCapabilitiesResponse(nullptr) {}
  ~GroupControllerGetCapabilitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GroupControllerGetCapabilitiesResponse(::google::protobuf::internal::ConstantInitialized);

  inline GroupControllerGetCapabilitiesResponse(const GroupControllerGetCapabilitiesResponse& from)
      : GroupControllerGetCapabilitiesResponse(nullptr, from) {}
  GroupControllerGetCapabilitiesResponse(GroupControllerGetCapabilitiesResponse&& from) noexcept
    : GroupControllerGetCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline GroupControllerGetCapabilitiesResponse& operator=(const GroupControllerGetCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupControllerGetCapabilitiesResponse& operator=(GroupControllerGetCapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupControllerGetCapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupControllerGetCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const GroupControllerGetCapabilitiesResponse*>(
               &_GroupControllerGetCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(GroupControllerGetCapabilitiesResponse& a, GroupControllerGetCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupControllerGetCapabilitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupControllerGetCapabilitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GroupControllerGetCapabilitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GroupControllerGetCapabilitiesResponse& from) {
    GroupControllerGetCapabilitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GroupControllerGetCapabilitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GroupControllerGetCapabilitiesResponse";
  }
  protected:
  explicit GroupControllerGetCapabilitiesResponse(::google::protobuf::Arena* arena);
  GroupControllerGetCapabilitiesResponse(::google::protobuf::Arena* arena, const GroupControllerGetCapabilitiesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.GroupControllerServiceCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;

  public:
  void clear_capabilities() ;
  ::csi::v1::GroupControllerServiceCapability* mutable_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::GroupControllerServiceCapability >*
      mutable_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>& _internal_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>* _internal_mutable_capabilities();
  public:
  const ::csi::v1::GroupControllerServiceCapability& capabilities(int index) const;
  ::csi::v1::GroupControllerServiceCapability* add_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::GroupControllerServiceCapability >&
      capabilities() const;
  // @@protoc_insertion_point(class_scope:csi.v1.GroupControllerGetCapabilitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::GroupControllerServiceCapability > capabilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetPluginCapabilitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginCapabilitiesResponse) */ {
 public:
  inline GetPluginCapabilitiesResponse() : GetPluginCapabilitiesResponse(nullptr) {}
  ~GetPluginCapabilitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetPluginCapabilitiesResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetPluginCapabilitiesResponse(const GetPluginCapabilitiesResponse& from)
      : GetPluginCapabilitiesResponse(nullptr, from) {}
  GetPluginCapabilitiesResponse(GetPluginCapabilitiesResponse&& from) noexcept
    : GetPluginCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline GetPluginCapabilitiesResponse& operator=(const GetPluginCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginCapabilitiesResponse& operator=(GetPluginCapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPluginCapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPluginCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const GetPluginCapabilitiesResponse*>(
               &_GetPluginCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetPluginCapabilitiesResponse& a, GetPluginCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginCapabilitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginCapabilitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPluginCapabilitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPluginCapabilitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetPluginCapabilitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetPluginCapabilitiesResponse& from) {
    GetPluginCapabilitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetPluginCapabilitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetPluginCapabilitiesResponse";
  }
  protected:
  explicit GetPluginCapabilitiesResponse(::google::protobuf::Arena* arena);
  GetPluginCapabilitiesResponse(::google::protobuf::Arena* arena, const GetPluginCapabilitiesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.PluginCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;

  public:
  void clear_capabilities() ;
  ::csi::v1::PluginCapability* mutable_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::PluginCapability >*
      mutable_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>& _internal_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>* _internal_mutable_capabilities();
  public:
  const ::csi::v1::PluginCapability& capabilities(int index) const;
  ::csi::v1::PluginCapability* add_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::PluginCapability >&
      capabilities() const;
  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::PluginCapability > capabilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetCapacityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetCapacityRequest) */ {
 public:
  inline GetCapacityRequest() : GetCapacityRequest(nullptr) {}
  ~GetCapacityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetCapacityRequest(::google::protobuf::internal::ConstantInitialized);

  inline GetCapacityRequest(const GetCapacityRequest& from)
      : GetCapacityRequest(nullptr, from) {}
  GetCapacityRequest(GetCapacityRequest&& from) noexcept
    : GetCapacityRequest() {
    *this = ::std::move(from);
  }

  inline GetCapacityRequest& operator=(const GetCapacityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapacityRequest& operator=(GetCapacityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCapacityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCapacityRequest* internal_default_instance() {
    return reinterpret_cast<const GetCapacityRequest*>(
               &_GetCapacityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(GetCapacityRequest& a, GetCapacityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCapacityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapacityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCapacityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCapacityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetCapacityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetCapacityRequest& from) {
    GetCapacityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetCapacityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetCapacityRequest";
  }
  protected:
  explicit GetCapacityRequest(::google::protobuf::Arena* arena);
  GetCapacityRequest(::google::protobuf::Arena* arena, const GetCapacityRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeCapabilitiesFieldNumber = 1,
    kParametersFieldNumber = 2,
    kAccessibleTopologyFieldNumber = 3,
  };
  // repeated .csi.v1.VolumeCapability volume_capabilities = 1;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;

  public:
  void clear_volume_capabilities() ;
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& _internal_volume_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* _internal_mutable_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;
  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // .csi.v1.Topology accessible_topology = 3;
  bool has_accessible_topology() const;
  void clear_accessible_topology() ;
  const ::csi::v1::Topology& accessible_topology() const;
  PROTOBUF_NODISCARD ::csi::v1::Topology* release_accessible_topology();
  ::csi::v1::Topology* mutable_accessible_topology();
  void set_allocated_accessible_topology(::csi::v1::Topology* value);
  void unsafe_arena_set_allocated_accessible_topology(::csi::v1::Topology* value);
  ::csi::v1::Topology* unsafe_arena_release_accessible_topology();

  private:
  const ::csi::v1::Topology& _internal_accessible_topology() const;
  ::csi::v1::Topology* _internal_mutable_accessible_topology();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
    ::google::protobuf::internal::MapField<GetCapacityRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::csi::v1::Topology* accessible_topology_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateSnapshotResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateSnapshotResponse) */ {
 public:
  inline CreateSnapshotResponse() : CreateSnapshotResponse(nullptr) {}
  ~CreateSnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateSnapshotResponse(const CreateSnapshotResponse& from)
      : CreateSnapshotResponse(nullptr, from) {}
  CreateSnapshotResponse(CreateSnapshotResponse&& from) noexcept
    : CreateSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline CreateSnapshotResponse& operator=(const CreateSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSnapshotResponse& operator=(CreateSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotResponse*>(
               &_CreateSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CreateSnapshotResponse& a, CreateSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSnapshotResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateSnapshotResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateSnapshotResponse& from) {
    CreateSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateSnapshotResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateSnapshotResponse";
  }
  protected:
  explicit CreateSnapshotResponse(::google::protobuf::Arena* arena);
  CreateSnapshotResponse(::google::protobuf::Arena* arena, const CreateSnapshotResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
  };
  // .csi.v1.Snapshot snapshot = 1;
  bool has_snapshot() const;
  void clear_snapshot() ;
  const ::csi::v1::Snapshot& snapshot() const;
  PROTOBUF_NODISCARD ::csi::v1::Snapshot* release_snapshot();
  ::csi::v1::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::Snapshot* value);
  void unsafe_arena_set_allocated_snapshot(::csi::v1::Snapshot* value);
  ::csi::v1::Snapshot* unsafe_arena_release_snapshot();

  private:
  const ::csi::v1::Snapshot& _internal_snapshot() const;
  ::csi::v1::Snapshot* _internal_mutable_snapshot();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::Snapshot* snapshot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerPublishVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerPublishVolumeRequest) */ {
 public:
  inline ControllerPublishVolumeRequest() : ControllerPublishVolumeRequest(nullptr) {}
  ~ControllerPublishVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerPublishVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerPublishVolumeRequest(const ControllerPublishVolumeRequest& from)
      : ControllerPublishVolumeRequest(nullptr, from) {}
  ControllerPublishVolumeRequest(ControllerPublishVolumeRequest&& from) noexcept
    : ControllerPublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerPublishVolumeRequest& operator=(const ControllerPublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerPublishVolumeRequest& operator=(ControllerPublishVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerPublishVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerPublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeRequest*>(
               &_ControllerPublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ControllerPublishVolumeRequest& a, ControllerPublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerPublishVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerPublishVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerPublishVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerPublishVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerPublishVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerPublishVolumeRequest& from) {
    ControllerPublishVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerPublishVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerPublishVolumeRequest";
  }
  protected:
  explicit ControllerPublishVolumeRequest(::google::protobuf::Arena* arena);
  ControllerPublishVolumeRequest(::google::protobuf::Arena* arena, const ControllerPublishVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 5,
    kVolumeContextFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kVolumeCapabilityFieldNumber = 3,
    kReadonlyFieldNumber = 4,
  };
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> volume_context = 6;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;

  public:
  void clear_volume_context() ;
  const ::google::protobuf::Map<std::string, std::string>& volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_volume_context();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_volume_context() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_volume_context();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // string node_id = 2;
  void clear_node_id() ;
  const std::string& node_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* value);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // .csi.v1.VolumeCapability volume_capability = 3;
  bool has_volume_capability() const;
  void clear_volume_capability() ;
  const ::csi::v1::VolumeCapability& volume_capability() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  void unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();

  public:
  // bool readonly = 4;
  void clear_readonly() ;
  bool readonly() const;
  void set_readonly(bool value);

  private:
  bool _internal_readonly() const;
  void _internal_set_readonly(bool value);

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 6, 3,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<ControllerPublishVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        volume_context_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    ::csi::v1::VolumeCapability* volume_capability_;
    bool readonly_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerGetCapabilitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetCapabilitiesResponse) */ {
 public:
  inline ControllerGetCapabilitiesResponse() : ControllerGetCapabilitiesResponse(nullptr) {}
  ~ControllerGetCapabilitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerGetCapabilitiesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerGetCapabilitiesResponse(const ControllerGetCapabilitiesResponse& from)
      : ControllerGetCapabilitiesResponse(nullptr, from) {}
  ControllerGetCapabilitiesResponse(ControllerGetCapabilitiesResponse&& from) noexcept
    : ControllerGetCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline ControllerGetCapabilitiesResponse& operator=(const ControllerGetCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetCapabilitiesResponse& operator=(ControllerGetCapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerGetCapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerGetCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerGetCapabilitiesResponse*>(
               &_ControllerGetCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(ControllerGetCapabilitiesResponse& a, ControllerGetCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerGetCapabilitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerGetCapabilitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerGetCapabilitiesResponse& from) {
    ControllerGetCapabilitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerGetCapabilitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerGetCapabilitiesResponse";
  }
  protected:
  explicit ControllerGetCapabilitiesResponse(::google::protobuf::Arena* arena);
  ControllerGetCapabilitiesResponse(::google::protobuf::Arena* arena, const ControllerGetCapabilitiesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.ControllerServiceCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;

  public:
  void clear_capabilities() ;
  ::csi::v1::ControllerServiceCapability* mutable_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >*
      mutable_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>& _internal_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>* _internal_mutable_capabilities();
  public:
  const ::csi::v1::ControllerServiceCapability& capabilities(int index) const;
  ::csi::v1::ControllerServiceCapability* add_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >&
      capabilities() const;
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::ControllerServiceCapability > capabilities_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerExpandVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerExpandVolumeRequest) */ {
 public:
  inline ControllerExpandVolumeRequest() : ControllerExpandVolumeRequest(nullptr) {}
  ~ControllerExpandVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerExpandVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ControllerExpandVolumeRequest(const ControllerExpandVolumeRequest& from)
      : ControllerExpandVolumeRequest(nullptr, from) {}
  ControllerExpandVolumeRequest(ControllerExpandVolumeRequest&& from) noexcept
    : ControllerExpandVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerExpandVolumeRequest& operator=(const ControllerExpandVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerExpandVolumeRequest& operator=(ControllerExpandVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerExpandVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerExpandVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerExpandVolumeRequest*>(
               &_ControllerExpandVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(ControllerExpandVolumeRequest& a, ControllerExpandVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerExpandVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerExpandVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerExpandVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerExpandVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerExpandVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerExpandVolumeRequest& from) {
    ControllerExpandVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerExpandVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerExpandVolumeRequest";
  }
  protected:
  explicit ControllerExpandVolumeRequest(::google::protobuf::Arena* arena);
  ControllerExpandVolumeRequest(::google::protobuf::Arena* arena, const ControllerExpandVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kVolumeIdFieldNumber = 1,
    kCapacityRangeFieldNumber = 2,
    kVolumeCapabilityFieldNumber = 4,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // string volume_id = 1;
  void clear_volume_id() ;
  const std::string& volume_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_volume_id(Arg_&& arg, Args_... args);
  std::string* mutable_volume_id();
  PROTOBUF_NODISCARD std::string* release_volume_id();
  void set_allocated_volume_id(std::string* value);

  private:
  const std::string& _internal_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_id(
      const std::string& value);
  std::string* _internal_mutable_volume_id();

  public:
  // .csi.v1.CapacityRange capacity_range = 2;
  bool has_capacity_range() const;
  void clear_capacity_range() ;
  const ::csi::v1::CapacityRange& capacity_range() const;
  PROTOBUF_NODISCARD ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  void unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();

  public:
  // .csi.v1.VolumeCapability volume_capability = 4;
  bool has_volume_capability() const;
  void clear_volume_capability() ;
  const ::csi::v1::VolumeCapability& volume_capability() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  void unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<ControllerExpandVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::ArenaStringPtr volume_id_;
    ::csi::v1::CapacityRange* capacity_range_;
    ::csi::v1::VolumeCapability* volume_capability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesResponse) */ {
 public:
  inline ValidateVolumeCapabilitiesResponse() : ValidateVolumeCapabilitiesResponse(nullptr) {}
  ~ValidateVolumeCapabilitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValidateVolumeCapabilitiesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ValidateVolumeCapabilitiesResponse(const ValidateVolumeCapabilitiesResponse& from)
      : ValidateVolumeCapabilitiesResponse(nullptr, from) {}
  ValidateVolumeCapabilitiesResponse(ValidateVolumeCapabilitiesResponse&& from) noexcept
    : ValidateVolumeCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesResponse& operator=(const ValidateVolumeCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesResponse& operator=(ValidateVolumeCapabilitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateVolumeCapabilitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateVolumeCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse*>(
               &_ValidateVolumeCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ValidateVolumeCapabilitiesResponse& a, ValidateVolumeCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateVolumeCapabilitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValidateVolumeCapabilitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValidateVolumeCapabilitiesResponse& from) {
    ValidateVolumeCapabilitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValidateVolumeCapabilitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesResponse";
  }
  protected:
  explicit ValidateVolumeCapabilitiesResponse(::google::protobuf::Arena* arena);
  ValidateVolumeCapabilitiesResponse(::google::protobuf::Arena* arena, const ValidateVolumeCapabilitiesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Confirmed = ValidateVolumeCapabilitiesResponse_Confirmed;

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kConfirmedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;
  bool has_confirmed() const;
  void clear_confirmed() ;
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& confirmed() const;
  PROTOBUF_NODISCARD ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* release_confirmed();
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* mutable_confirmed();
  void set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* value);
  void unsafe_arena_set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* value);
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* unsafe_arena_release_confirmed();

  private:
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& _internal_confirmed() const;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* _internal_mutable_confirmed();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListVolumesResponse_Entry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse.Entry) */ {
 public:
  inline ListVolumesResponse_Entry() : ListVolumesResponse_Entry(nullptr) {}
  ~ListVolumesResponse_Entry() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListVolumesResponse_Entry(::google::protobuf::internal::ConstantInitialized);

  inline ListVolumesResponse_Entry(const ListVolumesResponse_Entry& from)
      : ListVolumesResponse_Entry(nullptr, from) {}
  ListVolumesResponse_Entry(ListVolumesResponse_Entry&& from) noexcept
    : ListVolumesResponse_Entry() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse_Entry& operator=(const ListVolumesResponse_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse_Entry& operator=(ListVolumesResponse_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVolumesResponse_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVolumesResponse_Entry* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse_Entry*>(
               &_ListVolumesResponse_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ListVolumesResponse_Entry& a, ListVolumesResponse_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse_Entry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVolumesResponse_Entry* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVolumesResponse_Entry>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListVolumesResponse_Entry& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListVolumesResponse_Entry& from) {
    ListVolumesResponse_Entry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListVolumesResponse_Entry* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListVolumesResponse.Entry";
  }
  protected:
  explicit ListVolumesResponse_Entry(::google::protobuf::Arena* arena);
  ListVolumesResponse_Entry(::google::protobuf::Arena* arena, const ListVolumesResponse_Entry& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  void clear_volume() ;
  const ::csi::v1::Volume& volume() const;
  PROTOBUF_NODISCARD ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* value);
  void unsafe_arena_set_allocated_volume(::csi::v1::Volume* value);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();

  public:
  // .csi.v1.ListVolumesResponse.VolumeStatus status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::csi::v1::ListVolumesResponse_VolumeStatus& status() const;
  PROTOBUF_NODISCARD ::csi::v1::ListVolumesResponse_VolumeStatus* release_status();
  ::csi::v1::ListVolumesResponse_VolumeStatus* mutable_status();
  void set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* value);
  void unsafe_arena_set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* value);
  ::csi::v1::ListVolumesResponse_VolumeStatus* unsafe_arena_release_status();

  private:
  const ::csi::v1::ListVolumesResponse_VolumeStatus& _internal_status() const;
  ::csi::v1::ListVolumesResponse_VolumeStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse.Entry)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::Volume* volume_;
    ::csi::v1::ListVolumesResponse_VolumeStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListSnapshotsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsResponse) */ {
 public:
  inline ListSnapshotsResponse() : ListSnapshotsResponse(nullptr) {}
  ~ListSnapshotsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListSnapshotsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListSnapshotsResponse(const ListSnapshotsResponse& from)
      : ListSnapshotsResponse(nullptr, from) {}
  ListSnapshotsResponse(ListSnapshotsResponse&& from) noexcept
    : ListSnapshotsResponse() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsResponse& operator=(const ListSnapshotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsResponse& operator=(ListSnapshotsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSnapshotsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSnapshotsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsResponse*>(
               &_ListSnapshotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(ListSnapshotsResponse& a, ListSnapshotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSnapshotsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSnapshotsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListSnapshotsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListSnapshotsResponse& from) {
    ListSnapshotsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListSnapshotsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListSnapshotsResponse";
  }
  protected:
  explicit ListSnapshotsResponse(::google::protobuf::Arena* arena);
  ListSnapshotsResponse(::google::protobuf::Arena* arena, const ListSnapshotsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Entry = ListSnapshotsResponse_Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::csi::v1::ListSnapshotsResponse_Entry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >*
      mutable_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>* _internal_mutable_entries();
  public:
  const ::csi::v1::ListSnapshotsResponse_Entry& entries(int index) const;
  ::csi::v1::ListSnapshotsResponse_Entry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >&
      entries() const;
  // string next_token = 2;
  void clear_next_token() ;
  const std::string& next_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_token();
  PROTOBUF_NODISCARD std::string* release_next_token();
  void set_allocated_next_token(std::string* value);

  private:
  const std::string& _internal_next_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_token(
      const std::string& value);
  std::string* _internal_mutable_next_token();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry > entries_;
    ::google::protobuf::internal::ArenaStringPtr next_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class GetVolumeGroupSnapshotResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetVolumeGroupSnapshotResponse) */ {
 public:
  inline GetVolumeGroupSnapshotResponse() : GetVolumeGroupSnapshotResponse(nullptr) {}
  ~GetVolumeGroupSnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetVolumeGroupSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline GetVolumeGroupSnapshotResponse(const GetVolumeGroupSnapshotResponse& from)
      : GetVolumeGroupSnapshotResponse(nullptr, from) {}
  GetVolumeGroupSnapshotResponse(GetVolumeGroupSnapshotResponse&& from) noexcept
    : GetVolumeGroupSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline GetVolumeGroupSnapshotResponse& operator=(const GetVolumeGroupSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVolumeGroupSnapshotResponse& operator=(GetVolumeGroupSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVolumeGroupSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVolumeGroupSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const GetVolumeGroupSnapshotResponse*>(
               &_GetVolumeGroupSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(GetVolumeGroupSnapshotResponse& a, GetVolumeGroupSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVolumeGroupSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVolumeGroupSnapshotResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetVolumeGroupSnapshotResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetVolumeGroupSnapshotResponse& from) {
    GetVolumeGroupSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetVolumeGroupSnapshotResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.GetVolumeGroupSnapshotResponse";
  }
  protected:
  explicit GetVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena);
  GetVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena, const GetVolumeGroupSnapshotResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupSnapshotFieldNumber = 1,
  };
  // .csi.v1.VolumeGroupSnapshot group_snapshot = 1;
  bool has_group_snapshot() const;
  void clear_group_snapshot() ;
  const ::csi::v1::VolumeGroupSnapshot& group_snapshot() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeGroupSnapshot* release_group_snapshot();
  ::csi::v1::VolumeGroupSnapshot* mutable_group_snapshot();
  void set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value);
  void unsafe_arena_set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value);
  ::csi::v1::VolumeGroupSnapshot* unsafe_arena_release_group_snapshot();

  private:
  const ::csi::v1::VolumeGroupSnapshot& _internal_group_snapshot() const;
  ::csi::v1::VolumeGroupSnapshot* _internal_mutable_group_snapshot();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.GetVolumeGroupSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::VolumeGroupSnapshot* group_snapshot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeResponse) */ {
 public:
  inline CreateVolumeResponse() : CreateVolumeResponse(nullptr) {}
  ~CreateVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateVolumeResponse(const CreateVolumeResponse& from)
      : CreateVolumeResponse(nullptr, from) {}
  CreateVolumeResponse(CreateVolumeResponse&& from) noexcept
    : CreateVolumeResponse() {
    *this = ::std::move(from);
  }

  inline CreateVolumeResponse& operator=(const CreateVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeResponse& operator=(CreateVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeResponse*>(
               &_CreateVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CreateVolumeResponse& a, CreateVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVolumeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateVolumeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateVolumeResponse& from) {
    CreateVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateVolumeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateVolumeResponse";
  }
  protected:
  explicit CreateVolumeResponse(::google::protobuf::Arena* arena);
  CreateVolumeResponse(::google::protobuf::Arena* arena, const CreateVolumeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  void clear_volume() ;
  const ::csi::v1::Volume& volume() const;
  PROTOBUF_NODISCARD ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* value);
  void unsafe_arena_set_allocated_volume(::csi::v1::Volume* value);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::Volume* volume_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateVolumeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeRequest) */ {
 public:
  inline CreateVolumeRequest() : CreateVolumeRequest(nullptr) {}
  ~CreateVolumeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateVolumeRequest(const CreateVolumeRequest& from)
      : CreateVolumeRequest(nullptr, from) {}
  CreateVolumeRequest(CreateVolumeRequest&& from) noexcept
    : CreateVolumeRequest() {
    *this = ::std::move(from);
  }

  inline CreateVolumeRequest& operator=(const CreateVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeRequest& operator=(CreateVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeRequest*>(
               &_CreateVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CreateVolumeRequest& a, CreateVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVolumeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVolumeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateVolumeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateVolumeRequest& from) {
    CreateVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateVolumeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateVolumeRequest";
  }
  protected:
  explicit CreateVolumeRequest(::google::protobuf::Arena* arena);
  CreateVolumeRequest(::google::protobuf::Arena* arena, const CreateVolumeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeCapabilitiesFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSecretsFieldNumber = 5,
    kMutableParametersFieldNumber = 8,
    kNameFieldNumber = 1,
    kCapacityRangeFieldNumber = 2,
    kVolumeContentSourceFieldNumber = 6,
    kAccessibilityRequirementsFieldNumber = 7,
  };
  // repeated .csi.v1.VolumeCapability volume_capabilities = 3;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;

  public:
  void clear_volume_capabilities() ;
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& _internal_volume_capabilities() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* _internal_mutable_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;
  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;

  public:
  void clear_secrets() ;
  const ::google::protobuf::Map<std::string, std::string>& secrets() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_secrets();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_secrets() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_secrets();

  public:
  // map<string, string> mutable_parameters = 8 [(.csi.v1.alpha_field) = true];
  int mutable_parameters_size() const;
  private:
  int _internal_mutable_parameters_size() const;

  public:
  void clear_mutable_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_mutable_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_mutable_parameters();

  public:
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .csi.v1.CapacityRange capacity_range = 2;
  bool has_capacity_range() const;
  void clear_capacity_range() ;
  const ::csi::v1::CapacityRange& capacity_range() const;
  PROTOBUF_NODISCARD ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  void unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();

  public:
  // .csi.v1.VolumeContentSource volume_content_source = 6;
  bool has_volume_content_source() const;
  void clear_volume_content_source() ;
  const ::csi::v1::VolumeContentSource& volume_content_source() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeContentSource* release_volume_content_source();
  ::csi::v1::VolumeContentSource* mutable_volume_content_source();
  void set_allocated_volume_content_source(::csi::v1::VolumeContentSource* value);
  void unsafe_arena_set_allocated_volume_content_source(::csi::v1::VolumeContentSource* value);
  ::csi::v1::VolumeContentSource* unsafe_arena_release_volume_content_source();

  private:
  const ::csi::v1::VolumeContentSource& _internal_volume_content_source() const;
  ::csi::v1::VolumeContentSource* _internal_mutable_volume_content_source();

  public:
  // .csi.v1.TopologyRequirement accessibility_requirements = 7;
  bool has_accessibility_requirements() const;
  void clear_accessibility_requirements() ;
  const ::csi::v1::TopologyRequirement& accessibility_requirements() const;
  PROTOBUF_NODISCARD ::csi::v1::TopologyRequirement* release_accessibility_requirements();
  ::csi::v1::TopologyRequirement* mutable_accessibility_requirements();
  void set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* value);
  void unsafe_arena_set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* value);
  ::csi::v1::TopologyRequirement* unsafe_arena_release_accessibility_requirements();

  private:
  const ::csi::v1::TopologyRequirement& _internal_accessibility_requirements() const;
  ::csi::v1::TopologyRequirement* _internal_mutable_accessibility_requirements();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 7,
      82, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
    ::google::protobuf::internal::MapField<CreateVolumeRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::MapField<CreateVolumeRequest_SecretsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        secrets_;
    ::google::protobuf::internal::MapField<CreateVolumeRequest_MutableParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        mutable_parameters_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::csi::v1::CapacityRange* capacity_range_;
    ::csi::v1::VolumeContentSource* volume_content_source_;
    ::csi::v1::TopologyRequirement* accessibility_requirements_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class CreateVolumeGroupSnapshotResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeGroupSnapshotResponse) */ {
 public:
  inline CreateVolumeGroupSnapshotResponse() : CreateVolumeGroupSnapshotResponse(nullptr) {}
  ~CreateVolumeGroupSnapshotResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateVolumeGroupSnapshotResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateVolumeGroupSnapshotResponse(const CreateVolumeGroupSnapshotResponse& from)
      : CreateVolumeGroupSnapshotResponse(nullptr, from) {}
  CreateVolumeGroupSnapshotResponse(CreateVolumeGroupSnapshotResponse&& from) noexcept
    : CreateVolumeGroupSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline CreateVolumeGroupSnapshotResponse& operator=(const CreateVolumeGroupSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeGroupSnapshotResponse& operator=(CreateVolumeGroupSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateVolumeGroupSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateVolumeGroupSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeGroupSnapshotResponse*>(
               &_CreateVolumeGroupSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(CreateVolumeGroupSnapshotResponse& a, CreateVolumeGroupSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeGroupSnapshotResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateVolumeGroupSnapshotResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateVolumeGroupSnapshotResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateVolumeGroupSnapshotResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateVolumeGroupSnapshotResponse& from) {
    CreateVolumeGroupSnapshotResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateVolumeGroupSnapshotResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.CreateVolumeGroupSnapshotResponse";
  }
  protected:
  explicit CreateVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena);
  CreateVolumeGroupSnapshotResponse(::google::protobuf::Arena* arena, const CreateVolumeGroupSnapshotResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupSnapshotFieldNumber = 1,
  };
  // .csi.v1.VolumeGroupSnapshot group_snapshot = 1;
  bool has_group_snapshot() const;
  void clear_group_snapshot() ;
  const ::csi::v1::VolumeGroupSnapshot& group_snapshot() const;
  PROTOBUF_NODISCARD ::csi::v1::VolumeGroupSnapshot* release_group_snapshot();
  ::csi::v1::VolumeGroupSnapshot* mutable_group_snapshot();
  void set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value);
  void unsafe_arena_set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value);
  ::csi::v1::VolumeGroupSnapshot* unsafe_arena_release_group_snapshot();

  private:
  const ::csi::v1::VolumeGroupSnapshot& _internal_group_snapshot() const;
  ::csi::v1::VolumeGroupSnapshot* _internal_mutable_group_snapshot();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeGroupSnapshotResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::VolumeGroupSnapshot* group_snapshot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ControllerGetVolumeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeResponse) */ {
 public:
  inline ControllerGetVolumeResponse() : ControllerGetVolumeResponse(nullptr) {}
  ~ControllerGetVolumeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ControllerGetVolumeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ControllerGetVolumeResponse(const ControllerGetVolumeResponse& from)
      : ControllerGetVolumeResponse(nullptr, from) {}
  ControllerGetVolumeResponse(ControllerGetVolumeResponse&& from) noexcept
    : ControllerGetVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeResponse& operator=(const ControllerGetVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeResponse& operator=(ControllerGetVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControllerGetVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControllerGetVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeResponse*>(
               &_ControllerGetVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(ControllerGetVolumeResponse& a, ControllerGetVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControllerGetVolumeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ControllerGetVolumeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ControllerGetVolumeResponse& from) {
    ControllerGetVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ControllerGetVolumeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ControllerGetVolumeResponse";
  }
  protected:
  explicit ControllerGetVolumeResponse(::google::protobuf::Arena* arena);
  ControllerGetVolumeResponse(::google::protobuf::Arena* arena, const ControllerGetVolumeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VolumeStatus = ControllerGetVolumeResponse_VolumeStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  void clear_volume() ;
  const ::csi::v1::Volume& volume() const;
  PROTOBUF_NODISCARD ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* value);
  void unsafe_arena_set_allocated_volume(::csi::v1::Volume* value);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();

  public:
  // .csi.v1.ControllerGetVolumeResponse.VolumeStatus status = 2;
  bool has_status() const;
  void clear_status() ;
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& status() const;
  PROTOBUF_NODISCARD ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* release_status();
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* mutable_status();
  void set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* value);
  void unsafe_arena_set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* value);
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* unsafe_arena_release_status();

  private:
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& _internal_status() const;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::csi::v1::Volume* volume_;
    ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};// -------------------------------------------------------------------

class ListVolumesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse) */ {
 public:
  inline ListVolumesResponse() : ListVolumesResponse(nullptr) {}
  ~ListVolumesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListVolumesResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListVolumesResponse(const ListVolumesResponse& from)
      : ListVolumesResponse(nullptr, from) {}
  ListVolumesResponse(ListVolumesResponse&& from) noexcept
    : ListVolumesResponse() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse& operator=(const ListVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse& operator=(ListVolumesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListVolumesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse*>(
               &_ListVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ListVolumesResponse& a, ListVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListVolumesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListVolumesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListVolumesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListVolumesResponse& from) {
    ListVolumesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListVolumesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "csi.v1.ListVolumesResponse";
  }
  protected:
  explicit ListVolumesResponse(::google::protobuf::Arena* arena);
  ListVolumesResponse(::google::protobuf::Arena* arena, const ListVolumesResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using VolumeStatus = ListVolumesResponse_VolumeStatus;
  using Entry = ListVolumesResponse_Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .csi.v1.ListVolumesResponse.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;

  public:
  void clear_entries() ;
  ::csi::v1::ListVolumesResponse_Entry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >*
      mutable_entries();
  private:
  const ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>& _internal_entries() const;
  ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>* _internal_mutable_entries();
  public:
  const ::csi::v1::ListVolumesResponse_Entry& entries(int index) const;
  ::csi::v1::ListVolumesResponse_Entry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >&
      entries() const;
  // string next_token = 2;
  void clear_next_token() ;
  const std::string& next_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_token();
  PROTOBUF_NODISCARD std::string* release_next_token();
  void set_allocated_next_token(std::string* value);

  private:
  const std::string& _internal_next_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_token(
      const std::string& value);
  std::string* _internal_mutable_next_token();

  public:
  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry > entries_;
    ::google::protobuf::internal::ArenaStringPtr next_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto;
};

// ===================================================================



static const int kAlphaEnumFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_enum;
static const int kAlphaEnumValueFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_enum_value;
static const int kCsiSecretFieldNumber = 1059;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  csi_secret;
static const int kAlphaFieldFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_field;
static const int kAlphaMessageFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_message;
static const int kAlphaMethodFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MethodOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_method;
static const int kAlphaServiceFieldNumber = 1060;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::ServiceOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_service;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GetPluginInfoRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetPluginInfoResponse

// string name = 1;
inline void GetPluginInfoResponse::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetPluginInfoResponse::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginInfoResponse.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPluginInfoResponse::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.GetPluginInfoResponse.name)
}
inline std::string* GetPluginInfoResponse::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginInfoResponse.name)
  return _s;
}
inline const std::string& GetPluginInfoResponse::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GetPluginInfoResponse::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GetPluginInfoResponse::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GetPluginInfoResponse::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetPluginInfoResponse.name)
  return _impl_.name_.Release();
}
inline void GetPluginInfoResponse::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetPluginInfoResponse.name)
}

// string vendor_version = 2;
inline void GetPluginInfoResponse::clear_vendor_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vendor_version_.ClearToEmpty();
}
inline const std::string& GetPluginInfoResponse::vendor_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginInfoResponse.vendor_version)
  return _internal_vendor_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetPluginInfoResponse::set_vendor_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vendor_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline std::string* GetPluginInfoResponse::mutable_vendor_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_vendor_version();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginInfoResponse.vendor_version)
  return _s;
}
inline const std::string& GetPluginInfoResponse::_internal_vendor_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vendor_version_.Get();
}
inline void GetPluginInfoResponse::_internal_set_vendor_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.vendor_version_.Set(value, GetArena());
}
inline std::string* GetPluginInfoResponse::_internal_mutable_vendor_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.vendor_version_.Mutable( GetArena());
}
inline std::string* GetPluginInfoResponse::release_vendor_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetPluginInfoResponse.vendor_version)
  return _impl_.vendor_version_.Release();
}
inline void GetPluginInfoResponse::set_allocated_vendor_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vendor_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vendor_version_.IsDefault()) {
          _impl_.vendor_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetPluginInfoResponse.vendor_version)
}

// map<string, string> manifest = 3;
inline int GetPluginInfoResponse::_internal_manifest_size() const {
  return _internal_manifest().size();
}
inline int GetPluginInfoResponse::manifest_size() const {
  return _internal_manifest_size();
}
inline void GetPluginInfoResponse::clear_manifest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.manifest_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetPluginInfoResponse::_internal_manifest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.manifest_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetPluginInfoResponse::manifest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.GetPluginInfoResponse.manifest)
  return _internal_manifest();
}
inline ::google::protobuf::Map<std::string, std::string>* GetPluginInfoResponse::_internal_mutable_manifest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.manifest_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GetPluginInfoResponse::mutable_manifest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.GetPluginInfoResponse.manifest)
  return _internal_mutable_manifest();
}

// -------------------------------------------------------------------

// GetPluginCapabilitiesRequest

// -------------------------------------------------------------------

// GetPluginCapabilitiesResponse

// repeated .csi.v1.PluginCapability capabilities = 1;
inline int GetPluginCapabilitiesResponse::_internal_capabilities_size() const {
  return _internal_capabilities().size();
}
inline int GetPluginCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void GetPluginCapabilitiesResponse::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_.Clear();
}
inline ::csi::v1::PluginCapability* GetPluginCapabilitiesResponse::mutable_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _internal_mutable_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>* GetPluginCapabilitiesResponse::mutable_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capabilities();
}
inline const ::csi::v1::PluginCapability& GetPluginCapabilitiesResponse::capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _internal_capabilities().Get(index);
}
inline ::csi::v1::PluginCapability* GetPluginCapabilitiesResponse::add_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::PluginCapability* _add = _internal_mutable_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>& GetPluginCapabilitiesResponse::capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _internal_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>&
GetPluginCapabilitiesResponse::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::PluginCapability>*
GetPluginCapabilitiesResponse::_internal_mutable_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// PluginCapability_Service

// .csi.v1.PluginCapability.Service.Type type = 1;
inline void PluginCapability_Service::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::csi::v1::PluginCapability_Service_Type PluginCapability_Service::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.Service.type)
  return _internal_type();
}
inline void PluginCapability_Service::set_type(::csi::v1::PluginCapability_Service_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.PluginCapability.Service.type)
}
inline ::csi::v1::PluginCapability_Service_Type PluginCapability_Service::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::PluginCapability_Service_Type>(_impl_.type_);
}
inline void PluginCapability_Service::_internal_set_type(::csi::v1::PluginCapability_Service_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// PluginCapability_VolumeExpansion

// .csi.v1.PluginCapability.VolumeExpansion.Type type = 1;
inline void PluginCapability_VolumeExpansion::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::csi::v1::PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.VolumeExpansion.type)
  return _internal_type();
}
inline void PluginCapability_VolumeExpansion::set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.PluginCapability.VolumeExpansion.type)
}
inline ::csi::v1::PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::PluginCapability_VolumeExpansion_Type>(_impl_.type_);
}
inline void PluginCapability_VolumeExpansion::_internal_set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// PluginCapability

// .csi.v1.PluginCapability.Service service = 1;
inline bool PluginCapability::has_service() const {
  return type_case() == kService;
}
inline bool PluginCapability::_internal_has_service() const {
  return type_case() == kService;
}
inline void PluginCapability::set_has_service() {
  _impl_._oneof_case_[0] = kService;
}
inline void PluginCapability::clear_service() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kService) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.service_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::release_service() {
  // @@protoc_insertion_point(field_release:csi.v1.PluginCapability.service)
  if (type_case() == kService) {
    clear_has_type();
    auto* temp = _impl_.type_.service_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::PluginCapability_Service& PluginCapability::_internal_service() const {
  return type_case() == kService ? *_impl_.type_.service_ : reinterpret_cast<::csi::v1::PluginCapability_Service&>(::csi::v1::_PluginCapability_Service_default_instance_);
}
inline const ::csi::v1::PluginCapability_Service& PluginCapability::service() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.service)
  return _internal_service();
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.PluginCapability.service)
  if (type_case() == kService) {
    clear_has_type();
    auto* temp = _impl_.type_.service_;
    _impl_.type_.service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginCapability::unsafe_arena_set_allocated_service(::csi::v1::PluginCapability_Service* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_service();
    _impl_.type_.service_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.PluginCapability.service)
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::_internal_mutable_service() {
  if (type_case() != kService) {
    clear_type();
    set_has_service();
    _impl_.type_.service_ = CreateMaybeMessage<::csi::v1::PluginCapability_Service>(GetArena());
  }
  return _impl_.type_.service_;
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::mutable_service() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::PluginCapability_Service* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:csi.v1.PluginCapability.service)
  return _msg;
}

// .csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;
inline bool PluginCapability::has_volume_expansion() const {
  return type_case() == kVolumeExpansion;
}
inline bool PluginCapability::_internal_has_volume_expansion() const {
  return type_case() == kVolumeExpansion;
}
inline void PluginCapability::set_has_volume_expansion() {
  _impl_._oneof_case_[0] = kVolumeExpansion;
}
inline void PluginCapability::clear_volume_expansion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kVolumeExpansion) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.volume_expansion_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::release_volume_expansion() {
  // @@protoc_insertion_point(field_release:csi.v1.PluginCapability.volume_expansion)
  if (type_case() == kVolumeExpansion) {
    clear_has_type();
    auto* temp = _impl_.type_.volume_expansion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.volume_expansion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::PluginCapability_VolumeExpansion& PluginCapability::_internal_volume_expansion() const {
  return type_case() == kVolumeExpansion ? *_impl_.type_.volume_expansion_ : reinterpret_cast<::csi::v1::PluginCapability_VolumeExpansion&>(::csi::v1::_PluginCapability_VolumeExpansion_default_instance_);
}
inline const ::csi::v1::PluginCapability_VolumeExpansion& PluginCapability::volume_expansion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.volume_expansion)
  return _internal_volume_expansion();
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::unsafe_arena_release_volume_expansion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.PluginCapability.volume_expansion)
  if (type_case() == kVolumeExpansion) {
    clear_has_type();
    auto* temp = _impl_.type_.volume_expansion_;
    _impl_.type_.volume_expansion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginCapability::unsafe_arena_set_allocated_volume_expansion(::csi::v1::PluginCapability_VolumeExpansion* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_volume_expansion();
    _impl_.type_.volume_expansion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.PluginCapability.volume_expansion)
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::_internal_mutable_volume_expansion() {
  if (type_case() != kVolumeExpansion) {
    clear_type();
    set_has_volume_expansion();
    _impl_.type_.volume_expansion_ = CreateMaybeMessage<::csi::v1::PluginCapability_VolumeExpansion>(GetArena());
  }
  return _impl_.type_.volume_expansion_;
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::mutable_volume_expansion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::PluginCapability_VolumeExpansion* _msg = _internal_mutable_volume_expansion();
  // @@protoc_insertion_point(field_mutable:csi.v1.PluginCapability.volume_expansion)
  return _msg;
}

inline bool PluginCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void PluginCapability::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline PluginCapability::TypeCase PluginCapability::type_case() const {
  return PluginCapability::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProbeRequest

// -------------------------------------------------------------------

// ProbeResponse

// .google.protobuf.BoolValue ready = 1;
inline bool ProbeResponse::has_ready() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ready_ != nullptr);
  return value;
}
inline const ::google::protobuf::BoolValue& ProbeResponse::_internal_ready() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::BoolValue* p = _impl_.ready_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::BoolValue&>(::google::protobuf::_BoolValue_default_instance_);
}
inline const ::google::protobuf::BoolValue& ProbeResponse::ready() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ProbeResponse.ready)
  return _internal_ready();
}
inline void ProbeResponse::unsafe_arena_set_allocated_ready(::google::protobuf::BoolValue* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ready_);
  }
  _impl_.ready_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ProbeResponse.ready)
}
inline ::google::protobuf::BoolValue* ProbeResponse::release_ready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* released = _impl_.ready_;
  _impl_.ready_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::BoolValue* ProbeResponse::unsafe_arena_release_ready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ProbeResponse.ready)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::BoolValue* temp = _impl_.ready_;
  _impl_.ready_ = nullptr;
  return temp;
}
inline ::google::protobuf::BoolValue* ProbeResponse::_internal_mutable_ready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ready_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::BoolValue>(GetArena());
    _impl_.ready_ = reinterpret_cast<::google::protobuf::BoolValue*>(p);
  }
  return _impl_.ready_;
}
inline ::google::protobuf::BoolValue* ProbeResponse::mutable_ready() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::BoolValue* _msg = _internal_mutable_ready();
  // @@protoc_insertion_point(field_mutable:csi.v1.ProbeResponse.ready)
  return _msg;
}
inline void ProbeResponse::set_allocated_ready(::google::protobuf::BoolValue* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ready_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ready_ = reinterpret_cast<::google::protobuf::BoolValue*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ProbeResponse.ready)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateVolumeRequest

// string name = 1;
inline void CreateVolumeRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateVolumeRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateVolumeRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.CreateVolumeRequest.name)
}
inline std::string* CreateVolumeRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.name)
  return _s;
}
inline const std::string& CreateVolumeRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateVolumeRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreateVolumeRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreateVolumeRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.name)
  return _impl_.name_.Release();
}
inline void CreateVolumeRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.name)
}

// .csi.v1.CapacityRange capacity_range = 2;
inline bool CreateVolumeRequest::has_capacity_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capacity_range_ != nullptr);
  return value;
}
inline void CreateVolumeRequest::clear_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.capacity_range_ != nullptr) _impl_.capacity_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::CapacityRange& CreateVolumeRequest::_internal_capacity_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::CapacityRange* p = _impl_.capacity_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::CapacityRange&>(::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& CreateVolumeRequest::capacity_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacity_range_);
  }
  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* released = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::unsafe_arena_release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.capacity_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* temp = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::_internal_mutable_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(p);
  }
  return _impl_.capacity_range_;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::mutable_capacity_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::CapacityRange* _msg = _internal_mutable_capacity_range();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.capacity_range)
  return _msg;
}
inline void CreateVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::CapacityRange*>(_impl_.capacity_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::CapacityRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.capacity_range)
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 3;
inline int CreateVolumeRequest::_internal_volume_capabilities_size() const {
  return _internal_volume_capabilities().size();
}
inline int CreateVolumeRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void CreateVolumeRequest::clear_volume_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* CreateVolumeRequest::mutable_volume_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _internal_mutable_volume_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* CreateVolumeRequest::mutable_volume_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.CreateVolumeRequest.volume_capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_volume_capabilities();
}
inline const ::csi::v1::VolumeCapability& CreateVolumeRequest::volume_capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _internal_volume_capabilities().Get(index);
}
inline ::csi::v1::VolumeCapability* CreateVolumeRequest::add_volume_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::VolumeCapability* _add = _internal_mutable_volume_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& CreateVolumeRequest::volume_capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _internal_volume_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>&
CreateVolumeRequest::_internal_volume_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>*
CreateVolumeRequest::_internal_mutable_volume_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.volume_capabilities_;
}

// map<string, string> parameters = 4;
inline int CreateVolumeRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int CreateVolumeRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void CreateVolumeRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeRequest.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int CreateVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int CreateVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void CreateVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// .csi.v1.VolumeContentSource volume_content_source = 6;
inline bool CreateVolumeRequest::has_volume_content_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_content_source_ != nullptr);
  return value;
}
inline void CreateVolumeRequest::clear_volume_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_content_source_ != nullptr) _impl_.volume_content_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::csi::v1::VolumeContentSource& CreateVolumeRequest::_internal_volume_content_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeContentSource* p = _impl_.volume_content_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeContentSource&>(::csi::v1::_VolumeContentSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource& CreateVolumeRequest::volume_content_source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.volume_content_source)
  return _internal_volume_content_source();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_volume_content_source(::csi::v1::VolumeContentSource* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_content_source_);
  }
  _impl_.volume_content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.volume_content_source)
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::release_volume_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeContentSource* released = _impl_.volume_content_source_;
  _impl_.volume_content_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::unsafe_arena_release_volume_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.volume_content_source)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeContentSource* temp = _impl_.volume_content_source_;
  _impl_.volume_content_source_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::_internal_mutable_volume_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.volume_content_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeContentSource>(GetArena());
    _impl_.volume_content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(p);
  }
  return _impl_.volume_content_source_;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::mutable_volume_content_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeContentSource* _msg = _internal_mutable_volume_content_source();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.volume_content_source)
  return _msg;
}
inline void CreateVolumeRequest::set_allocated_volume_content_source(::csi::v1::VolumeContentSource* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeContentSource*>(_impl_.volume_content_source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeContentSource*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.volume_content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.volume_content_source)
}

// .csi.v1.TopologyRequirement accessibility_requirements = 7;
inline bool CreateVolumeRequest::has_accessibility_requirements() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accessibility_requirements_ != nullptr);
  return value;
}
inline void CreateVolumeRequest::clear_accessibility_requirements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accessibility_requirements_ != nullptr) _impl_.accessibility_requirements_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::csi::v1::TopologyRequirement& CreateVolumeRequest::_internal_accessibility_requirements() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::TopologyRequirement* p = _impl_.accessibility_requirements_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::TopologyRequirement&>(::csi::v1::_TopologyRequirement_default_instance_);
}
inline const ::csi::v1::TopologyRequirement& CreateVolumeRequest::accessibility_requirements() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.accessibility_requirements)
  return _internal_accessibility_requirements();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accessibility_requirements_);
  }
  _impl_.accessibility_requirements_ = reinterpret_cast<::csi::v1::TopologyRequirement*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.accessibility_requirements)
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::release_accessibility_requirements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::csi::v1::TopologyRequirement* released = _impl_.accessibility_requirements_;
  _impl_.accessibility_requirements_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::unsafe_arena_release_accessibility_requirements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.accessibility_requirements)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::csi::v1::TopologyRequirement* temp = _impl_.accessibility_requirements_;
  _impl_.accessibility_requirements_ = nullptr;
  return temp;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::_internal_mutable_accessibility_requirements() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.accessibility_requirements_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::TopologyRequirement>(GetArena());
    _impl_.accessibility_requirements_ = reinterpret_cast<::csi::v1::TopologyRequirement*>(p);
  }
  return _impl_.accessibility_requirements_;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::mutable_accessibility_requirements() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::TopologyRequirement* _msg = _internal_mutable_accessibility_requirements();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.accessibility_requirements)
  return _msg;
}
inline void CreateVolumeRequest::set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::TopologyRequirement*>(_impl_.accessibility_requirements_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::TopologyRequirement*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.accessibility_requirements_ = reinterpret_cast<::csi::v1::TopologyRequirement*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.accessibility_requirements)
}

// map<string, string> mutable_parameters = 8 [(.csi.v1.alpha_field) = true];
inline int CreateVolumeRequest::_internal_mutable_parameters_size() const {
  return _internal_mutable_parameters().size();
}
inline int CreateVolumeRequest::mutable_parameters_size() const {
  return _internal_mutable_parameters_size();
}
inline void CreateVolumeRequest::clear_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mutable_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::_internal_mutable_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeRequest::mutable_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeRequest.mutable_parameters)
  return _internal_mutable_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::_internal_mutable_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeRequest::mutable_mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeRequest.mutable_parameters)
  return _internal_mutable_mutable_parameters();
}

// -------------------------------------------------------------------

// VolumeContentSource_SnapshotSource

// string snapshot_id = 1;
inline void VolumeContentSource_SnapshotSource::clear_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.ClearToEmpty();
}
inline const std::string& VolumeContentSource_SnapshotSource::snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return _internal_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeContentSource_SnapshotSource::set_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline std::string* VolumeContentSource_SnapshotSource::mutable_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return _s;
}
inline const std::string& VolumeContentSource_SnapshotSource::_internal_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_id_.Get();
}
inline void VolumeContentSource_SnapshotSource::_internal_set_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(value, GetArena());
}
inline std::string* VolumeContentSource_SnapshotSource::_internal_mutable_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.snapshot_id_.Mutable( GetArena());
}
inline std::string* VolumeContentSource_SnapshotSource::release_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return _impl_.snapshot_id_.Release();
}
inline void VolumeContentSource_SnapshotSource::set_allocated_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.snapshot_id_.IsDefault()) {
          _impl_.snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}

// -------------------------------------------------------------------

// VolumeContentSource_VolumeSource

// string volume_id = 1;
inline void VolumeContentSource_VolumeSource::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& VolumeContentSource_VolumeSource::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeContentSource_VolumeSource::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline std::string* VolumeContentSource_VolumeSource::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return _s;
}
inline const std::string& VolumeContentSource_VolumeSource::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void VolumeContentSource_VolumeSource::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* VolumeContentSource_VolumeSource::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* VolumeContentSource_VolumeSource::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return _impl_.volume_id_.Release();
}
inline void VolumeContentSource_VolumeSource::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}

// -------------------------------------------------------------------

// VolumeContentSource

// .csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;
inline bool VolumeContentSource::has_snapshot() const {
  return type_case() == kSnapshot;
}
inline bool VolumeContentSource::_internal_has_snapshot() const {
  return type_case() == kSnapshot;
}
inline void VolumeContentSource::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void VolumeContentSource::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kSnapshot) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.snapshot_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::release_snapshot() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.snapshot)
  if (type_case() == kSnapshot) {
    clear_has_type();
    auto* temp = _impl_.type_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeContentSource_SnapshotSource& VolumeContentSource::_internal_snapshot() const {
  return type_case() == kSnapshot ? *_impl_.type_.snapshot_ : reinterpret_cast<::csi::v1::VolumeContentSource_SnapshotSource&>(::csi::v1::_VolumeContentSource_SnapshotSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource_SnapshotSource& VolumeContentSource::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.snapshot)
  return _internal_snapshot();
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.snapshot)
  if (type_case() == kSnapshot) {
    clear_has_type();
    auto* temp = _impl_.type_.snapshot_;
    _impl_.type_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeContentSource::unsafe_arena_set_allocated_snapshot(::csi::v1::VolumeContentSource_SnapshotSource* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_snapshot();
    _impl_.type_.snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.snapshot)
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::_internal_mutable_snapshot() {
  if (type_case() != kSnapshot) {
    clear_type();
    set_has_snapshot();
    _impl_.type_.snapshot_ = CreateMaybeMessage<::csi::v1::VolumeContentSource_SnapshotSource>(GetArena());
  }
  return _impl_.type_.snapshot_;
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeContentSource_SnapshotSource* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.snapshot)
  return _msg;
}

// .csi.v1.VolumeContentSource.VolumeSource volume = 2;
inline bool VolumeContentSource::has_volume() const {
  return type_case() == kVolume;
}
inline bool VolumeContentSource::_internal_has_volume() const {
  return type_case() == kVolume;
}
inline void VolumeContentSource::set_has_volume() {
  _impl_._oneof_case_[0] = kVolume;
}
inline void VolumeContentSource::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kVolume) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.volume_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::release_volume() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.volume)
  if (type_case() == kVolume) {
    clear_has_type();
    auto* temp = _impl_.type_.volume_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeContentSource_VolumeSource& VolumeContentSource::_internal_volume() const {
  return type_case() == kVolume ? *_impl_.type_.volume_ : reinterpret_cast<::csi::v1::VolumeContentSource_VolumeSource&>(::csi::v1::_VolumeContentSource_VolumeSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource_VolumeSource& VolumeContentSource::volume() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.volume)
  return _internal_volume();
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.volume)
  if (type_case() == kVolume) {
    clear_has_type();
    auto* temp = _impl_.type_.volume_;
    _impl_.type_.volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeContentSource::unsafe_arena_set_allocated_volume(::csi::v1::VolumeContentSource_VolumeSource* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_volume();
    _impl_.type_.volume_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.volume)
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::_internal_mutable_volume() {
  if (type_case() != kVolume) {
    clear_type();
    set_has_volume();
    _impl_.type_.volume_ = CreateMaybeMessage<::csi::v1::VolumeContentSource_VolumeSource>(GetArena());
  }
  return _impl_.type_.volume_;
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::mutable_volume() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeContentSource_VolumeSource* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.volume)
  return _msg;
}

inline bool VolumeContentSource::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void VolumeContentSource::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline VolumeContentSource::TypeCase VolumeContentSource::type_case() const {
  return VolumeContentSource::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateVolumeResponse

// .csi.v1.Volume volume = 1;
inline bool CreateVolumeResponse::has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_ != nullptr);
  return value;
}
inline void CreateVolumeResponse::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_ != nullptr) _impl_.volume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Volume& CreateVolumeResponse::_internal_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Volume* p = _impl_.volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Volume&>(::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& CreateVolumeResponse::volume() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeResponse.volume)
  return _internal_volume();
}
inline void CreateVolumeResponse::unsafe_arena_set_allocated_volume(::csi::v1::Volume* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_);
  }
  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeResponse.volume)
}
inline ::csi::v1::Volume* CreateVolumeResponse::release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* released = _impl_.volume_;
  _impl_.volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Volume* CreateVolumeResponse::unsafe_arena_release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeResponse.volume)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* CreateVolumeResponse::_internal_mutable_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(p);
  }
  return _impl_.volume_;
}
inline ::csi::v1::Volume* CreateVolumeResponse::mutable_volume() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Volume* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeResponse.volume)
  return _msg;
}
inline void CreateVolumeResponse::set_allocated_volume(::csi::v1::Volume* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Volume*>(_impl_.volume_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Volume*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeResponse.volume)
}

// -------------------------------------------------------------------

// VolumeCapability_BlockVolume

// -------------------------------------------------------------------

// VolumeCapability_MountVolume

// string fs_type = 1;
inline void VolumeCapability_MountVolume::clear_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fs_type_.ClearToEmpty();
}
inline const std::string& VolumeCapability_MountVolume::fs_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.MountVolume.fs_type)
  return _internal_fs_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeCapability_MountVolume::set_fs_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fs_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline std::string* VolumeCapability_MountVolume::mutable_fs_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fs_type();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.MountVolume.fs_type)
  return _s;
}
inline const std::string& VolumeCapability_MountVolume::_internal_fs_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fs_type_.Get();
}
inline void VolumeCapability_MountVolume::_internal_set_fs_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fs_type_.Set(value, GetArena());
}
inline std::string* VolumeCapability_MountVolume::_internal_mutable_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.fs_type_.Mutable( GetArena());
}
inline std::string* VolumeCapability_MountVolume::release_fs_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.MountVolume.fs_type)
  return _impl_.fs_type_.Release();
}
inline void VolumeCapability_MountVolume::set_allocated_fs_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fs_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fs_type_.IsDefault()) {
          _impl_.fs_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCapability.MountVolume.fs_type)
}

// repeated string mount_flags = 2;
inline int VolumeCapability_MountVolume::_internal_mount_flags_size() const {
  return _internal_mount_flags().size();
}
inline int VolumeCapability_MountVolume::mount_flags_size() const {
  return _internal_mount_flags_size();
}
inline void VolumeCapability_MountVolume::clear_mount_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mount_flags_.Clear();
}
inline std::string* VolumeCapability_MountVolume::add_mount_flags()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_mount_flags()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _s;
}
inline const std::string& VolumeCapability_MountVolume::mount_flags(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _internal_mount_flags().Get(index);
}
inline std::string* VolumeCapability_MountVolume::mutable_mount_flags(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _internal_mutable_mount_flags()->Mutable(index);
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const std::string& value) {
  _internal_mutable_mount_flags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, std::string&& value) {
  _internal_mutable_mount_flags()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_mount_flags()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_mount_flags()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, absl::string_view value) {
  _internal_mutable_mount_flags()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mount_flags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mount_flags()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mount_flags()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mount_flags()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mount_flags()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VolumeCapability_MountVolume::mount_flags() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _internal_mount_flags();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VolumeCapability_MountVolume::mutable_mount_flags() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.VolumeCapability.MountVolume.mount_flags)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mount_flags();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
VolumeCapability_MountVolume::_internal_mount_flags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mount_flags_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
VolumeCapability_MountVolume::_internal_mutable_mount_flags() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mount_flags_;
}

// string volume_mount_group = 3;
inline void VolumeCapability_MountVolume::clear_volume_mount_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_mount_group_.ClearToEmpty();
}
inline const std::string& VolumeCapability_MountVolume::volume_mount_group() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.MountVolume.volume_mount_group)
  return _internal_volume_mount_group();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeCapability_MountVolume::set_volume_mount_group(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_mount_group_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.volume_mount_group)
}
inline std::string* VolumeCapability_MountVolume::mutable_volume_mount_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_mount_group();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.MountVolume.volume_mount_group)
  return _s;
}
inline const std::string& VolumeCapability_MountVolume::_internal_volume_mount_group() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_mount_group_.Get();
}
inline void VolumeCapability_MountVolume::_internal_set_volume_mount_group(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_mount_group_.Set(value, GetArena());
}
inline std::string* VolumeCapability_MountVolume::_internal_mutable_volume_mount_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_mount_group_.Mutable( GetArena());
}
inline std::string* VolumeCapability_MountVolume::release_volume_mount_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.MountVolume.volume_mount_group)
  return _impl_.volume_mount_group_.Release();
}
inline void VolumeCapability_MountVolume::set_allocated_volume_mount_group(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_mount_group_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_mount_group_.IsDefault()) {
          _impl_.volume_mount_group_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCapability.MountVolume.volume_mount_group)
}

// -------------------------------------------------------------------

// VolumeCapability_AccessMode

// .csi.v1.VolumeCapability.AccessMode.Mode mode = 1;
inline void VolumeCapability_AccessMode::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
}
inline ::csi::v1::VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode::mode() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.AccessMode.mode)
  return _internal_mode();
}
inline void VolumeCapability_AccessMode::set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.AccessMode.mode)
}
inline ::csi::v1::VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::VolumeCapability_AccessMode_Mode>(_impl_.mode_);
}
inline void VolumeCapability_AccessMode::_internal_set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// VolumeCapability

// .csi.v1.VolumeCapability.BlockVolume block = 1;
inline bool VolumeCapability::has_block() const {
  return access_type_case() == kBlock;
}
inline bool VolumeCapability::_internal_has_block() const {
  return access_type_case() == kBlock;
}
inline void VolumeCapability::set_has_block() {
  _impl_._oneof_case_[0] = kBlock;
}
inline void VolumeCapability::clear_block() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (access_type_case() == kBlock) {
    if (GetArena() == nullptr) {
      delete _impl_.access_type_.block_;
    }
    clear_has_access_type();
  }
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::release_block() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.block)
  if (access_type_case() == kBlock) {
    clear_has_access_type();
    auto* temp = _impl_.access_type_.block_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.access_type_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeCapability_BlockVolume& VolumeCapability::_internal_block() const {
  return access_type_case() == kBlock ? *_impl_.access_type_.block_ : reinterpret_cast<::csi::v1::VolumeCapability_BlockVolume&>(::csi::v1::_VolumeCapability_BlockVolume_default_instance_);
}
inline const ::csi::v1::VolumeCapability_BlockVolume& VolumeCapability::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.block)
  return _internal_block();
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCapability.block)
  if (access_type_case() == kBlock) {
    clear_has_access_type();
    auto* temp = _impl_.access_type_.block_;
    _impl_.access_type_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeCapability::unsafe_arena_set_allocated_block(::csi::v1::VolumeCapability_BlockVolume* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_access_type();
  if (value) {
    set_has_block();
    _impl_.access_type_.block_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.block)
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::_internal_mutable_block() {
  if (access_type_case() != kBlock) {
    clear_access_type();
    set_has_block();
    _impl_.access_type_.block_ = CreateMaybeMessage<::csi::v1::VolumeCapability_BlockVolume>(GetArena());
  }
  return _impl_.access_type_.block_;
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::mutable_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability_BlockVolume* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.block)
  return _msg;
}

// .csi.v1.VolumeCapability.MountVolume mount = 2;
inline bool VolumeCapability::has_mount() const {
  return access_type_case() == kMount;
}
inline bool VolumeCapability::_internal_has_mount() const {
  return access_type_case() == kMount;
}
inline void VolumeCapability::set_has_mount() {
  _impl_._oneof_case_[0] = kMount;
}
inline void VolumeCapability::clear_mount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (access_type_case() == kMount) {
    if (GetArena() == nullptr) {
      delete _impl_.access_type_.mount_;
    }
    clear_has_access_type();
  }
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::release_mount() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.mount)
  if (access_type_case() == kMount) {
    clear_has_access_type();
    auto* temp = _impl_.access_type_.mount_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.access_type_.mount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeCapability_MountVolume& VolumeCapability::_internal_mount() const {
  return access_type_case() == kMount ? *_impl_.access_type_.mount_ : reinterpret_cast<::csi::v1::VolumeCapability_MountVolume&>(::csi::v1::_VolumeCapability_MountVolume_default_instance_);
}
inline const ::csi::v1::VolumeCapability_MountVolume& VolumeCapability::mount() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.mount)
  return _internal_mount();
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::unsafe_arena_release_mount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCapability.mount)
  if (access_type_case() == kMount) {
    clear_has_access_type();
    auto* temp = _impl_.access_type_.mount_;
    _impl_.access_type_.mount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeCapability::unsafe_arena_set_allocated_mount(::csi::v1::VolumeCapability_MountVolume* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_access_type();
  if (value) {
    set_has_mount();
    _impl_.access_type_.mount_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.mount)
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::_internal_mutable_mount() {
  if (access_type_case() != kMount) {
    clear_access_type();
    set_has_mount();
    _impl_.access_type_.mount_ = CreateMaybeMessage<::csi::v1::VolumeCapability_MountVolume>(GetArena());
  }
  return _impl_.access_type_.mount_;
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::mutable_mount() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability_MountVolume* _msg = _internal_mutable_mount();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.mount)
  return _msg;
}

// .csi.v1.VolumeCapability.AccessMode access_mode = 3;
inline bool VolumeCapability::has_access_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.access_mode_ != nullptr);
  return value;
}
inline void VolumeCapability::clear_access_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.access_mode_ != nullptr) _impl_.access_mode_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCapability_AccessMode& VolumeCapability::_internal_access_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability_AccessMode* p = _impl_.access_mode_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability_AccessMode&>(::csi::v1::_VolumeCapability_AccessMode_default_instance_);
}
inline const ::csi::v1::VolumeCapability_AccessMode& VolumeCapability::access_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.access_mode)
  return _internal_access_mode();
}
inline void VolumeCapability::unsafe_arena_set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.access_mode_);
  }
  _impl_.access_mode_ = reinterpret_cast<::csi::v1::VolumeCapability_AccessMode*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.access_mode)
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::release_access_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability_AccessMode* released = _impl_.access_mode_;
  _impl_.access_mode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::unsafe_arena_release_access_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.access_mode)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability_AccessMode* temp = _impl_.access_mode_;
  _impl_.access_mode_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::_internal_mutable_access_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.access_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability_AccessMode>(GetArena());
    _impl_.access_mode_ = reinterpret_cast<::csi::v1::VolumeCapability_AccessMode*>(p);
  }
  return _impl_.access_mode_;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::mutable_access_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability_AccessMode* _msg = _internal_mutable_access_mode();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.access_mode)
  return _msg;
}
inline void VolumeCapability::set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability_AccessMode*>(_impl_.access_mode_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability_AccessMode*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.access_mode_ = reinterpret_cast<::csi::v1::VolumeCapability_AccessMode*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCapability.access_mode)
}

inline bool VolumeCapability::has_access_type() const {
  return access_type_case() != ACCESS_TYPE_NOT_SET;
}
inline void VolumeCapability::clear_has_access_type() {
  _impl_._oneof_case_[0] = ACCESS_TYPE_NOT_SET;
}
inline VolumeCapability::AccessTypeCase VolumeCapability::access_type_case() const {
  return VolumeCapability::AccessTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CapacityRange

// int64 required_bytes = 1;
inline void CapacityRange::clear_required_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.required_bytes_ = ::int64_t{0};
}
inline ::int64_t CapacityRange::required_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.CapacityRange.required_bytes)
  return _internal_required_bytes();
}
inline void CapacityRange::set_required_bytes(::int64_t value) {
  _internal_set_required_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.CapacityRange.required_bytes)
}
inline ::int64_t CapacityRange::_internal_required_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.required_bytes_;
}
inline void CapacityRange::_internal_set_required_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.required_bytes_ = value;
}

// int64 limit_bytes = 2;
inline void CapacityRange::clear_limit_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.limit_bytes_ = ::int64_t{0};
}
inline ::int64_t CapacityRange::limit_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.CapacityRange.limit_bytes)
  return _internal_limit_bytes();
}
inline void CapacityRange::set_limit_bytes(::int64_t value) {
  _internal_set_limit_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.CapacityRange.limit_bytes)
}
inline ::int64_t CapacityRange::_internal_limit_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.limit_bytes_;
}
inline void CapacityRange::_internal_set_limit_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.limit_bytes_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Volume

// int64 capacity_bytes = 1;
inline void Volume::clear_capacity_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_bytes_ = ::int64_t{0};
}
inline ::int64_t Volume::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void Volume::set_capacity_bytes(::int64_t value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.Volume.capacity_bytes)
}
inline ::int64_t Volume::_internal_capacity_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_bytes_;
}
inline void Volume::_internal_set_capacity_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capacity_bytes_ = value;
}

// string volume_id = 2;
inline void Volume::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& Volume::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Volume::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.Volume.volume_id)
}
inline std::string* Volume::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.volume_id)
  return _s;
}
inline const std::string& Volume::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void Volume::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* Volume::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* Volume::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Volume.volume_id)
  return _impl_.volume_id_.Release();
}
inline void Volume::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Volume.volume_id)
}

// map<string, string> volume_context = 3;
inline int Volume::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int Volume::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void Volume::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Volume::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Volume::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.Volume.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* Volume::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Volume::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.Volume.volume_context)
  return _internal_mutable_volume_context();
}

// .csi.v1.VolumeContentSource content_source = 4;
inline bool Volume::has_content_source() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.content_source_ != nullptr);
  return value;
}
inline void Volume::clear_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.content_source_ != nullptr) _impl_.content_source_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeContentSource& Volume::_internal_content_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeContentSource* p = _impl_.content_source_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeContentSource&>(::csi::v1::_VolumeContentSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource& Volume::content_source() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.content_source)
  return _internal_content_source();
}
inline void Volume::unsafe_arena_set_allocated_content_source(::csi::v1::VolumeContentSource* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.content_source_);
  }
  _impl_.content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Volume.content_source)
}
inline ::csi::v1::VolumeContentSource* Volume::release_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeContentSource* released = _impl_.content_source_;
  _impl_.content_source_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeContentSource* Volume::unsafe_arena_release_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Volume.content_source)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeContentSource* temp = _impl_.content_source_;
  _impl_.content_source_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeContentSource* Volume::_internal_mutable_content_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.content_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeContentSource>(GetArena());
    _impl_.content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(p);
  }
  return _impl_.content_source_;
}
inline ::csi::v1::VolumeContentSource* Volume::mutable_content_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeContentSource* _msg = _internal_mutable_content_source();
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.content_source)
  return _msg;
}
inline void Volume::set_allocated_content_source(::csi::v1::VolumeContentSource* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeContentSource*>(_impl_.content_source_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeContentSource*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.content_source_ = reinterpret_cast<::csi::v1::VolumeContentSource*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Volume.content_source)
}

// repeated .csi.v1.Topology accessible_topology = 5;
inline int Volume::_internal_accessible_topology_size() const {
  return _internal_accessible_topology().size();
}
inline int Volume::accessible_topology_size() const {
  return _internal_accessible_topology_size();
}
inline void Volume::clear_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accessible_topology_.Clear();
}
inline ::csi::v1::Topology* Volume::mutable_accessible_topology(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.accessible_topology)
  return _internal_mutable_accessible_topology()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* Volume::mutable_accessible_topology()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.Volume.accessible_topology)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_accessible_topology();
}
inline const ::csi::v1::Topology& Volume::accessible_topology(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.accessible_topology)
  return _internal_accessible_topology().Get(index);
}
inline ::csi::v1::Topology* Volume::add_accessible_topology() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::Topology* _add = _internal_mutable_accessible_topology()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.Volume.accessible_topology)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& Volume::accessible_topology() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.Volume.accessible_topology)
  return _internal_accessible_topology();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>&
Volume::_internal_accessible_topology() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accessible_topology_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>*
Volume::_internal_mutable_accessible_topology() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.accessible_topology_;
}

// -------------------------------------------------------------------

// TopologyRequirement

// repeated .csi.v1.Topology requisite = 1;
inline int TopologyRequirement::_internal_requisite_size() const {
  return _internal_requisite().size();
}
inline int TopologyRequirement::requisite_size() const {
  return _internal_requisite_size();
}
inline void TopologyRequirement::clear_requisite() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requisite_.Clear();
}
inline ::csi::v1::Topology* TopologyRequirement::mutable_requisite(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.TopologyRequirement.requisite)
  return _internal_mutable_requisite()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* TopologyRequirement::mutable_requisite()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.TopologyRequirement.requisite)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_requisite();
}
inline const ::csi::v1::Topology& TopologyRequirement::requisite(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.TopologyRequirement.requisite)
  return _internal_requisite().Get(index);
}
inline ::csi::v1::Topology* TopologyRequirement::add_requisite() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::Topology* _add = _internal_mutable_requisite()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.TopologyRequirement.requisite)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& TopologyRequirement::requisite() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.TopologyRequirement.requisite)
  return _internal_requisite();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>&
TopologyRequirement::_internal_requisite() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requisite_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>*
TopologyRequirement::_internal_mutable_requisite() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.requisite_;
}

// repeated .csi.v1.Topology preferred = 2;
inline int TopologyRequirement::_internal_preferred_size() const {
  return _internal_preferred().size();
}
inline int TopologyRequirement::preferred_size() const {
  return _internal_preferred_size();
}
inline void TopologyRequirement::clear_preferred() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preferred_.Clear();
}
inline ::csi::v1::Topology* TopologyRequirement::mutable_preferred(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.TopologyRequirement.preferred)
  return _internal_mutable_preferred()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>* TopologyRequirement::mutable_preferred()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.TopologyRequirement.preferred)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_preferred();
}
inline const ::csi::v1::Topology& TopologyRequirement::preferred(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.TopologyRequirement.preferred)
  return _internal_preferred().Get(index);
}
inline ::csi::v1::Topology* TopologyRequirement::add_preferred() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::Topology* _add = _internal_mutable_preferred()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.TopologyRequirement.preferred)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>& TopologyRequirement::preferred() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.TopologyRequirement.preferred)
  return _internal_preferred();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>&
TopologyRequirement::_internal_preferred() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.preferred_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Topology>*
TopologyRequirement::_internal_mutable_preferred() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.preferred_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Topology

// map<string, string> segments = 1;
inline int Topology::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int Topology::segments_size() const {
  return _internal_segments_size();
}
inline void Topology::clear_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.segments_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& Topology::_internal_segments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.segments_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& Topology::segments() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.Topology.segments)
  return _internal_segments();
}
inline ::google::protobuf::Map<std::string, std::string>* Topology::_internal_mutable_segments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.segments_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* Topology::mutable_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.Topology.segments)
  return _internal_mutable_segments();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteVolumeRequest

// string volume_id = 1;
inline void DeleteVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& DeleteVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.DeleteVolumeRequest.volume_id)
}
inline std::string* DeleteVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteVolumeRequest.volume_id)
  return _s;
}
inline const std::string& DeleteVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void DeleteVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* DeleteVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* DeleteVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.DeleteVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void DeleteVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.DeleteVolumeRequest.volume_id)
}

// map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
inline int DeleteVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int DeleteVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void DeleteVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.DeleteVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.DeleteVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// DeleteVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerPublishVolumeRequest

// string volume_id = 1;
inline void ControllerPublishVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ControllerPublishVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerPublishVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline std::string* ControllerPublishVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return _s;
}
inline const std::string& ControllerPublishVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ControllerPublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ControllerPublishVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ControllerPublishVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ControllerPublishVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_id)
}

// string node_id = 2;
inline void ControllerPublishVolumeRequest::clear_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& ControllerPublishVolumeRequest::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerPublishVolumeRequest::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline std::string* ControllerPublishVolumeRequest::mutable_node_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.node_id)
  return _s;
}
inline const std::string& ControllerPublishVolumeRequest::_internal_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_id_.Get();
}
inline void ControllerPublishVolumeRequest::_internal_set_node_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(value, GetArena());
}
inline std::string* ControllerPublishVolumeRequest::_internal_mutable_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_id_.Mutable( GetArena());
}
inline std::string* ControllerPublishVolumeRequest::release_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.node_id)
  return _impl_.node_id_.Release();
}
inline void ControllerPublishVolumeRequest::set_allocated_node_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.node_id)
}

// .csi.v1.VolumeCapability volume_capability = 3;
inline bool ControllerPublishVolumeRequest::has_volume_capability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_capability_ != nullptr);
  return value;
}
inline void ControllerPublishVolumeRequest::clear_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_capability_ != nullptr) _impl_.volume_capability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCapability& ControllerPublishVolumeRequest::_internal_volume_capability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability* p = _impl_.volume_capability_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability&>(::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& ControllerPublishVolumeRequest::volume_capability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void ControllerPublishVolumeRequest::unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_capability_);
  }
  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* released = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::unsafe_arena_release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.volume_capability)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* temp = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::_internal_mutable_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(p);
  }
  return _impl_.volume_capability_;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::mutable_volume_capability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability* _msg = _internal_mutable_volume_capability();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.volume_capability)
  return _msg;
}
inline void ControllerPublishVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability*>(_impl_.volume_capability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_capability)
}

// bool readonly = 4;
inline void ControllerPublishVolumeRequest::clear_readonly() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.readonly_ = false;
}
inline bool ControllerPublishVolumeRequest::readonly() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.readonly)
  return _internal_readonly();
}
inline void ControllerPublishVolumeRequest::set_readonly(bool value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.readonly)
}
inline bool ControllerPublishVolumeRequest::_internal_readonly() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.readonly_;
}
inline void ControllerPublishVolumeRequest::_internal_set_readonly(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.readonly_ = value;
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ControllerPublishVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ControllerPublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerPublishVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 6;
inline int ControllerPublishVolumeRequest::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int ControllerPublishVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ControllerPublishVolumeRequest::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeRequest::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeRequest::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeRequest::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeRequest::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerPublishVolumeResponse

// map<string, string> publish_context = 1;
inline int ControllerPublishVolumeResponse::_internal_publish_context_size() const {
  return _internal_publish_context().size();
}
inline int ControllerPublishVolumeResponse::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void ControllerPublishVolumeResponse::clear_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publish_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeResponse::_internal_publish_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerPublishVolumeResponse::publish_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeResponse.publish_context)
  return _internal_publish_context();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeResponse::_internal_mutable_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerPublishVolumeResponse::mutable_publish_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeResponse.publish_context)
  return _internal_mutable_publish_context();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerUnpublishVolumeRequest

// string volume_id = 1;
inline void ControllerUnpublishVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ControllerUnpublishVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerUnpublishVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline std::string* ControllerUnpublishVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return _s;
}
inline const std::string& ControllerUnpublishVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ControllerUnpublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ControllerUnpublishVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}

// string node_id = 2;
inline void ControllerUnpublishVolumeRequest::clear_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& ControllerUnpublishVolumeRequest::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerUnpublishVolumeRequest::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline std::string* ControllerUnpublishVolumeRequest::mutable_node_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return _s;
}
inline const std::string& ControllerUnpublishVolumeRequest::_internal_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_id_.Get();
}
inline void ControllerUnpublishVolumeRequest::_internal_set_node_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(value, GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::_internal_mutable_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_id_.Mutable( GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::release_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return _impl_.node_id_.Release();
}
inline void ControllerUnpublishVolumeRequest::set_allocated_node_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int ControllerUnpublishVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ControllerUnpublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerUnpublishVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerUnpublishVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerUnpublishVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerUnpublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerUnpublishVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerUnpublishVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerUnpublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// ControllerUnpublishVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesRequest

// string volume_id = 1;
inline void ValidateVolumeCapabilitiesRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ValidateVolumeCapabilitiesRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateVolumeCapabilitiesRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline std::string* ValidateVolumeCapabilitiesRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return _s;
}
inline const std::string& ValidateVolumeCapabilitiesRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ValidateVolumeCapabilitiesRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ValidateVolumeCapabilitiesRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ValidateVolumeCapabilitiesRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ValidateVolumeCapabilitiesRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}

// map<string, string> volume_context = 2;
inline int ValidateVolumeCapabilitiesRequest::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int ValidateVolumeCapabilitiesRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.volume_context)
  return _internal_mutable_volume_context();
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 3;
inline int ValidateVolumeCapabilitiesRequest::_internal_volume_capabilities_size() const {
  return _internal_volume_capabilities().size();
}
inline int ValidateVolumeCapabilitiesRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_volume_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesRequest::mutable_volume_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _internal_mutable_volume_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* ValidateVolumeCapabilitiesRequest::mutable_volume_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_volume_capabilities();
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesRequest::volume_capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _internal_volume_capabilities().Get(index);
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesRequest::add_volume_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::VolumeCapability* _add = _internal_mutable_volume_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& ValidateVolumeCapabilitiesRequest::volume_capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _internal_volume_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>&
ValidateVolumeCapabilitiesRequest::_internal_volume_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>*
ValidateVolumeCapabilitiesRequest::_internal_mutable_volume_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.volume_capabilities_;
}

// map<string, string> parameters = 4;
inline int ValidateVolumeCapabilitiesRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int ValidateVolumeCapabilitiesRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ValidateVolumeCapabilitiesRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ValidateVolumeCapabilitiesRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> mutable_parameters = 6 [(.csi.v1.alpha_field) = true];
inline int ValidateVolumeCapabilitiesRequest::_internal_mutable_parameters_size() const {
  return _internal_mutable_parameters().size();
}
inline int ValidateVolumeCapabilitiesRequest::mutable_parameters_size() const {
  return _internal_mutable_parameters_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mutable_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::_internal_mutable_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesRequest::mutable_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.mutable_parameters)
  return _internal_mutable_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::_internal_mutable_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesRequest::mutable_mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.mutable_parameters)
  return _internal_mutable_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesResponse_Confirmed

// map<string, string> volume_context = 1;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_context)
  return _internal_mutable_volume_context();
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 2;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_capabilities_size() const {
  return _internal_volume_capabilities().size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_volume_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _internal_mutable_volume_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_volume_capabilities();
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _internal_volume_capabilities().Get(index);
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesResponse_Confirmed::add_volume_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::VolumeCapability* _add = _internal_mutable_volume_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _internal_volume_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>&
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>*
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_volume_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.volume_capabilities_;
}

// map<string, string> parameters = 3;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::parameters_size() const {
  return _internal_parameters_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> mutable_parameters = 4 [(.csi.v1.alpha_field) = true];
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_parameters_size() const {
  return _internal_mutable_parameters().size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::mutable_parameters_size() const {
  return _internal_mutable_parameters_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mutable_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ValidateVolumeCapabilitiesResponse_Confirmed::mutable_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.mutable_parameters)
  return _internal_mutable_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.mutable_parameters)
  return _internal_mutable_mutable_parameters();
}

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesResponse

// .csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;
inline bool ValidateVolumeCapabilitiesResponse::has_confirmed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.confirmed_ != nullptr);
  return value;
}
inline void ValidateVolumeCapabilitiesResponse::clear_confirmed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.confirmed_ != nullptr) _impl_.confirmed_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& ValidateVolumeCapabilitiesResponse::_internal_confirmed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* p = _impl_.confirmed_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed&>(::csi::v1::_ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_);
}
inline const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& ValidateVolumeCapabilitiesResponse::confirmed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
  return _internal_confirmed();
}
inline void ValidateVolumeCapabilitiesResponse::unsafe_arena_set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.confirmed_);
  }
  _impl_.confirmed_ = reinterpret_cast<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::release_confirmed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* released = _impl_.confirmed_;
  _impl_.confirmed_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::unsafe_arena_release_confirmed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* temp = _impl_.confirmed_;
  _impl_.confirmed_ = nullptr;
  return temp;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::_internal_mutable_confirmed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.confirmed_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed>(GetArena());
    _impl_.confirmed_ = reinterpret_cast<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(p);
  }
  return _impl_.confirmed_;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::mutable_confirmed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* _msg = _internal_mutable_confirmed();
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
  return _msg;
}
inline void ValidateVolumeCapabilitiesResponse::set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(_impl_.confirmed_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.confirmed_ = reinterpret_cast<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
}

// string message = 2;
inline void ValidateVolumeCapabilitiesResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ValidateVolumeCapabilitiesResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValidateVolumeCapabilitiesResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline std::string* ValidateVolumeCapabilitiesResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return _s;
}
inline const std::string& ValidateVolumeCapabilitiesResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ValidateVolumeCapabilitiesResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ValidateVolumeCapabilitiesResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ValidateVolumeCapabilitiesResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return _impl_.message_.Release();
}
inline void ValidateVolumeCapabilitiesResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}

// -------------------------------------------------------------------

// ListVolumesRequest

// int32 max_entries = 1;
inline void ListVolumesRequest::clear_max_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_entries_ = 0;
}
inline ::int32_t ListVolumesRequest::max_entries() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesRequest.max_entries)
  return _internal_max_entries();
}
inline void ListVolumesRequest::set_max_entries(::int32_t value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesRequest.max_entries)
}
inline ::int32_t ListVolumesRequest::_internal_max_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_entries_;
}
inline void ListVolumesRequest::_internal_set_max_entries(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_entries_ = value;
}

// string starting_token = 2;
inline void ListVolumesRequest::clear_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starting_token_.ClearToEmpty();
}
inline const std::string& ListVolumesRequest::starting_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesRequest.starting_token)
  return _internal_starting_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListVolumesRequest::set_starting_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starting_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesRequest.starting_token)
}
inline std::string* ListVolumesRequest::mutable_starting_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_starting_token();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesRequest.starting_token)
  return _s;
}
inline const std::string& ListVolumesRequest::_internal_starting_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.starting_token_.Get();
}
inline void ListVolumesRequest::_internal_set_starting_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starting_token_.Set(value, GetArena());
}
inline std::string* ListVolumesRequest::_internal_mutable_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.starting_token_.Mutable( GetArena());
}
inline std::string* ListVolumesRequest::release_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesRequest.starting_token)
  return _impl_.starting_token_.Release();
}
inline void ListVolumesRequest::set_allocated_starting_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starting_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.starting_token_.IsDefault()) {
          _impl_.starting_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesRequest.starting_token)
}

// -------------------------------------------------------------------

// ListVolumesResponse_VolumeStatus

// repeated string published_node_ids = 1;
inline int ListVolumesResponse_VolumeStatus::_internal_published_node_ids_size() const {
  return _internal_published_node_ids().size();
}
inline int ListVolumesResponse_VolumeStatus::published_node_ids_size() const {
  return _internal_published_node_ids_size();
}
inline void ListVolumesResponse_VolumeStatus::clear_published_node_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.published_node_ids_.Clear();
}
inline std::string* ListVolumesResponse_VolumeStatus::add_published_node_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_published_node_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _s;
}
inline const std::string& ListVolumesResponse_VolumeStatus::published_node_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids().Get(index);
}
inline std::string* ListVolumesResponse_VolumeStatus::mutable_published_node_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _internal_mutable_published_node_ids()->Mutable(index);
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const std::string& value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, std::string&& value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, absl::string_view value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListVolumesResponse_VolumeStatus::published_node_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListVolumesResponse_VolumeStatus::mutable_published_node_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_published_node_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ListVolumesResponse_VolumeStatus::_internal_published_node_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.published_node_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ListVolumesResponse_VolumeStatus::_internal_mutable_published_node_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.published_node_ids_;
}

// .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
inline bool ListVolumesResponse_VolumeStatus::has_volume_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_condition_ != nullptr);
  return value;
}
inline void ListVolumesResponse_VolumeStatus::clear_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_condition_ != nullptr) _impl_.volume_condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCondition& ListVolumesResponse_VolumeStatus::_internal_volume_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCondition* p = _impl_.volume_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCondition&>(::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& ListVolumesResponse_VolumeStatus::volume_condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
  return _internal_volume_condition();
}
inline void ListVolumesResponse_VolumeStatus::unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_condition_);
  }
  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* released = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::unsafe_arena_release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* temp = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::_internal_mutable_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(p);
  }
  return _impl_.volume_condition_;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::mutable_volume_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCondition* _msg = _internal_mutable_volume_condition();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
  return _msg;
}
inline void ListVolumesResponse_VolumeStatus::set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCondition*>(_impl_.volume_condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCondition*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
}

// -------------------------------------------------------------------

// ListVolumesResponse_Entry

// .csi.v1.Volume volume = 1;
inline bool ListVolumesResponse_Entry::has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_ != nullptr);
  return value;
}
inline void ListVolumesResponse_Entry::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_ != nullptr) _impl_.volume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Volume& ListVolumesResponse_Entry::_internal_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Volume* p = _impl_.volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Volume&>(::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& ListVolumesResponse_Entry::volume() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.Entry.volume)
  return _internal_volume();
}
inline void ListVolumesResponse_Entry::unsafe_arena_set_allocated_volume(::csi::v1::Volume* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_);
  }
  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.Entry.volume)
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* released = _impl_.volume_;
  _impl_.volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::unsafe_arena_release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.Entry.volume)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::_internal_mutable_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(p);
  }
  return _impl_.volume_;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::mutable_volume() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Volume* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.Entry.volume)
  return _msg;
}
inline void ListVolumesResponse_Entry::set_allocated_volume(::csi::v1::Volume* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Volume*>(_impl_.volume_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Volume*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.Entry.volume)
}

// .csi.v1.ListVolumesResponse.VolumeStatus status = 2;
inline bool ListVolumesResponse_Entry::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ListVolumesResponse_Entry::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::csi::v1::ListVolumesResponse_VolumeStatus& ListVolumesResponse_Entry::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::ListVolumesResponse_VolumeStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::ListVolumesResponse_VolumeStatus&>(::csi::v1::_ListVolumesResponse_VolumeStatus_default_instance_);
}
inline const ::csi::v1::ListVolumesResponse_VolumeStatus& ListVolumesResponse_Entry::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.Entry.status)
  return _internal_status();
}
inline void ListVolumesResponse_Entry::unsafe_arena_set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::csi::v1::ListVolumesResponse_VolumeStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.Entry.status)
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::ListVolumesResponse_VolumeStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.Entry.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::ListVolumesResponse_VolumeStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ListVolumesResponse_VolumeStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::csi::v1::ListVolumesResponse_VolumeStatus*>(p);
  }
  return _impl_.status_;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::ListVolumesResponse_VolumeStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.Entry.status)
  return _msg;
}
inline void ListVolumesResponse_Entry::set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::ListVolumesResponse_VolumeStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::ListVolumesResponse_VolumeStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::csi::v1::ListVolumesResponse_VolumeStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.Entry.status)
}

// -------------------------------------------------------------------

// ListVolumesResponse

// repeated .csi.v1.ListVolumesResponse.Entry entries = 1;
inline int ListVolumesResponse::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int ListVolumesResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ListVolumesResponse::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::csi::v1::ListVolumesResponse_Entry* ListVolumesResponse::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>* ListVolumesResponse::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListVolumesResponse.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::csi::v1::ListVolumesResponse_Entry& ListVolumesResponse::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.entries)
  return _internal_entries().Get(index);
}
inline ::csi::v1::ListVolumesResponse_Entry* ListVolumesResponse::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::ListVolumesResponse_Entry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>& ListVolumesResponse::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ListVolumesResponse.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>&
ListVolumesResponse::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ListVolumesResponse_Entry>*
ListVolumesResponse::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

// string next_token = 2;
inline void ListVolumesResponse::clear_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_token_.ClearToEmpty();
}
inline const std::string& ListVolumesResponse::next_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.next_token)
  return _internal_next_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListVolumesResponse::set_next_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.next_token)
}
inline std::string* ListVolumesResponse::mutable_next_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_token();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.next_token)
  return _s;
}
inline const std::string& ListVolumesResponse::_internal_next_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_token_.Get();
}
inline void ListVolumesResponse::_internal_set_next_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_token_.Set(value, GetArena());
}
inline std::string* ListVolumesResponse::_internal_mutable_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_token_.Mutable( GetArena());
}
inline std::string* ListVolumesResponse::release_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.next_token)
  return _impl_.next_token_.Release();
}
inline void ListVolumesResponse::set_allocated_next_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_token_.IsDefault()) {
          _impl_.next_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.next_token)
}

// -------------------------------------------------------------------

// ControllerGetVolumeRequest

// string volume_id = 1;
inline void ControllerGetVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ControllerGetVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerGetVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline std::string* ControllerGetVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeRequest.volume_id)
  return _s;
}
inline const std::string& ControllerGetVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ControllerGetVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ControllerGetVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ControllerGetVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ControllerGetVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeRequest.volume_id)
}

// -------------------------------------------------------------------

// ControllerGetVolumeResponse_VolumeStatus

// repeated string published_node_ids = 1;
inline int ControllerGetVolumeResponse_VolumeStatus::_internal_published_node_ids_size() const {
  return _internal_published_node_ids().size();
}
inline int ControllerGetVolumeResponse_VolumeStatus::published_node_ids_size() const {
  return _internal_published_node_ids_size();
}
inline void ControllerGetVolumeResponse_VolumeStatus::clear_published_node_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.published_node_ids_.Clear();
}
inline std::string* ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_published_node_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _s;
}
inline const std::string& ControllerGetVolumeResponse_VolumeStatus::published_node_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids().Get(index);
}
inline std::string* ControllerGetVolumeResponse_VolumeStatus::mutable_published_node_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _internal_mutable_published_node_ids()->Mutable(index);
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const std::string& value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, std::string&& value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, absl::string_view value) {
  _internal_mutable_published_node_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_published_node_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ControllerGetVolumeResponse_VolumeStatus::published_node_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ControllerGetVolumeResponse_VolumeStatus::mutable_published_node_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_published_node_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ControllerGetVolumeResponse_VolumeStatus::_internal_published_node_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.published_node_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ControllerGetVolumeResponse_VolumeStatus::_internal_mutable_published_node_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.published_node_ids_;
}

// .csi.v1.VolumeCondition volume_condition = 2;
inline bool ControllerGetVolumeResponse_VolumeStatus::has_volume_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_condition_ != nullptr);
  return value;
}
inline void ControllerGetVolumeResponse_VolumeStatus::clear_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_condition_ != nullptr) _impl_.volume_condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCondition& ControllerGetVolumeResponse_VolumeStatus::_internal_volume_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCondition* p = _impl_.volume_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCondition&>(::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& ControllerGetVolumeResponse_VolumeStatus::volume_condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
  return _internal_volume_condition();
}
inline void ControllerGetVolumeResponse_VolumeStatus::unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_condition_);
  }
  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* released = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::unsafe_arena_release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* temp = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::_internal_mutable_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(p);
  }
  return _impl_.volume_condition_;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::mutable_volume_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCondition* _msg = _internal_mutable_volume_condition();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
  return _msg;
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCondition*>(_impl_.volume_condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCondition*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
}

// -------------------------------------------------------------------

// ControllerGetVolumeResponse

// .csi.v1.Volume volume = 1;
inline bool ControllerGetVolumeResponse::has_volume() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_ != nullptr);
  return value;
}
inline void ControllerGetVolumeResponse::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_ != nullptr) _impl_.volume_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Volume& ControllerGetVolumeResponse::_internal_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Volume* p = _impl_.volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Volume&>(::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& ControllerGetVolumeResponse::volume() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.volume)
  return _internal_volume();
}
inline void ControllerGetVolumeResponse::unsafe_arena_set_allocated_volume(::csi::v1::Volume* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_);
  }
  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.volume)
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* released = _impl_.volume_;
  _impl_.volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::unsafe_arena_release_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.volume)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Volume* temp = _impl_.volume_;
  _impl_.volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::_internal_mutable_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(p);
  }
  return _impl_.volume_;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::mutable_volume() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Volume* _msg = _internal_mutable_volume();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.volume)
  return _msg;
}
inline void ControllerGetVolumeResponse::set_allocated_volume(::csi::v1::Volume* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Volume*>(_impl_.volume_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Volume*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_ = reinterpret_cast<::csi::v1::Volume*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.volume)
}

// .csi.v1.ControllerGetVolumeResponse.VolumeStatus status = 2;
inline bool ControllerGetVolumeResponse::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void ControllerGetVolumeResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& ControllerGetVolumeResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus&>(::csi::v1::_ControllerGetVolumeResponse_VolumeStatus_default_instance_);
}
inline const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& ControllerGetVolumeResponse::status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.status)
  return _internal_status();
}
inline void ControllerGetVolumeResponse::unsafe_arena_set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.status)
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.status)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ControllerGetVolumeResponse_VolumeStatus>(GetArena());
    _impl_.status_ = reinterpret_cast<::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(p);
  }
  return _impl_.status_;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.status)
  return _msg;
}
inline void ControllerGetVolumeResponse::set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.status_ = reinterpret_cast<::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.status)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerModifyVolumeRequest

// string volume_id = 1;
inline void ControllerModifyVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ControllerModifyVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerModifyVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerModifyVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerModifyVolumeRequest.volume_id)
}
inline std::string* ControllerModifyVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerModifyVolumeRequest.volume_id)
  return _s;
}
inline const std::string& ControllerModifyVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ControllerModifyVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ControllerModifyVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ControllerModifyVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerModifyVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ControllerModifyVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerModifyVolumeRequest.volume_id)
}

// map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
inline int ControllerModifyVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ControllerModifyVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerModifyVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerModifyVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerModifyVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerModifyVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerModifyVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerModifyVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerModifyVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> mutable_parameters = 3;
inline int ControllerModifyVolumeRequest::_internal_mutable_parameters_size() const {
  return _internal_mutable_parameters().size();
}
inline int ControllerModifyVolumeRequest::mutable_parameters_size() const {
  return _internal_mutable_parameters_size();
}
inline void ControllerModifyVolumeRequest::clear_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mutable_parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerModifyVolumeRequest::_internal_mutable_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerModifyVolumeRequest::mutable_parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerModifyVolumeRequest.mutable_parameters)
  return _internal_mutable_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerModifyVolumeRequest::_internal_mutable_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mutable_parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerModifyVolumeRequest::mutable_mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerModifyVolumeRequest.mutable_parameters)
  return _internal_mutable_mutable_parameters();
}

// -------------------------------------------------------------------

// ControllerModifyVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetCapacityRequest

// repeated .csi.v1.VolumeCapability volume_capabilities = 1;
inline int GetCapacityRequest::_internal_volume_capabilities_size() const {
  return _internal_volume_capabilities().size();
}
inline int GetCapacityRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void GetCapacityRequest::clear_volume_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* GetCapacityRequest::mutable_volume_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityRequest.volume_capabilities)
  return _internal_mutable_volume_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>* GetCapacityRequest::mutable_volume_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GetCapacityRequest.volume_capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_volume_capabilities();
}
inline const ::csi::v1::VolumeCapability& GetCapacityRequest::volume_capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityRequest.volume_capabilities)
  return _internal_volume_capabilities().Get(index);
}
inline ::csi::v1::VolumeCapability* GetCapacityRequest::add_volume_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::VolumeCapability* _add = _internal_mutable_volume_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.GetCapacityRequest.volume_capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>& GetCapacityRequest::volume_capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.GetCapacityRequest.volume_capabilities)
  return _internal_volume_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>&
GetCapacityRequest::_internal_volume_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeCapability>*
GetCapacityRequest::_internal_mutable_volume_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.volume_capabilities_;
}

// map<string, string> parameters = 2;
inline int GetCapacityRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int GetCapacityRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void GetCapacityRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetCapacityRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetCapacityRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.GetCapacityRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* GetCapacityRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GetCapacityRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.GetCapacityRequest.parameters)
  return _internal_mutable_parameters();
}

// .csi.v1.Topology accessible_topology = 3;
inline bool GetCapacityRequest::has_accessible_topology() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accessible_topology_ != nullptr);
  return value;
}
inline void GetCapacityRequest::clear_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accessible_topology_ != nullptr) _impl_.accessible_topology_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Topology& GetCapacityRequest::_internal_accessible_topology() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Topology* p = _impl_.accessible_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Topology&>(::csi::v1::_Topology_default_instance_);
}
inline const ::csi::v1::Topology& GetCapacityRequest::accessible_topology() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityRequest.accessible_topology)
  return _internal_accessible_topology();
}
inline void GetCapacityRequest::unsafe_arena_set_allocated_accessible_topology(::csi::v1::Topology* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accessible_topology_);
  }
  _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityRequest.accessible_topology)
}
inline ::csi::v1::Topology* GetCapacityRequest::release_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Topology* released = _impl_.accessible_topology_;
  _impl_.accessible_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Topology* GetCapacityRequest::unsafe_arena_release_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityRequest.accessible_topology)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Topology* temp = _impl_.accessible_topology_;
  _impl_.accessible_topology_ = nullptr;
  return temp;
}
inline ::csi::v1::Topology* GetCapacityRequest::_internal_mutable_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.accessible_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Topology>(GetArena());
    _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(p);
  }
  return _impl_.accessible_topology_;
}
inline ::csi::v1::Topology* GetCapacityRequest::mutable_accessible_topology() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Topology* _msg = _internal_mutable_accessible_topology();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityRequest.accessible_topology)
  return _msg;
}
inline void GetCapacityRequest::set_allocated_accessible_topology(::csi::v1::Topology* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Topology*>(_impl_.accessible_topology_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Topology*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityRequest.accessible_topology)
}

// -------------------------------------------------------------------

// GetCapacityResponse

// int64 available_capacity = 1;
inline void GetCapacityResponse::clear_available_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_capacity_ = ::int64_t{0};
}
inline ::int64_t GetCapacityResponse::available_capacity() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.available_capacity)
  return _internal_available_capacity();
}
inline void GetCapacityResponse::set_available_capacity(::int64_t value) {
  _internal_set_available_capacity(value);
  // @@protoc_insertion_point(field_set:csi.v1.GetCapacityResponse.available_capacity)
}
inline ::int64_t GetCapacityResponse::_internal_available_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_capacity_;
}
inline void GetCapacityResponse::_internal_set_available_capacity(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.available_capacity_ = value;
}

// .google.protobuf.Int64Value maximum_volume_size = 2;
inline bool GetCapacityResponse::has_maximum_volume_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.maximum_volume_size_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& GetCapacityResponse::_internal_maximum_volume_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.maximum_volume_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& GetCapacityResponse::maximum_volume_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.maximum_volume_size)
  return _internal_maximum_volume_size();
}
inline void GetCapacityResponse::unsafe_arena_set_allocated_maximum_volume_size(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_volume_size_);
  }
  _impl_.maximum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityResponse.maximum_volume_size)
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::release_maximum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* released = _impl_.maximum_volume_size_;
  _impl_.maximum_volume_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::unsafe_arena_release_maximum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityResponse.maximum_volume_size)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Int64Value* temp = _impl_.maximum_volume_size_;
  _impl_.maximum_volume_size_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::_internal_mutable_maximum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.maximum_volume_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.maximum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.maximum_volume_size_;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::mutable_maximum_volume_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_maximum_volume_size();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityResponse.maximum_volume_size)
  return _msg;
}
inline void GetCapacityResponse::set_allocated_maximum_volume_size(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.maximum_volume_size_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.maximum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityResponse.maximum_volume_size)
}

// .google.protobuf.Int64Value minimum_volume_size = 3 [(.csi.v1.alpha_field) = true];
inline bool GetCapacityResponse::has_minimum_volume_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.minimum_volume_size_ != nullptr);
  return value;
}
inline const ::google::protobuf::Int64Value& GetCapacityResponse::_internal_minimum_volume_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Int64Value* p = _impl_.minimum_volume_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Int64Value&>(::google::protobuf::_Int64Value_default_instance_);
}
inline const ::google::protobuf::Int64Value& GetCapacityResponse::minimum_volume_size() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.minimum_volume_size)
  return _internal_minimum_volume_size();
}
inline void GetCapacityResponse::unsafe_arena_set_allocated_minimum_volume_size(::google::protobuf::Int64Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_volume_size_);
  }
  _impl_.minimum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityResponse.minimum_volume_size)
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::release_minimum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* released = _impl_.minimum_volume_size_;
  _impl_.minimum_volume_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::unsafe_arena_release_minimum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityResponse.minimum_volume_size)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Int64Value* temp = _impl_.minimum_volume_size_;
  _impl_.minimum_volume_size_ = nullptr;
  return temp;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::_internal_mutable_minimum_volume_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.minimum_volume_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArena());
    _impl_.minimum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(p);
  }
  return _impl_.minimum_volume_size_;
}
inline ::google::protobuf::Int64Value* GetCapacityResponse::mutable_minimum_volume_size() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Int64Value* _msg = _internal_mutable_minimum_volume_size();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityResponse.minimum_volume_size)
  return _msg;
}
inline void GetCapacityResponse::set_allocated_minimum_volume_size(::google::protobuf::Int64Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.minimum_volume_size_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.minimum_volume_size_ = reinterpret_cast<::google::protobuf::Int64Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityResponse.minimum_volume_size)
}

// -------------------------------------------------------------------

// ControllerGetCapabilitiesRequest

// -------------------------------------------------------------------

// ControllerGetCapabilitiesResponse

// repeated .csi.v1.ControllerServiceCapability capabilities = 1;
inline int ControllerGetCapabilitiesResponse::_internal_capabilities_size() const {
  return _internal_capabilities().size();
}
inline int ControllerGetCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void ControllerGetCapabilitiesResponse::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_.Clear();
}
inline ::csi::v1::ControllerServiceCapability* ControllerGetCapabilitiesResponse::mutable_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _internal_mutable_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>* ControllerGetCapabilitiesResponse::mutable_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capabilities();
}
inline const ::csi::v1::ControllerServiceCapability& ControllerGetCapabilitiesResponse::capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _internal_capabilities().Get(index);
}
inline ::csi::v1::ControllerServiceCapability* ControllerGetCapabilitiesResponse::add_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::ControllerServiceCapability* _add = _internal_mutable_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>& ControllerGetCapabilitiesResponse::capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _internal_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>&
ControllerGetCapabilitiesResponse::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ControllerServiceCapability>*
ControllerGetCapabilitiesResponse::_internal_mutable_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// ControllerServiceCapability_RPC

// .csi.v1.ControllerServiceCapability.RPC.Type type = 1;
inline void ControllerServiceCapability_RPC::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::csi::v1::ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerServiceCapability.RPC.type)
  return _internal_type();
}
inline void ControllerServiceCapability_RPC::set_type(::csi::v1::ControllerServiceCapability_RPC_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerServiceCapability.RPC.type)
}
inline ::csi::v1::ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::ControllerServiceCapability_RPC_Type>(_impl_.type_);
}
inline void ControllerServiceCapability_RPC::_internal_set_type(::csi::v1::ControllerServiceCapability_RPC_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// ControllerServiceCapability

// .csi.v1.ControllerServiceCapability.RPC rpc = 1;
inline bool ControllerServiceCapability::has_rpc() const {
  return type_case() == kRpc;
}
inline bool ControllerServiceCapability::_internal_has_rpc() const {
  return type_case() == kRpc;
}
inline void ControllerServiceCapability::set_has_rpc() {
  _impl_._oneof_case_[0] = kRpc;
}
inline void ControllerServiceCapability::clear_rpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRpc) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rpc_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::release_rpc() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::ControllerServiceCapability_RPC& ControllerServiceCapability::_internal_rpc() const {
  return type_case() == kRpc ? *_impl_.type_.rpc_ : reinterpret_cast<::csi::v1::ControllerServiceCapability_RPC&>(::csi::v1::_ControllerServiceCapability_RPC_default_instance_);
}
inline const ::csi::v1::ControllerServiceCapability_RPC& ControllerServiceCapability::rpc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerServiceCapability.rpc)
  return _internal_rpc();
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControllerServiceCapability::unsafe_arena_set_allocated_rpc(::csi::v1::ControllerServiceCapability_RPC* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rpc();
    _impl_.type_.rpc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerServiceCapability.rpc)
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::_internal_mutable_rpc() {
  if (type_case() != kRpc) {
    clear_type();
    set_has_rpc();
    _impl_.type_.rpc_ = CreateMaybeMessage<::csi::v1::ControllerServiceCapability_RPC>(GetArena());
  }
  return _impl_.type_.rpc_;
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::mutable_rpc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::ControllerServiceCapability_RPC* _msg = _internal_mutable_rpc();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerServiceCapability.rpc)
  return _msg;
}

inline bool ControllerServiceCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ControllerServiceCapability::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline ControllerServiceCapability::TypeCase ControllerServiceCapability::type_case() const {
  return ControllerServiceCapability::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateSnapshotRequest

// string source_volume_id = 1;
inline void CreateSnapshotRequest::clear_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.ClearToEmpty();
}
inline const std::string& CreateSnapshotRequest::source_volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotRequest.source_volume_id)
  return _internal_source_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateSnapshotRequest::set_source_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline std::string* CreateSnapshotRequest::mutable_source_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotRequest.source_volume_id)
  return _s;
}
inline const std::string& CreateSnapshotRequest::_internal_source_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_volume_id_.Get();
}
inline void CreateSnapshotRequest::_internal_set_source_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(value, GetArena());
}
inline std::string* CreateSnapshotRequest::_internal_mutable_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_volume_id_.Mutable( GetArena());
}
inline std::string* CreateSnapshotRequest::release_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotRequest.source_volume_id)
  return _impl_.source_volume_id_.Release();
}
inline void CreateSnapshotRequest::set_allocated_source_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_volume_id_.IsDefault()) {
          _impl_.source_volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotRequest.source_volume_id)
}

// string name = 2;
inline void CreateSnapshotRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateSnapshotRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateSnapshotRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.CreateSnapshotRequest.name)
}
inline std::string* CreateSnapshotRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotRequest.name)
  return _s;
}
inline const std::string& CreateSnapshotRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateSnapshotRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreateSnapshotRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreateSnapshotRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotRequest.name)
  return _impl_.name_.Release();
}
inline void CreateSnapshotRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotRequest.name)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int CreateSnapshotRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int CreateSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void CreateSnapshotRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateSnapshotRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateSnapshotRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateSnapshotRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateSnapshotRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> parameters = 4;
inline int CreateSnapshotRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int CreateSnapshotRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void CreateSnapshotRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateSnapshotRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateSnapshotRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateSnapshotRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateSnapshotRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateSnapshotRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateSnapshotRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// CreateSnapshotResponse

// .csi.v1.Snapshot snapshot = 1;
inline bool CreateSnapshotResponse::has_snapshot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.snapshot_ != nullptr);
  return value;
}
inline void CreateSnapshotResponse::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.snapshot_ != nullptr) _impl_.snapshot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Snapshot& CreateSnapshotResponse::_internal_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Snapshot* p = _impl_.snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Snapshot&>(::csi::v1::_Snapshot_default_instance_);
}
inline const ::csi::v1::Snapshot& CreateSnapshotResponse::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotResponse.snapshot)
  return _internal_snapshot();
}
inline void CreateSnapshotResponse::unsafe_arena_set_allocated_snapshot(::csi::v1::Snapshot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.snapshot_);
  }
  _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateSnapshotResponse.snapshot)
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::release_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Snapshot* released = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::unsafe_arena_release_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotResponse.snapshot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Snapshot* temp = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::_internal_mutable_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Snapshot>(GetArena());
    _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(p);
  }
  return _impl_.snapshot_;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Snapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotResponse.snapshot)
  return _msg;
}
inline void CreateSnapshotResponse::set_allocated_snapshot(::csi::v1::Snapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Snapshot*>(_impl_.snapshot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Snapshot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotResponse.snapshot)
}

// -------------------------------------------------------------------

// Snapshot

// int64 size_bytes = 1;
inline void Snapshot::clear_size_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_bytes_ = ::int64_t{0};
}
inline ::int64_t Snapshot::size_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.size_bytes)
  return _internal_size_bytes();
}
inline void Snapshot::set_size_bytes(::int64_t value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.size_bytes)
}
inline ::int64_t Snapshot::_internal_size_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_bytes_;
}
inline void Snapshot::_internal_set_size_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_bytes_ = value;
}

// string snapshot_id = 2;
inline void Snapshot::clear_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.ClearToEmpty();
}
inline const std::string& Snapshot::snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.snapshot_id)
  return _internal_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.snapshot_id)
}
inline std::string* Snapshot::mutable_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.snapshot_id)
  return _s;
}
inline const std::string& Snapshot::_internal_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_id_.Get();
}
inline void Snapshot::_internal_set_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(value, GetArena());
}
inline std::string* Snapshot::_internal_mutable_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.snapshot_id_.Mutable( GetArena());
}
inline std::string* Snapshot::release_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.snapshot_id)
  return _impl_.snapshot_id_.Release();
}
inline void Snapshot::set_allocated_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.snapshot_id_.IsDefault()) {
          _impl_.snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.snapshot_id)
}

// string source_volume_id = 3;
inline void Snapshot::clear_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.ClearToEmpty();
}
inline const std::string& Snapshot::source_volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.source_volume_id)
  return _internal_source_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_source_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.source_volume_id)
}
inline std::string* Snapshot::mutable_source_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.source_volume_id)
  return _s;
}
inline const std::string& Snapshot::_internal_source_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_volume_id_.Get();
}
inline void Snapshot::_internal_set_source_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(value, GetArena());
}
inline std::string* Snapshot::_internal_mutable_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_volume_id_.Mutable( GetArena());
}
inline std::string* Snapshot::release_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.source_volume_id)
  return _impl_.source_volume_id_.Release();
}
inline void Snapshot::set_allocated_source_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_volume_id_.IsDefault()) {
          _impl_.source_volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.source_volume_id)
}

// .google.protobuf.Timestamp creation_time = 4;
inline bool Snapshot::has_creation_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creation_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Snapshot::_internal_creation_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.creation_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Snapshot::creation_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.creation_time)
  return _internal_creation_time();
}
inline void Snapshot::unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }
  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Snapshot.creation_time)
}
inline ::google::protobuf::Timestamp* Snapshot::release_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Snapshot::unsafe_arena_release_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.creation_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Snapshot::_internal_mutable_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.creation_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.creation_time_;
}
inline ::google::protobuf::Timestamp* Snapshot::mutable_creation_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_creation_time();
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.creation_time)
  return _msg;
}
inline void Snapshot::set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.creation_time)
}

// bool ready_to_use = 5;
inline void Snapshot::clear_ready_to_use() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ready_to_use_ = false;
}
inline bool Snapshot::ready_to_use() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.ready_to_use)
  return _internal_ready_to_use();
}
inline void Snapshot::set_ready_to_use(bool value) {
  _internal_set_ready_to_use(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.ready_to_use)
}
inline bool Snapshot::_internal_ready_to_use() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ready_to_use_;
}
inline void Snapshot::_internal_set_ready_to_use(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ready_to_use_ = value;
}

// string group_snapshot_id = 6 [(.csi.v1.alpha_field) = true];
inline void Snapshot::clear_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.ClearToEmpty();
}
inline const std::string& Snapshot::group_snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.group_snapshot_id)
  return _internal_group_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Snapshot::set_group_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.group_snapshot_id)
}
inline std::string* Snapshot::mutable_group_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.group_snapshot_id)
  return _s;
}
inline const std::string& Snapshot::_internal_group_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_snapshot_id_.Get();
}
inline void Snapshot::_internal_set_group_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(value, GetArena());
}
inline std::string* Snapshot::_internal_mutable_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_snapshot_id_.Mutable( GetArena());
}
inline std::string* Snapshot::release_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.group_snapshot_id)
  return _impl_.group_snapshot_id_.Release();
}
inline void Snapshot::set_allocated_group_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_snapshot_id_.IsDefault()) {
          _impl_.group_snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.group_snapshot_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteSnapshotRequest

// string snapshot_id = 1;
inline void DeleteSnapshotRequest::clear_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.ClearToEmpty();
}
inline const std::string& DeleteSnapshotRequest::snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return _internal_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteSnapshotRequest::set_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline std::string* DeleteSnapshotRequest::mutable_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return _s;
}
inline const std::string& DeleteSnapshotRequest::_internal_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_id_.Get();
}
inline void DeleteSnapshotRequest::_internal_set_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(value, GetArena());
}
inline std::string* DeleteSnapshotRequest::_internal_mutable_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.snapshot_id_.Mutable( GetArena());
}
inline std::string* DeleteSnapshotRequest::release_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return _impl_.snapshot_id_.Release();
}
inline void DeleteSnapshotRequest::set_allocated_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.snapshot_id_.IsDefault()) {
          _impl_.snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.DeleteSnapshotRequest.snapshot_id)
}

// map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
inline int DeleteSnapshotRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int DeleteSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void DeleteSnapshotRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteSnapshotRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteSnapshotRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.DeleteSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteSnapshotRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteSnapshotRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.DeleteSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// DeleteSnapshotResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ListSnapshotsRequest

// int32 max_entries = 1;
inline void ListSnapshotsRequest::clear_max_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_entries_ = 0;
}
inline ::int32_t ListSnapshotsRequest::max_entries() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.max_entries)
  return _internal_max_entries();
}
inline void ListSnapshotsRequest::set_max_entries(::int32_t value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.max_entries)
}
inline ::int32_t ListSnapshotsRequest::_internal_max_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_entries_;
}
inline void ListSnapshotsRequest::_internal_set_max_entries(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_entries_ = value;
}

// string starting_token = 2;
inline void ListSnapshotsRequest::clear_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starting_token_.ClearToEmpty();
}
inline const std::string& ListSnapshotsRequest::starting_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.starting_token)
  return _internal_starting_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListSnapshotsRequest::set_starting_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starting_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.starting_token)
}
inline std::string* ListSnapshotsRequest::mutable_starting_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_starting_token();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.starting_token)
  return _s;
}
inline const std::string& ListSnapshotsRequest::_internal_starting_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.starting_token_.Get();
}
inline void ListSnapshotsRequest::_internal_set_starting_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starting_token_.Set(value, GetArena());
}
inline std::string* ListSnapshotsRequest::_internal_mutable_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.starting_token_.Mutable( GetArena());
}
inline std::string* ListSnapshotsRequest::release_starting_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.starting_token)
  return _impl_.starting_token_.Release();
}
inline void ListSnapshotsRequest::set_allocated_starting_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starting_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.starting_token_.IsDefault()) {
          _impl_.starting_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.starting_token)
}

// string source_volume_id = 3;
inline void ListSnapshotsRequest::clear_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.ClearToEmpty();
}
inline const std::string& ListSnapshotsRequest::source_volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.source_volume_id)
  return _internal_source_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListSnapshotsRequest::set_source_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline std::string* ListSnapshotsRequest::mutable_source_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.source_volume_id)
  return _s;
}
inline const std::string& ListSnapshotsRequest::_internal_source_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_volume_id_.Get();
}
inline void ListSnapshotsRequest::_internal_set_source_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_volume_id_.Set(value, GetArena());
}
inline std::string* ListSnapshotsRequest::_internal_mutable_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_volume_id_.Mutable( GetArena());
}
inline std::string* ListSnapshotsRequest::release_source_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.source_volume_id)
  return _impl_.source_volume_id_.Release();
}
inline void ListSnapshotsRequest::set_allocated_source_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_volume_id_.IsDefault()) {
          _impl_.source_volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.source_volume_id)
}

// string snapshot_id = 4;
inline void ListSnapshotsRequest::clear_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.ClearToEmpty();
}
inline const std::string& ListSnapshotsRequest::snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.snapshot_id)
  return _internal_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListSnapshotsRequest::set_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline std::string* ListSnapshotsRequest::mutable_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.snapshot_id)
  return _s;
}
inline const std::string& ListSnapshotsRequest::_internal_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_id_.Get();
}
inline void ListSnapshotsRequest::_internal_set_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.snapshot_id_.Set(value, GetArena());
}
inline std::string* ListSnapshotsRequest::_internal_mutable_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.snapshot_id_.Mutable( GetArena());
}
inline std::string* ListSnapshotsRequest::release_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.snapshot_id)
  return _impl_.snapshot_id_.Release();
}
inline void ListSnapshotsRequest::set_allocated_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.snapshot_id_.IsDefault()) {
          _impl_.snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.snapshot_id)
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ListSnapshotsRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ListSnapshotsRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ListSnapshotsRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ListSnapshotsRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ListSnapshotsRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ListSnapshotsRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ListSnapshotsRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ListSnapshotsRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ListSnapshotsRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// ListSnapshotsResponse_Entry

// .csi.v1.Snapshot snapshot = 1;
inline bool ListSnapshotsResponse_Entry::has_snapshot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.snapshot_ != nullptr);
  return value;
}
inline void ListSnapshotsResponse_Entry::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.snapshot_ != nullptr) _impl_.snapshot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Snapshot& ListSnapshotsResponse_Entry::_internal_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Snapshot* p = _impl_.snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Snapshot&>(::csi::v1::_Snapshot_default_instance_);
}
inline const ::csi::v1::Snapshot& ListSnapshotsResponse_Entry::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.Entry.snapshot)
  return _internal_snapshot();
}
inline void ListSnapshotsResponse_Entry::unsafe_arena_set_allocated_snapshot(::csi::v1::Snapshot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.snapshot_);
  }
  _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsResponse.Entry.snapshot)
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::release_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Snapshot* released = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::unsafe_arena_release_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsResponse.Entry.snapshot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Snapshot* temp = _impl_.snapshot_;
  _impl_.snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::_internal_mutable_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Snapshot>(GetArena());
    _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(p);
  }
  return _impl_.snapshot_;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Snapshot* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.Entry.snapshot)
  return _msg;
}
inline void ListSnapshotsResponse_Entry::set_allocated_snapshot(::csi::v1::Snapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Snapshot*>(_impl_.snapshot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Snapshot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.snapshot_ = reinterpret_cast<::csi::v1::Snapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsResponse.Entry.snapshot)
}

// -------------------------------------------------------------------

// ListSnapshotsResponse

// repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;
inline int ListSnapshotsResponse::_internal_entries_size() const {
  return _internal_entries().size();
}
inline int ListSnapshotsResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ListSnapshotsResponse::clear_entries() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entries_.Clear();
}
inline ::csi::v1::ListSnapshotsResponse_Entry* ListSnapshotsResponse::mutable_entries(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.entries)
  return _internal_mutable_entries()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>* ListSnapshotsResponse::mutable_entries()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListSnapshotsResponse.entries)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_entries();
}
inline const ::csi::v1::ListSnapshotsResponse_Entry& ListSnapshotsResponse::entries(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.entries)
  return _internal_entries().Get(index);
}
inline ::csi::v1::ListSnapshotsResponse_Entry* ListSnapshotsResponse::add_entries() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::ListSnapshotsResponse_Entry* _add = _internal_mutable_entries()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.ListSnapshotsResponse.entries)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>& ListSnapshotsResponse::entries() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.ListSnapshotsResponse.entries)
  return _internal_entries();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>&
ListSnapshotsResponse::_internal_entries() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entries_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::ListSnapshotsResponse_Entry>*
ListSnapshotsResponse::_internal_mutable_entries() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.entries_;
}

// string next_token = 2;
inline void ListSnapshotsResponse::clear_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_token_.ClearToEmpty();
}
inline const std::string& ListSnapshotsResponse::next_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.next_token)
  return _internal_next_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListSnapshotsResponse::set_next_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsResponse.next_token)
}
inline std::string* ListSnapshotsResponse::mutable_next_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_token();
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.next_token)
  return _s;
}
inline const std::string& ListSnapshotsResponse::_internal_next_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_token_.Get();
}
inline void ListSnapshotsResponse::_internal_set_next_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_token_.Set(value, GetArena());
}
inline std::string* ListSnapshotsResponse::_internal_mutable_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_token_.Mutable( GetArena());
}
inline std::string* ListSnapshotsResponse::release_next_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsResponse.next_token)
  return _impl_.next_token_.Release();
}
inline void ListSnapshotsResponse::set_allocated_next_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_token_.IsDefault()) {
          _impl_.next_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsResponse.next_token)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerExpandVolumeRequest

// string volume_id = 1;
inline void ControllerExpandVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& ControllerExpandVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ControllerExpandVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline std::string* ControllerExpandVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return _s;
}
inline const std::string& ControllerExpandVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void ControllerExpandVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* ControllerExpandVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* ControllerExpandVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void ControllerExpandVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_id)
}

// .csi.v1.CapacityRange capacity_range = 2;
inline bool ControllerExpandVolumeRequest::has_capacity_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capacity_range_ != nullptr);
  return value;
}
inline void ControllerExpandVolumeRequest::clear_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.capacity_range_ != nullptr) _impl_.capacity_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::CapacityRange& ControllerExpandVolumeRequest::_internal_capacity_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::CapacityRange* p = _impl_.capacity_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::CapacityRange&>(::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& ControllerExpandVolumeRequest::capacity_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void ControllerExpandVolumeRequest::unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacity_range_);
  }
  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerExpandVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* released = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::unsafe_arena_release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.capacity_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* temp = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::_internal_mutable_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(p);
  }
  return _impl_.capacity_range_;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::mutable_capacity_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::CapacityRange* _msg = _internal_mutable_capacity_range();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.capacity_range)
  return _msg;
}
inline void ControllerExpandVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::CapacityRange*>(_impl_.capacity_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::CapacityRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.capacity_range)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int ControllerExpandVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int ControllerExpandVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerExpandVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerExpandVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ControllerExpandVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerExpandVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerExpandVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* ControllerExpandVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerExpandVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// .csi.v1.VolumeCapability volume_capability = 4;
inline bool ControllerExpandVolumeRequest::has_volume_capability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_capability_ != nullptr);
  return value;
}
inline void ControllerExpandVolumeRequest::clear_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_capability_ != nullptr) _impl_.volume_capability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::csi::v1::VolumeCapability& ControllerExpandVolumeRequest::_internal_volume_capability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability* p = _impl_.volume_capability_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability&>(::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& ControllerExpandVolumeRequest::volume_capability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void ControllerExpandVolumeRequest::unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_capability_);
  }
  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeCapability* released = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::unsafe_arena_release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.volume_capability)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeCapability* temp = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::_internal_mutable_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(p);
  }
  return _impl_.volume_capability_;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::mutable_volume_capability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability* _msg = _internal_mutable_volume_capability();
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.volume_capability)
  return _msg;
}
inline void ControllerExpandVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability*>(_impl_.volume_capability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_capability)
}

// -------------------------------------------------------------------

// ControllerExpandVolumeResponse

// int64 capacity_bytes = 1;
inline void ControllerExpandVolumeResponse::clear_capacity_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_bytes_ = ::int64_t{0};
}
inline ::int64_t ControllerExpandVolumeResponse::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeResponse.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void ControllerExpandVolumeResponse::set_capacity_bytes(::int64_t value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeResponse.capacity_bytes)
}
inline ::int64_t ControllerExpandVolumeResponse::_internal_capacity_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_bytes_;
}
inline void ControllerExpandVolumeResponse::_internal_set_capacity_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capacity_bytes_ = value;
}

// bool node_expansion_required = 2;
inline void ControllerExpandVolumeResponse::clear_node_expansion_required() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_expansion_required_ = false;
}
inline bool ControllerExpandVolumeResponse::node_expansion_required() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeResponse.node_expansion_required)
  return _internal_node_expansion_required();
}
inline void ControllerExpandVolumeResponse::set_node_expansion_required(bool value) {
  _internal_set_node_expansion_required(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeResponse.node_expansion_required)
}
inline bool ControllerExpandVolumeResponse::_internal_node_expansion_required() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_expansion_required_;
}
inline void ControllerExpandVolumeResponse::_internal_set_node_expansion_required(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_expansion_required_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeStageVolumeRequest

// string volume_id = 1;
inline void NodeStageVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodeStageVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStageVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline std::string* NodeStageVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.volume_id)
  return _s;
}
inline const std::string& NodeStageVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodeStageVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodeStageVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodeStageVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodeStageVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.volume_id)
}

// map<string, string> publish_context = 2;
inline int NodeStageVolumeRequest::_internal_publish_context_size() const {
  return _internal_publish_context().size();
}
inline int NodeStageVolumeRequest::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void NodeStageVolumeRequest::clear_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publish_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::_internal_publish_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::publish_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.publish_context)
  return _internal_publish_context();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::_internal_mutable_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::mutable_publish_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.publish_context)
  return _internal_mutable_publish_context();
}

// string staging_target_path = 3;
inline void NodeStageVolumeRequest::clear_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.ClearToEmpty();
}
inline const std::string& NodeStageVolumeRequest::staging_target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStageVolumeRequest::set_staging_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline std::string* NodeStageVolumeRequest::mutable_staging_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_staging_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return _s;
}
inline const std::string& NodeStageVolumeRequest::_internal_staging_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.staging_target_path_.Get();
}
inline void NodeStageVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(value, GetArena());
}
inline std::string* NodeStageVolumeRequest::_internal_mutable_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.staging_target_path_.Mutable( GetArena());
}
inline std::string* NodeStageVolumeRequest::release_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return _impl_.staging_target_path_.Release();
}
inline void NodeStageVolumeRequest::set_allocated_staging_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staging_target_path_.IsDefault()) {
          _impl_.staging_target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.staging_target_path)
}

// .csi.v1.VolumeCapability volume_capability = 4;
inline bool NodeStageVolumeRequest::has_volume_capability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_capability_ != nullptr);
  return value;
}
inline void NodeStageVolumeRequest::clear_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_capability_ != nullptr) _impl_.volume_capability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCapability& NodeStageVolumeRequest::_internal_volume_capability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability* p = _impl_.volume_capability_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability&>(::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodeStageVolumeRequest::volume_capability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodeStageVolumeRequest::unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_capability_);
  }
  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeStageVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* released = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::unsafe_arena_release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.volume_capability)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* temp = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::_internal_mutable_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(p);
  }
  return _impl_.volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::mutable_volume_capability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability* _msg = _internal_mutable_volume_capability();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.volume_capability)
  return _msg;
}
inline void NodeStageVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability*>(_impl_.volume_capability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.volume_capability)
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int NodeStageVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int NodeStageVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodeStageVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 6;
inline int NodeStageVolumeRequest::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int NodeStageVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void NodeStageVolumeRequest::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeStageVolumeRequest::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeStageVolumeRequest::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// NodeStageVolumeResponse

// -------------------------------------------------------------------

// NodeUnstageVolumeRequest

// string volume_id = 1;
inline void NodeUnstageVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodeUnstageVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeUnstageVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline std::string* NodeUnstageVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return _s;
}
inline const std::string& NodeUnstageVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodeUnstageVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodeUnstageVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodeUnstageVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodeUnstageVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnstageVolumeRequest.volume_id)
}

// string staging_target_path = 2;
inline void NodeUnstageVolumeRequest::clear_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.ClearToEmpty();
}
inline const std::string& NodeUnstageVolumeRequest::staging_target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeUnstageVolumeRequest::set_staging_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline std::string* NodeUnstageVolumeRequest::mutable_staging_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_staging_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return _s;
}
inline const std::string& NodeUnstageVolumeRequest::_internal_staging_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.staging_target_path_.Get();
}
inline void NodeUnstageVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(value, GetArena());
}
inline std::string* NodeUnstageVolumeRequest::_internal_mutable_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.staging_target_path_.Mutable( GetArena());
}
inline std::string* NodeUnstageVolumeRequest::release_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return _impl_.staging_target_path_.Release();
}
inline void NodeUnstageVolumeRequest::set_allocated_staging_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staging_target_path_.IsDefault()) {
          _impl_.staging_target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}

// -------------------------------------------------------------------

// NodeUnstageVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodePublishVolumeRequest

// string volume_id = 1;
inline void NodePublishVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodePublishVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodePublishVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline std::string* NodePublishVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.volume_id)
  return _s;
}
inline const std::string& NodePublishVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodePublishVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodePublishVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.volume_id)
}

// map<string, string> publish_context = 2;
inline int NodePublishVolumeRequest::_internal_publish_context_size() const {
  return _internal_publish_context().size();
}
inline int NodePublishVolumeRequest::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void NodePublishVolumeRequest::clear_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publish_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::_internal_publish_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::publish_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.publish_context)
  return _internal_publish_context();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::_internal_mutable_publish_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.publish_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::mutable_publish_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.publish_context)
  return _internal_mutable_publish_context();
}

// string staging_target_path = 3;
inline void NodePublishVolumeRequest::clear_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.ClearToEmpty();
}
inline const std::string& NodePublishVolumeRequest::staging_target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodePublishVolumeRequest::set_staging_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline std::string* NodePublishVolumeRequest::mutable_staging_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_staging_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return _s;
}
inline const std::string& NodePublishVolumeRequest::_internal_staging_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.staging_target_path_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(value, GetArena());
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.staging_target_path_.Mutable( GetArena());
}
inline std::string* NodePublishVolumeRequest::release_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return _impl_.staging_target_path_.Release();
}
inline void NodePublishVolumeRequest::set_allocated_staging_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staging_target_path_.IsDefault()) {
          _impl_.staging_target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.staging_target_path)
}

// string target_path = 4;
inline void NodePublishVolumeRequest::clear_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.ClearToEmpty();
}
inline const std::string& NodePublishVolumeRequest::target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.target_path)
  return _internal_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodePublishVolumeRequest::set_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.target_path)
}
inline std::string* NodePublishVolumeRequest::mutable_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.target_path)
  return _s;
}
inline const std::string& NodePublishVolumeRequest::_internal_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_path_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(value, GetArena());
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_path_.Mutable( GetArena());
}
inline std::string* NodePublishVolumeRequest::release_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.target_path)
  return _impl_.target_path_.Release();
}
inline void NodePublishVolumeRequest::set_allocated_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_path_.IsDefault()) {
          _impl_.target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.target_path)
}

// .csi.v1.VolumeCapability volume_capability = 5;
inline bool NodePublishVolumeRequest::has_volume_capability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_capability_ != nullptr);
  return value;
}
inline void NodePublishVolumeRequest::clear_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_capability_ != nullptr) _impl_.volume_capability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCapability& NodePublishVolumeRequest::_internal_volume_capability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability* p = _impl_.volume_capability_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability&>(::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodePublishVolumeRequest::volume_capability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodePublishVolumeRequest::unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_capability_);
  }
  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodePublishVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* released = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::unsafe_arena_release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.volume_capability)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCapability* temp = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::_internal_mutable_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(p);
  }
  return _impl_.volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::mutable_volume_capability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability* _msg = _internal_mutable_volume_capability();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.volume_capability)
  return _msg;
}
inline void NodePublishVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability*>(_impl_.volume_capability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.volume_capability)
}

// bool readonly = 6;
inline void NodePublishVolumeRequest::clear_readonly() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.readonly_ = false;
}
inline bool NodePublishVolumeRequest::readonly() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.readonly)
  return _internal_readonly();
}
inline void NodePublishVolumeRequest::set_readonly(bool value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.readonly)
}
inline bool NodePublishVolumeRequest::_internal_readonly() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.readonly_;
}
inline void NodePublishVolumeRequest::_internal_set_readonly(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.readonly_ = value;
}

// map<string, string> secrets = 7 [(.csi.v1.csi_secret) = true];
inline int NodePublishVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int NodePublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodePublishVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 8;
inline int NodePublishVolumeRequest::_internal_volume_context_size() const {
  return _internal_volume_context().size();
}
inline int NodePublishVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void NodePublishVolumeRequest::clear_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_context_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::_internal_volume_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodePublishVolumeRequest::volume_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::_internal_mutable_volume_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.volume_context_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodePublishVolumeRequest::mutable_volume_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// NodePublishVolumeResponse

// -------------------------------------------------------------------

// NodeUnpublishVolumeRequest

// string volume_id = 1;
inline void NodeUnpublishVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodeUnpublishVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeUnpublishVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline std::string* NodeUnpublishVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return _s;
}
inline const std::string& NodeUnpublishVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodeUnpublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodeUnpublishVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}

// string target_path = 2;
inline void NodeUnpublishVolumeRequest::clear_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.ClearToEmpty();
}
inline const std::string& NodeUnpublishVolumeRequest::target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return _internal_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeUnpublishVolumeRequest::set_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline std::string* NodeUnpublishVolumeRequest::mutable_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return _s;
}
inline const std::string& NodeUnpublishVolumeRequest::_internal_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_path_.Get();
}
inline void NodeUnpublishVolumeRequest::_internal_set_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_path_.Set(value, GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::_internal_mutable_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_path_.Mutable( GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::release_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return _impl_.target_path_.Release();
}
inline void NodeUnpublishVolumeRequest::set_allocated_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_path_.IsDefault()) {
          _impl_.target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnpublishVolumeRequest.target_path)
}

// -------------------------------------------------------------------

// NodeUnpublishVolumeResponse

// -------------------------------------------------------------------

// NodeGetVolumeStatsRequest

// string volume_id = 1;
inline void NodeGetVolumeStatsRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodeGetVolumeStatsRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeGetVolumeStatsRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return _s;
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodeGetVolumeStatsRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}

// string volume_path = 2;
inline void NodeGetVolumeStatsRequest::clear_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_path_.ClearToEmpty();
}
inline const std::string& NodeGetVolumeStatsRequest::volume_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return _internal_volume_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeGetVolumeStatsRequest::set_volume_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_volume_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return _s;
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_volume_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_path_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_volume_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_path_.Set(value, GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_path_.Mutable( GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return _impl_.volume_path_.Release();
}
inline void NodeGetVolumeStatsRequest::set_allocated_volume_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_path_.IsDefault()) {
          _impl_.volume_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}

// string staging_target_path = 3;
inline void NodeGetVolumeStatsRequest::clear_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.ClearToEmpty();
}
inline const std::string& NodeGetVolumeStatsRequest::staging_target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return _internal_staging_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeGetVolumeStatsRequest::set_staging_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_staging_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_staging_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return _s;
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_staging_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.staging_target_path_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_staging_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(value, GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.staging_target_path_.Mutable( GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return _impl_.staging_target_path_.Release();
}
inline void NodeGetVolumeStatsRequest::set_allocated_staging_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staging_target_path_.IsDefault()) {
          _impl_.staging_target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}

// -------------------------------------------------------------------

// NodeGetVolumeStatsResponse

// repeated .csi.v1.VolumeUsage usage = 1;
inline int NodeGetVolumeStatsResponse::_internal_usage_size() const {
  return _internal_usage().size();
}
inline int NodeGetVolumeStatsResponse::usage_size() const {
  return _internal_usage_size();
}
inline void NodeGetVolumeStatsResponse::clear_usage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.usage_.Clear();
}
inline ::csi::v1::VolumeUsage* NodeGetVolumeStatsResponse::mutable_usage(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _internal_mutable_usage()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>* NodeGetVolumeStatsResponse::mutable_usage()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.NodeGetVolumeStatsResponse.usage)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_usage();
}
inline const ::csi::v1::VolumeUsage& NodeGetVolumeStatsResponse::usage(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _internal_usage().Get(index);
}
inline ::csi::v1::VolumeUsage* NodeGetVolumeStatsResponse::add_usage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::VolumeUsage* _add = _internal_mutable_usage()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>& NodeGetVolumeStatsResponse::usage() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _internal_usage();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>&
NodeGetVolumeStatsResponse::_internal_usage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.usage_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::VolumeUsage>*
NodeGetVolumeStatsResponse::_internal_mutable_usage() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.usage_;
}

// .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
inline bool NodeGetVolumeStatsResponse::has_volume_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_condition_ != nullptr);
  return value;
}
inline void NodeGetVolumeStatsResponse::clear_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_condition_ != nullptr) _impl_.volume_condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeCondition& NodeGetVolumeStatsResponse::_internal_volume_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCondition* p = _impl_.volume_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCondition&>(::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& NodeGetVolumeStatsResponse::volume_condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
  return _internal_volume_condition();
}
inline void NodeGetVolumeStatsResponse::unsafe_arena_set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_condition_);
  }
  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* released = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::unsafe_arena_release_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsResponse.volume_condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeCondition* temp = _impl_.volume_condition_;
  _impl_.volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::_internal_mutable_volume_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(p);
  }
  return _impl_.volume_condition_;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::mutable_volume_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCondition* _msg = _internal_mutable_volume_condition();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
  return _msg;
}
inline void NodeGetVolumeStatsResponse::set_allocated_volume_condition(::csi::v1::VolumeCondition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCondition*>(_impl_.volume_condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCondition*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.volume_condition_ = reinterpret_cast<::csi::v1::VolumeCondition*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
}

// -------------------------------------------------------------------

// VolumeUsage

// int64 available = 1;
inline void VolumeUsage::clear_available() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_ = ::int64_t{0};
}
inline ::int64_t VolumeUsage::available() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.available)
  return _internal_available();
}
inline void VolumeUsage::set_available(::int64_t value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.available)
}
inline ::int64_t VolumeUsage::_internal_available() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_;
}
inline void VolumeUsage::_internal_set_available(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.available_ = value;
}

// int64 total = 2;
inline void VolumeUsage::clear_total() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t VolumeUsage::total() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.total)
  return _internal_total();
}
inline void VolumeUsage::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.total)
}
inline ::int64_t VolumeUsage::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void VolumeUsage::_internal_set_total(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// int64 used = 3;
inline void VolumeUsage::clear_used() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.used_ = ::int64_t{0};
}
inline ::int64_t VolumeUsage::used() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.used)
  return _internal_used();
}
inline void VolumeUsage::set_used(::int64_t value) {
  _internal_set_used(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.used)
}
inline ::int64_t VolumeUsage::_internal_used() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.used_;
}
inline void VolumeUsage::_internal_set_used(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.used_ = value;
}

// .csi.v1.VolumeUsage.Unit unit = 4;
inline void VolumeUsage::clear_unit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unit_ = 0;
}
inline ::csi::v1::VolumeUsage_Unit VolumeUsage::unit() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.unit)
  return _internal_unit();
}
inline void VolumeUsage::set_unit(::csi::v1::VolumeUsage_Unit value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.unit)
}
inline ::csi::v1::VolumeUsage_Unit VolumeUsage::_internal_unit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::VolumeUsage_Unit>(_impl_.unit_);
}
inline void VolumeUsage::_internal_set_unit(::csi::v1::VolumeUsage_Unit value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.unit_ = value;
}

// -------------------------------------------------------------------

// VolumeCondition

// bool abnormal = 1;
inline void VolumeCondition::clear_abnormal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.abnormal_ = false;
}
inline bool VolumeCondition::abnormal() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCondition.abnormal)
  return _internal_abnormal();
}
inline void VolumeCondition::set_abnormal(bool value) {
  _internal_set_abnormal(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCondition.abnormal)
}
inline bool VolumeCondition::_internal_abnormal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.abnormal_;
}
inline void VolumeCondition::_internal_set_abnormal(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.abnormal_ = value;
}

// string message = 2;
inline void VolumeCondition::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& VolumeCondition::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCondition.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeCondition::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCondition.message)
}
inline std::string* VolumeCondition::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCondition.message)
  return _s;
}
inline const std::string& VolumeCondition::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void VolumeCondition::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* VolumeCondition::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* VolumeCondition::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCondition.message)
  return _impl_.message_.Release();
}
inline void VolumeCondition::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCondition.message)
}

// -------------------------------------------------------------------

// NodeGetCapabilitiesRequest

// -------------------------------------------------------------------

// NodeGetCapabilitiesResponse

// repeated .csi.v1.NodeServiceCapability capabilities = 1;
inline int NodeGetCapabilitiesResponse::_internal_capabilities_size() const {
  return _internal_capabilities().size();
}
inline int NodeGetCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void NodeGetCapabilitiesResponse::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_.Clear();
}
inline ::csi::v1::NodeServiceCapability* NodeGetCapabilitiesResponse::mutable_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _internal_mutable_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>* NodeGetCapabilitiesResponse::mutable_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capabilities();
}
inline const ::csi::v1::NodeServiceCapability& NodeGetCapabilitiesResponse::capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _internal_capabilities().Get(index);
}
inline ::csi::v1::NodeServiceCapability* NodeGetCapabilitiesResponse::add_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::NodeServiceCapability* _add = _internal_mutable_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>& NodeGetCapabilitiesResponse::capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _internal_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>&
NodeGetCapabilitiesResponse::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::NodeServiceCapability>*
NodeGetCapabilitiesResponse::_internal_mutable_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// NodeServiceCapability_RPC

// .csi.v1.NodeServiceCapability.RPC.Type type = 1;
inline void NodeServiceCapability_RPC::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::csi::v1::NodeServiceCapability_RPC_Type NodeServiceCapability_RPC::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeServiceCapability.RPC.type)
  return _internal_type();
}
inline void NodeServiceCapability_RPC::set_type(::csi::v1::NodeServiceCapability_RPC_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeServiceCapability.RPC.type)
}
inline ::csi::v1::NodeServiceCapability_RPC_Type NodeServiceCapability_RPC::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::NodeServiceCapability_RPC_Type>(_impl_.type_);
}
inline void NodeServiceCapability_RPC::_internal_set_type(::csi::v1::NodeServiceCapability_RPC_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// NodeServiceCapability

// .csi.v1.NodeServiceCapability.RPC rpc = 1;
inline bool NodeServiceCapability::has_rpc() const {
  return type_case() == kRpc;
}
inline bool NodeServiceCapability::_internal_has_rpc() const {
  return type_case() == kRpc;
}
inline void NodeServiceCapability::set_has_rpc() {
  _impl_._oneof_case_[0] = kRpc;
}
inline void NodeServiceCapability::clear_rpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRpc) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rpc_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::release_rpc() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::NodeServiceCapability_RPC& NodeServiceCapability::_internal_rpc() const {
  return type_case() == kRpc ? *_impl_.type_.rpc_ : reinterpret_cast<::csi::v1::NodeServiceCapability_RPC&>(::csi::v1::_NodeServiceCapability_RPC_default_instance_);
}
inline const ::csi::v1::NodeServiceCapability_RPC& NodeServiceCapability::rpc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeServiceCapability.rpc)
  return _internal_rpc();
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeServiceCapability::unsafe_arena_set_allocated_rpc(::csi::v1::NodeServiceCapability_RPC* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rpc();
    _impl_.type_.rpc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeServiceCapability.rpc)
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::_internal_mutable_rpc() {
  if (type_case() != kRpc) {
    clear_type();
    set_has_rpc();
    _impl_.type_.rpc_ = CreateMaybeMessage<::csi::v1::NodeServiceCapability_RPC>(GetArena());
  }
  return _impl_.type_.rpc_;
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::mutable_rpc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::NodeServiceCapability_RPC* _msg = _internal_mutable_rpc();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeServiceCapability.rpc)
  return _msg;
}

inline bool NodeServiceCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void NodeServiceCapability::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline NodeServiceCapability::TypeCase NodeServiceCapability::type_case() const {
  return NodeServiceCapability::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeGetInfoRequest

// -------------------------------------------------------------------

// NodeGetInfoResponse

// string node_id = 1;
inline void NodeGetInfoResponse::clear_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& NodeGetInfoResponse::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeGetInfoResponse::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetInfoResponse.node_id)
}
inline std::string* NodeGetInfoResponse::mutable_node_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetInfoResponse.node_id)
  return _s;
}
inline const std::string& NodeGetInfoResponse::_internal_node_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_id_.Get();
}
inline void NodeGetInfoResponse::_internal_set_node_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.node_id_.Set(value, GetArena());
}
inline std::string* NodeGetInfoResponse::_internal_mutable_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.node_id_.Mutable( GetArena());
}
inline std::string* NodeGetInfoResponse::release_node_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetInfoResponse.node_id)
  return _impl_.node_id_.Release();
}
inline void NodeGetInfoResponse::set_allocated_node_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_id_.IsDefault()) {
          _impl_.node_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetInfoResponse.node_id)
}

// int64 max_volumes_per_node = 2;
inline void NodeGetInfoResponse::clear_max_volumes_per_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_volumes_per_node_ = ::int64_t{0};
}
inline ::int64_t NodeGetInfoResponse::max_volumes_per_node() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.max_volumes_per_node)
  return _internal_max_volumes_per_node();
}
inline void NodeGetInfoResponse::set_max_volumes_per_node(::int64_t value) {
  _internal_set_max_volumes_per_node(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetInfoResponse.max_volumes_per_node)
}
inline ::int64_t NodeGetInfoResponse::_internal_max_volumes_per_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_volumes_per_node_;
}
inline void NodeGetInfoResponse::_internal_set_max_volumes_per_node(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_volumes_per_node_ = value;
}

// .csi.v1.Topology accessible_topology = 3;
inline bool NodeGetInfoResponse::has_accessible_topology() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accessible_topology_ != nullptr);
  return value;
}
inline void NodeGetInfoResponse::clear_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accessible_topology_ != nullptr) _impl_.accessible_topology_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::Topology& NodeGetInfoResponse::_internal_accessible_topology() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::Topology* p = _impl_.accessible_topology_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::Topology&>(::csi::v1::_Topology_default_instance_);
}
inline const ::csi::v1::Topology& NodeGetInfoResponse::accessible_topology() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.accessible_topology)
  return _internal_accessible_topology();
}
inline void NodeGetInfoResponse::unsafe_arena_set_allocated_accessible_topology(::csi::v1::Topology* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accessible_topology_);
  }
  _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetInfoResponse.accessible_topology)
}
inline ::csi::v1::Topology* NodeGetInfoResponse::release_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Topology* released = _impl_.accessible_topology_;
  _impl_.accessible_topology_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::unsafe_arena_release_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetInfoResponse.accessible_topology)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::Topology* temp = _impl_.accessible_topology_;
  _impl_.accessible_topology_ = nullptr;
  return temp;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::_internal_mutable_accessible_topology() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.accessible_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Topology>(GetArena());
    _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(p);
  }
  return _impl_.accessible_topology_;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::mutable_accessible_topology() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::Topology* _msg = _internal_mutable_accessible_topology();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetInfoResponse.accessible_topology)
  return _msg;
}
inline void NodeGetInfoResponse::set_allocated_accessible_topology(::csi::v1::Topology* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::Topology*>(_impl_.accessible_topology_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::Topology*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.accessible_topology_ = reinterpret_cast<::csi::v1::Topology*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetInfoResponse.accessible_topology)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeExpandVolumeRequest

// string volume_id = 1;
inline void NodeExpandVolumeRequest::clear_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.ClearToEmpty();
}
inline const std::string& NodeExpandVolumeRequest::volume_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_id)
  return _internal_volume_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeExpandVolumeRequest::set_volume_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline std::string* NodeExpandVolumeRequest::mutable_volume_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_id)
  return _s;
}
inline const std::string& NodeExpandVolumeRequest::_internal_volume_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_id_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_volume_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_id_.Set(value, GetArena());
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_id_.Mutable( GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_volume_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_id)
  return _impl_.volume_id_.Release();
}
inline void NodeExpandVolumeRequest::set_allocated_volume_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_id_.IsDefault()) {
          _impl_.volume_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_id)
}

// string volume_path = 2;
inline void NodeExpandVolumeRequest::clear_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_path_.ClearToEmpty();
}
inline const std::string& NodeExpandVolumeRequest::volume_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_path)
  return _internal_volume_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeExpandVolumeRequest::set_volume_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline std::string* NodeExpandVolumeRequest::mutable_volume_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_volume_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_path)
  return _s;
}
inline const std::string& NodeExpandVolumeRequest::_internal_volume_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_path_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_volume_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_path_.Set(value, GetArena());
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.volume_path_.Mutable( GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_volume_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_path)
  return _impl_.volume_path_.Release();
}
inline void NodeExpandVolumeRequest::set_allocated_volume_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.volume_path_.IsDefault()) {
          _impl_.volume_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_path)
}

// .csi.v1.CapacityRange capacity_range = 3;
inline bool NodeExpandVolumeRequest::has_capacity_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.capacity_range_ != nullptr);
  return value;
}
inline void NodeExpandVolumeRequest::clear_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.capacity_range_ != nullptr) _impl_.capacity_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::CapacityRange& NodeExpandVolumeRequest::_internal_capacity_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::CapacityRange* p = _impl_.capacity_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::CapacityRange&>(::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& NodeExpandVolumeRequest::capacity_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.capacity_range_);
  }
  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* released = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::unsafe_arena_release_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.capacity_range)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::CapacityRange* temp = _impl_.capacity_range_;
  _impl_.capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::_internal_mutable_capacity_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(p);
  }
  return _impl_.capacity_range_;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::mutable_capacity_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::CapacityRange* _msg = _internal_mutable_capacity_range();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.capacity_range)
  return _msg;
}
inline void NodeExpandVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::CapacityRange*>(_impl_.capacity_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::CapacityRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.capacity_range_ = reinterpret_cast<::csi::v1::CapacityRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.capacity_range)
}

// string staging_target_path = 4;
inline void NodeExpandVolumeRequest::clear_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.ClearToEmpty();
}
inline const std::string& NodeExpandVolumeRequest::staging_target_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeExpandVolumeRequest::set_staging_target_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline std::string* NodeExpandVolumeRequest::mutable_staging_target_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_staging_target_path();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return _s;
}
inline const std::string& NodeExpandVolumeRequest::_internal_staging_target_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.staging_target_path_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.staging_target_path_.Set(value, GetArena());
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.staging_target_path_.Mutable( GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_staging_target_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return _impl_.staging_target_path_.Release();
}
inline void NodeExpandVolumeRequest::set_allocated_staging_target_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.staging_target_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.staging_target_path_.IsDefault()) {
          _impl_.staging_target_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}

// .csi.v1.VolumeCapability volume_capability = 5;
inline bool NodeExpandVolumeRequest::has_volume_capability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.volume_capability_ != nullptr);
  return value;
}
inline void NodeExpandVolumeRequest::clear_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.volume_capability_ != nullptr) _impl_.volume_capability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::csi::v1::VolumeCapability& NodeExpandVolumeRequest::_internal_volume_capability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeCapability* p = _impl_.volume_capability_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeCapability&>(::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodeExpandVolumeRequest::volume_capability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.volume_capability_);
  }
  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeCapability* released = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::unsafe_arena_release_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_capability)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::csi::v1::VolumeCapability* temp = _impl_.volume_capability_;
  _impl_.volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::_internal_mutable_volume_capability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(p);
  }
  return _impl_.volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::mutable_volume_capability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeCapability* _msg = _internal_mutable_volume_capability();
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_capability)
  return _msg;
}
inline void NodeExpandVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeCapability*>(_impl_.volume_capability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeCapability*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.volume_capability_ = reinterpret_cast<::csi::v1::VolumeCapability*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_capability)
}

// map<string, string> secrets = 6 [(.csi.v1.csi_secret) = true, (.csi.v1.alpha_field) = true];
inline int NodeExpandVolumeRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int NodeExpandVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodeExpandVolumeRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeExpandVolumeRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& NodeExpandVolumeRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.NodeExpandVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeExpandVolumeRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* NodeExpandVolumeRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeExpandVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// NodeExpandVolumeResponse

// int64 capacity_bytes = 1;
inline void NodeExpandVolumeResponse::clear_capacity_bytes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capacity_bytes_ = ::int64_t{0};
}
inline ::int64_t NodeExpandVolumeResponse::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeResponse.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void NodeExpandVolumeResponse::set_capacity_bytes(::int64_t value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeResponse.capacity_bytes)
}
inline ::int64_t NodeExpandVolumeResponse::_internal_capacity_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capacity_bytes_;
}
inline void NodeExpandVolumeResponse::_internal_set_capacity_bytes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.capacity_bytes_ = value;
}

// -------------------------------------------------------------------

// GroupControllerGetCapabilitiesRequest

// -------------------------------------------------------------------

// GroupControllerGetCapabilitiesResponse

// repeated .csi.v1.GroupControllerServiceCapability capabilities = 1;
inline int GroupControllerGetCapabilitiesResponse::_internal_capabilities_size() const {
  return _internal_capabilities().size();
}
inline int GroupControllerGetCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void GroupControllerGetCapabilitiesResponse::clear_capabilities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.capabilities_.Clear();
}
inline ::csi::v1::GroupControllerServiceCapability* GroupControllerGetCapabilitiesResponse::mutable_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.GroupControllerGetCapabilitiesResponse.capabilities)
  return _internal_mutable_capabilities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>* GroupControllerGetCapabilitiesResponse::mutable_capabilities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GroupControllerGetCapabilitiesResponse.capabilities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_capabilities();
}
inline const ::csi::v1::GroupControllerServiceCapability& GroupControllerGetCapabilitiesResponse::capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GroupControllerGetCapabilitiesResponse.capabilities)
  return _internal_capabilities().Get(index);
}
inline ::csi::v1::GroupControllerServiceCapability* GroupControllerGetCapabilitiesResponse::add_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::GroupControllerServiceCapability* _add = _internal_mutable_capabilities()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.GroupControllerGetCapabilitiesResponse.capabilities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>& GroupControllerGetCapabilitiesResponse::capabilities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.GroupControllerGetCapabilitiesResponse.capabilities)
  return _internal_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>&
GroupControllerGetCapabilitiesResponse::_internal_capabilities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::GroupControllerServiceCapability>*
GroupControllerGetCapabilitiesResponse::_internal_mutable_capabilities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// GroupControllerServiceCapability_RPC

// .csi.v1.GroupControllerServiceCapability.RPC.Type type = 1;
inline void GroupControllerServiceCapability_RPC::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::csi::v1::GroupControllerServiceCapability_RPC_Type GroupControllerServiceCapability_RPC::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.GroupControllerServiceCapability.RPC.type)
  return _internal_type();
}
inline void GroupControllerServiceCapability_RPC::set_type(::csi::v1::GroupControllerServiceCapability_RPC_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.GroupControllerServiceCapability.RPC.type)
}
inline ::csi::v1::GroupControllerServiceCapability_RPC_Type GroupControllerServiceCapability_RPC::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::csi::v1::GroupControllerServiceCapability_RPC_Type>(_impl_.type_);
}
inline void GroupControllerServiceCapability_RPC::_internal_set_type(::csi::v1::GroupControllerServiceCapability_RPC_Type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// GroupControllerServiceCapability

// .csi.v1.GroupControllerServiceCapability.RPC rpc = 1;
inline bool GroupControllerServiceCapability::has_rpc() const {
  return type_case() == kRpc;
}
inline bool GroupControllerServiceCapability::_internal_has_rpc() const {
  return type_case() == kRpc;
}
inline void GroupControllerServiceCapability::set_has_rpc() {
  _impl_._oneof_case_[0] = kRpc;
}
inline void GroupControllerServiceCapability::clear_rpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRpc) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rpc_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::GroupControllerServiceCapability_RPC* GroupControllerServiceCapability::release_rpc() {
  // @@protoc_insertion_point(field_release:csi.v1.GroupControllerServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::GroupControllerServiceCapability_RPC& GroupControllerServiceCapability::_internal_rpc() const {
  return type_case() == kRpc ? *_impl_.type_.rpc_ : reinterpret_cast<::csi::v1::GroupControllerServiceCapability_RPC&>(::csi::v1::_GroupControllerServiceCapability_RPC_default_instance_);
}
inline const ::csi::v1::GroupControllerServiceCapability_RPC& GroupControllerServiceCapability::rpc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GroupControllerServiceCapability.rpc)
  return _internal_rpc();
}
inline ::csi::v1::GroupControllerServiceCapability_RPC* GroupControllerServiceCapability::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.GroupControllerServiceCapability.rpc)
  if (type_case() == kRpc) {
    clear_has_type();
    auto* temp = _impl_.type_.rpc_;
    _impl_.type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GroupControllerServiceCapability::unsafe_arena_set_allocated_rpc(::csi::v1::GroupControllerServiceCapability_RPC* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rpc();
    _impl_.type_.rpc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GroupControllerServiceCapability.rpc)
}
inline ::csi::v1::GroupControllerServiceCapability_RPC* GroupControllerServiceCapability::_internal_mutable_rpc() {
  if (type_case() != kRpc) {
    clear_type();
    set_has_rpc();
    _impl_.type_.rpc_ = CreateMaybeMessage<::csi::v1::GroupControllerServiceCapability_RPC>(GetArena());
  }
  return _impl_.type_.rpc_;
}
inline ::csi::v1::GroupControllerServiceCapability_RPC* GroupControllerServiceCapability::mutable_rpc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::GroupControllerServiceCapability_RPC* _msg = _internal_mutable_rpc();
  // @@protoc_insertion_point(field_mutable:csi.v1.GroupControllerServiceCapability.rpc)
  return _msg;
}

inline bool GroupControllerServiceCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void GroupControllerServiceCapability::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline GroupControllerServiceCapability::TypeCase GroupControllerServiceCapability::type_case() const {
  return GroupControllerServiceCapability::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateVolumeGroupSnapshotRequest

// string name = 1;
inline void CreateVolumeGroupSnapshotRequest::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateVolumeGroupSnapshotRequest::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeGroupSnapshotRequest.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateVolumeGroupSnapshotRequest::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.CreateVolumeGroupSnapshotRequest.name)
}
inline std::string* CreateVolumeGroupSnapshotRequest::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeGroupSnapshotRequest.name)
  return _s;
}
inline const std::string& CreateVolumeGroupSnapshotRequest::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void CreateVolumeGroupSnapshotRequest::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* CreateVolumeGroupSnapshotRequest::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* CreateVolumeGroupSnapshotRequest::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeGroupSnapshotRequest.name)
  return _impl_.name_.Release();
}
inline void CreateVolumeGroupSnapshotRequest::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeGroupSnapshotRequest.name)
}

// repeated string source_volume_ids = 2;
inline int CreateVolumeGroupSnapshotRequest::_internal_source_volume_ids_size() const {
  return _internal_source_volume_ids().size();
}
inline int CreateVolumeGroupSnapshotRequest::source_volume_ids_size() const {
  return _internal_source_volume_ids_size();
}
inline void CreateVolumeGroupSnapshotRequest::clear_source_volume_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_volume_ids_.Clear();
}
inline std::string* CreateVolumeGroupSnapshotRequest::add_source_volume_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_source_volume_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
  return _s;
}
inline const std::string& CreateVolumeGroupSnapshotRequest::source_volume_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
  return _internal_source_volume_ids().Get(index);
}
inline std::string* CreateVolumeGroupSnapshotRequest::mutable_source_volume_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
  return _internal_mutable_source_volume_ids()->Mutable(index);
}
inline void CreateVolumeGroupSnapshotRequest::set_source_volume_ids(int index, const std::string& value) {
  _internal_mutable_source_volume_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::set_source_volume_ids(int index, std::string&& value) {
  _internal_mutable_source_volume_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::set_source_volume_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_source_volume_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::set_source_volume_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_source_volume_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::set_source_volume_ids(int index, absl::string_view value) {
  _internal_mutable_source_volume_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::add_source_volume_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_source_volume_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::add_source_volume_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_source_volume_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::add_source_volume_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_source_volume_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::add_source_volume_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_source_volume_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline void CreateVolumeGroupSnapshotRequest::add_source_volume_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_source_volume_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateVolumeGroupSnapshotRequest::source_volume_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
  return _internal_source_volume_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateVolumeGroupSnapshotRequest::mutable_source_volume_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.CreateVolumeGroupSnapshotRequest.source_volume_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_source_volume_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateVolumeGroupSnapshotRequest::_internal_source_volume_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_volume_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateVolumeGroupSnapshotRequest::_internal_mutable_source_volume_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.source_volume_ids_;
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int CreateVolumeGroupSnapshotRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int CreateVolumeGroupSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void CreateVolumeGroupSnapshotRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeGroupSnapshotRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeGroupSnapshotRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeGroupSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeGroupSnapshotRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeGroupSnapshotRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeGroupSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> parameters = 4;
inline int CreateVolumeGroupSnapshotRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int CreateVolumeGroupSnapshotRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void CreateVolumeGroupSnapshotRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeGroupSnapshotRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& CreateVolumeGroupSnapshotRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeGroupSnapshotRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeGroupSnapshotRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* CreateVolumeGroupSnapshotRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeGroupSnapshotRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// CreateVolumeGroupSnapshotResponse

// .csi.v1.VolumeGroupSnapshot group_snapshot = 1;
inline bool CreateVolumeGroupSnapshotResponse::has_group_snapshot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_snapshot_ != nullptr);
  return value;
}
inline void CreateVolumeGroupSnapshotResponse::clear_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.group_snapshot_ != nullptr) _impl_.group_snapshot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeGroupSnapshot& CreateVolumeGroupSnapshotResponse::_internal_group_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeGroupSnapshot* p = _impl_.group_snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeGroupSnapshot&>(::csi::v1::_VolumeGroupSnapshot_default_instance_);
}
inline const ::csi::v1::VolumeGroupSnapshot& CreateVolumeGroupSnapshotResponse::group_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot)
  return _internal_group_snapshot();
}
inline void CreateVolumeGroupSnapshotResponse::unsafe_arena_set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_snapshot_);
  }
  _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot)
}
inline ::csi::v1::VolumeGroupSnapshot* CreateVolumeGroupSnapshotResponse::release_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeGroupSnapshot* released = _impl_.group_snapshot_;
  _impl_.group_snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeGroupSnapshot* CreateVolumeGroupSnapshotResponse::unsafe_arena_release_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeGroupSnapshot* temp = _impl_.group_snapshot_;
  _impl_.group_snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeGroupSnapshot* CreateVolumeGroupSnapshotResponse::_internal_mutable_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeGroupSnapshot>(GetArena());
    _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(p);
  }
  return _impl_.group_snapshot_;
}
inline ::csi::v1::VolumeGroupSnapshot* CreateVolumeGroupSnapshotResponse::mutable_group_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeGroupSnapshot* _msg = _internal_mutable_group_snapshot();
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot)
  return _msg;
}
inline void CreateVolumeGroupSnapshotResponse::set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(_impl_.group_snapshot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeGroupSnapshotResponse.group_snapshot)
}

// -------------------------------------------------------------------

// VolumeGroupSnapshot

// string group_snapshot_id = 1;
inline void VolumeGroupSnapshot::clear_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.ClearToEmpty();
}
inline const std::string& VolumeGroupSnapshot::group_snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeGroupSnapshot.group_snapshot_id)
  return _internal_group_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VolumeGroupSnapshot::set_group_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.VolumeGroupSnapshot.group_snapshot_id)
}
inline std::string* VolumeGroupSnapshot::mutable_group_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeGroupSnapshot.group_snapshot_id)
  return _s;
}
inline const std::string& VolumeGroupSnapshot::_internal_group_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_snapshot_id_.Get();
}
inline void VolumeGroupSnapshot::_internal_set_group_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(value, GetArena());
}
inline std::string* VolumeGroupSnapshot::_internal_mutable_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_snapshot_id_.Mutable( GetArena());
}
inline std::string* VolumeGroupSnapshot::release_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeGroupSnapshot.group_snapshot_id)
  return _impl_.group_snapshot_id_.Release();
}
inline void VolumeGroupSnapshot::set_allocated_group_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_snapshot_id_.IsDefault()) {
          _impl_.group_snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeGroupSnapshot.group_snapshot_id)
}

// repeated .csi.v1.Snapshot snapshots = 2;
inline int VolumeGroupSnapshot::_internal_snapshots_size() const {
  return _internal_snapshots().size();
}
inline int VolumeGroupSnapshot::snapshots_size() const {
  return _internal_snapshots_size();
}
inline void VolumeGroupSnapshot::clear_snapshots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshots_.Clear();
}
inline ::csi::v1::Snapshot* VolumeGroupSnapshot::mutable_snapshots(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeGroupSnapshot.snapshots)
  return _internal_mutable_snapshots()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>* VolumeGroupSnapshot::mutable_snapshots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.VolumeGroupSnapshot.snapshots)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_snapshots();
}
inline const ::csi::v1::Snapshot& VolumeGroupSnapshot::snapshots(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeGroupSnapshot.snapshots)
  return _internal_snapshots().Get(index);
}
inline ::csi::v1::Snapshot* VolumeGroupSnapshot::add_snapshots() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::csi::v1::Snapshot* _add = _internal_mutable_snapshots()->Add();
  // @@protoc_insertion_point(field_add:csi.v1.VolumeGroupSnapshot.snapshots)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>& VolumeGroupSnapshot::snapshots() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.VolumeGroupSnapshot.snapshots)
  return _internal_snapshots();
}
inline const ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>&
VolumeGroupSnapshot::_internal_snapshots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshots_;
}
inline ::google::protobuf::RepeatedPtrField<::csi::v1::Snapshot>*
VolumeGroupSnapshot::_internal_mutable_snapshots() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.snapshots_;
}

// .google.protobuf.Timestamp creation_time = 3;
inline bool VolumeGroupSnapshot::has_creation_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.creation_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& VolumeGroupSnapshot::_internal_creation_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.creation_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& VolumeGroupSnapshot::creation_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeGroupSnapshot.creation_time)
  return _internal_creation_time();
}
inline void VolumeGroupSnapshot::unsafe_arena_set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }
  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeGroupSnapshot.creation_time)
}
inline ::google::protobuf::Timestamp* VolumeGroupSnapshot::release_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* VolumeGroupSnapshot::unsafe_arena_release_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.VolumeGroupSnapshot.creation_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.creation_time_;
  _impl_.creation_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* VolumeGroupSnapshot::_internal_mutable_creation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.creation_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.creation_time_;
}
inline ::google::protobuf::Timestamp* VolumeGroupSnapshot::mutable_creation_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_creation_time();
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeGroupSnapshot.creation_time)
  return _msg;
}
inline void VolumeGroupSnapshot::set_allocated_creation_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.creation_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.creation_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeGroupSnapshot.creation_time)
}

// bool ready_to_use = 4;
inline void VolumeGroupSnapshot::clear_ready_to_use() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ready_to_use_ = false;
}
inline bool VolumeGroupSnapshot::ready_to_use() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeGroupSnapshot.ready_to_use)
  return _internal_ready_to_use();
}
inline void VolumeGroupSnapshot::set_ready_to_use(bool value) {
  _internal_set_ready_to_use(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeGroupSnapshot.ready_to_use)
}
inline bool VolumeGroupSnapshot::_internal_ready_to_use() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ready_to_use_;
}
inline void VolumeGroupSnapshot::_internal_set_ready_to_use(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ready_to_use_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteVolumeGroupSnapshotRequest

// string group_snapshot_id = 1;
inline void DeleteVolumeGroupSnapshotRequest::clear_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.ClearToEmpty();
}
inline const std::string& DeleteVolumeGroupSnapshotRequest::group_snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteVolumeGroupSnapshotRequest.group_snapshot_id)
  return _internal_group_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteVolumeGroupSnapshotRequest::set_group_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.DeleteVolumeGroupSnapshotRequest.group_snapshot_id)
}
inline std::string* DeleteVolumeGroupSnapshotRequest::mutable_group_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteVolumeGroupSnapshotRequest.group_snapshot_id)
  return _s;
}
inline const std::string& DeleteVolumeGroupSnapshotRequest::_internal_group_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_snapshot_id_.Get();
}
inline void DeleteVolumeGroupSnapshotRequest::_internal_set_group_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(value, GetArena());
}
inline std::string* DeleteVolumeGroupSnapshotRequest::_internal_mutable_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_snapshot_id_.Mutable( GetArena());
}
inline std::string* DeleteVolumeGroupSnapshotRequest::release_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.DeleteVolumeGroupSnapshotRequest.group_snapshot_id)
  return _impl_.group_snapshot_id_.Release();
}
inline void DeleteVolumeGroupSnapshotRequest::set_allocated_group_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_snapshot_id_.IsDefault()) {
          _impl_.group_snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.DeleteVolumeGroupSnapshotRequest.group_snapshot_id)
}

// repeated string snapshot_ids = 2;
inline int DeleteVolumeGroupSnapshotRequest::_internal_snapshot_ids_size() const {
  return _internal_snapshot_ids().size();
}
inline int DeleteVolumeGroupSnapshotRequest::snapshot_ids_size() const {
  return _internal_snapshot_ids_size();
}
inline void DeleteVolumeGroupSnapshotRequest::clear_snapshot_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ids_.Clear();
}
inline std::string* DeleteVolumeGroupSnapshotRequest::add_snapshot_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_snapshot_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
  return _s;
}
inline const std::string& DeleteVolumeGroupSnapshotRequest::snapshot_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_snapshot_ids().Get(index);
}
inline std::string* DeleteVolumeGroupSnapshotRequest::mutable_snapshot_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_mutable_snapshot_ids()->Mutable(index);
}
inline void DeleteVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const std::string& value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::set_snapshot_ids(int index, std::string&& value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::set_snapshot_ids(int index, absl::string_view value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::add_snapshot_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::add_snapshot_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::add_snapshot_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::add_snapshot_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void DeleteVolumeGroupSnapshotRequest::add_snapshot_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DeleteVolumeGroupSnapshotRequest::snapshot_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_snapshot_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DeleteVolumeGroupSnapshotRequest::mutable_snapshot_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.DeleteVolumeGroupSnapshotRequest.snapshot_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_snapshot_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DeleteVolumeGroupSnapshotRequest::_internal_snapshot_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DeleteVolumeGroupSnapshotRequest::_internal_mutable_snapshot_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.snapshot_ids_;
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int DeleteVolumeGroupSnapshotRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int DeleteVolumeGroupSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void DeleteVolumeGroupSnapshotRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteVolumeGroupSnapshotRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& DeleteVolumeGroupSnapshotRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.DeleteVolumeGroupSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteVolumeGroupSnapshotRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* DeleteVolumeGroupSnapshotRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.DeleteVolumeGroupSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// DeleteVolumeGroupSnapshotResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetVolumeGroupSnapshotRequest

// string group_snapshot_id = 1;
inline void GetVolumeGroupSnapshotRequest::clear_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.ClearToEmpty();
}
inline const std::string& GetVolumeGroupSnapshotRequest::group_snapshot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetVolumeGroupSnapshotRequest.group_snapshot_id)
  return _internal_group_snapshot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetVolumeGroupSnapshotRequest::set_group_snapshot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:csi.v1.GetVolumeGroupSnapshotRequest.group_snapshot_id)
}
inline std::string* GetVolumeGroupSnapshotRequest::mutable_group_snapshot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_group_snapshot_id();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetVolumeGroupSnapshotRequest.group_snapshot_id)
  return _s;
}
inline const std::string& GetVolumeGroupSnapshotRequest::_internal_group_snapshot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_snapshot_id_.Get();
}
inline void GetVolumeGroupSnapshotRequest::_internal_set_group_snapshot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.group_snapshot_id_.Set(value, GetArena());
}
inline std::string* GetVolumeGroupSnapshotRequest::_internal_mutable_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.group_snapshot_id_.Mutable( GetArena());
}
inline std::string* GetVolumeGroupSnapshotRequest::release_group_snapshot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetVolumeGroupSnapshotRequest.group_snapshot_id)
  return _impl_.group_snapshot_id_.Release();
}
inline void GetVolumeGroupSnapshotRequest::set_allocated_group_snapshot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_snapshot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.group_snapshot_id_.IsDefault()) {
          _impl_.group_snapshot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetVolumeGroupSnapshotRequest.group_snapshot_id)
}

// repeated string snapshot_ids = 2;
inline int GetVolumeGroupSnapshotRequest::_internal_snapshot_ids_size() const {
  return _internal_snapshot_ids().size();
}
inline int GetVolumeGroupSnapshotRequest::snapshot_ids_size() const {
  return _internal_snapshot_ids_size();
}
inline void GetVolumeGroupSnapshotRequest::clear_snapshot_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.snapshot_ids_.Clear();
}
inline std::string* GetVolumeGroupSnapshotRequest::add_snapshot_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_snapshot_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
  return _s;
}
inline const std::string& GetVolumeGroupSnapshotRequest::snapshot_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_snapshot_ids().Get(index);
}
inline std::string* GetVolumeGroupSnapshotRequest::mutable_snapshot_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_mutable_snapshot_ids()->Mutable(index);
}
inline void GetVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const std::string& value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::set_snapshot_ids(int index, std::string&& value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::set_snapshot_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::set_snapshot_ids(int index, absl::string_view value) {
  _internal_mutable_snapshot_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::add_snapshot_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::add_snapshot_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::add_snapshot_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::add_snapshot_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline void GetVolumeGroupSnapshotRequest::add_snapshot_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_snapshot_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetVolumeGroupSnapshotRequest::snapshot_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
  return _internal_snapshot_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetVolumeGroupSnapshotRequest::mutable_snapshot_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GetVolumeGroupSnapshotRequest.snapshot_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_snapshot_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetVolumeGroupSnapshotRequest::_internal_snapshot_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.snapshot_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetVolumeGroupSnapshotRequest::_internal_mutable_snapshot_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.snapshot_ids_;
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int GetVolumeGroupSnapshotRequest::_internal_secrets_size() const {
  return _internal_secrets().size();
}
inline int GetVolumeGroupSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void GetVolumeGroupSnapshotRequest::clear_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secrets_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetVolumeGroupSnapshotRequest::_internal_secrets() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secrets_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GetVolumeGroupSnapshotRequest::secrets() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:csi.v1.GetVolumeGroupSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::google::protobuf::Map<std::string, std::string>* GetVolumeGroupSnapshotRequest::_internal_mutable_secrets() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.secrets_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GetVolumeGroupSnapshotRequest::mutable_secrets() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.GetVolumeGroupSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// GetVolumeGroupSnapshotResponse

// .csi.v1.VolumeGroupSnapshot group_snapshot = 1;
inline bool GetVolumeGroupSnapshotResponse::has_group_snapshot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.group_snapshot_ != nullptr);
  return value;
}
inline void GetVolumeGroupSnapshotResponse::clear_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.group_snapshot_ != nullptr) _impl_.group_snapshot_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::csi::v1::VolumeGroupSnapshot& GetVolumeGroupSnapshotResponse::_internal_group_snapshot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::csi::v1::VolumeGroupSnapshot* p = _impl_.group_snapshot_;
  return p != nullptr ? *p : reinterpret_cast<const ::csi::v1::VolumeGroupSnapshot&>(::csi::v1::_VolumeGroupSnapshot_default_instance_);
}
inline const ::csi::v1::VolumeGroupSnapshot& GetVolumeGroupSnapshotResponse::group_snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot)
  return _internal_group_snapshot();
}
inline void GetVolumeGroupSnapshotResponse::unsafe_arena_set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.group_snapshot_);
  }
  _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot)
}
inline ::csi::v1::VolumeGroupSnapshot* GetVolumeGroupSnapshotResponse::release_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeGroupSnapshot* released = _impl_.group_snapshot_;
  _impl_.group_snapshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::csi::v1::VolumeGroupSnapshot* GetVolumeGroupSnapshotResponse::unsafe_arena_release_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::csi::v1::VolumeGroupSnapshot* temp = _impl_.group_snapshot_;
  _impl_.group_snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeGroupSnapshot* GetVolumeGroupSnapshotResponse::_internal_mutable_group_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.group_snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeGroupSnapshot>(GetArena());
    _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(p);
  }
  return _impl_.group_snapshot_;
}
inline ::csi::v1::VolumeGroupSnapshot* GetVolumeGroupSnapshotResponse::mutable_group_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::csi::v1::VolumeGroupSnapshot* _msg = _internal_mutable_group_snapshot();
  // @@protoc_insertion_point(field_mutable:csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot)
  return _msg;
}
inline void GetVolumeGroupSnapshotResponse::set_allocated_group_snapshot(::csi::v1::VolumeGroupSnapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(_impl_.group_snapshot_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.group_snapshot_ = reinterpret_cast<::csi::v1::VolumeGroupSnapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetVolumeGroupSnapshotResponse.group_snapshot)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace csi


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::csi::v1::PluginCapability_Service_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::PluginCapability_Service_Type>() {
  return ::csi::v1::PluginCapability_Service_Type_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::PluginCapability_VolumeExpansion_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::PluginCapability_VolumeExpansion_Type>() {
  return ::csi::v1::PluginCapability_VolumeExpansion_Type_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::VolumeCapability_AccessMode_Mode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::VolumeCapability_AccessMode_Mode>() {
  return ::csi::v1::VolumeCapability_AccessMode_Mode_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::ControllerServiceCapability_RPC_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::ControllerServiceCapability_RPC_Type>() {
  return ::csi::v1::ControllerServiceCapability_RPC_Type_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::VolumeUsage_Unit> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::VolumeUsage_Unit>() {
  return ::csi::v1::VolumeUsage_Unit_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::NodeServiceCapability_RPC_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::NodeServiceCapability_RPC_Type>() {
  return ::csi::v1::NodeServiceCapability_RPC_Type_descriptor();
}
template <>
struct is_proto_enum<::csi::v1::GroupControllerServiceCapability_RPC_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::csi::v1::GroupControllerServiceCapability_RPC_Type>() {
  return ::csi::v1::GroupControllerServiceCapability_RPC_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_lib_2fcxx_2f_2eprotoc_2fcsi_2eproto_2epb_2eh
